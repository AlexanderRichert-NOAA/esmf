\section{Test Harness (DRAFT)}
\label{sec:harness}


%%%%%%%%%%%%%%%%%%%%
% Test Harness Overview
The Test Harness is a flexible test control system intended to provide a thorough parameter space exploration of remapping and redistribution of distributed arrays and fields.

The Test Harness consists of a single shared executable and a collection of customizable helper configuration files located within the \texttt{tests} directory of each class. The Test Harness is integrated into the Unit test framework, enabling the Test Harness to be built and run as part of the Unit tests. The test results are reported to a single standard-out file which is located with the unit test results.

%%%%%%%%%%%%%%%%%%%%
\subsection{Test Harness Structure}
The Test Harness source code is  located in the \texttt{esmf/src/test\_harness/src/} directory. The test harness code consists of a single executable that runs as a Unit test. The executable is augmented by a hierarchy  of customizable configuration files which are located within and below the \texttt{tests/} directory of each class; currently Array and Field. These configuration files are combined by the executable to generate specific test configurations. 

The top level configuration file is called \texttt{test\_harness.rc} and is located in the \texttt{tests/} directory of each class; e.g. \texttt{esmf/src/Infrastructure/\$CLASS/tests/}. The top level helper file called \texttt{test\_harness.rc} is unique to each class and specifies the test class, the format for reporting the test results, and the location and file names containing the \textit{problem descriptor files}. The \textit{problem descriptor files} are the next level of configuration files used by the test harness routines.

The \textit{problem descriptor files} contain a collection of \textit{problem descriptor strings}, each of which describe, by use of the field taxonomy syntax, a family of problems with the same memory topology, distribution, and grid association. The table below summarizes what is defined by a problem descriptor string.  
\begin{center}
\begin{tabular}{|l|} \hline \hline
Problem Descriptor Strings \\
\hline
memory shape and rank \\
type of memory distribution (block, block cyclic, or arbitrary) \\
grid association with memory location \\
grid stagger location \\
memory halo \\
\hline
\end{tabular}
\end{center}
For instance, a \textit{problem descriptor string} might describe the ensemble of all redistributions between a pair of two-dimensional blocks memory, each with a specific type of distribution and grid association. What it does not define is information such as the type, size, and coordinates of the grid, or the size of the distribution.

The \textit{problem descriptor strings} are augmented by a collection of three \textit{specifier files} which complete the description of the test configuration. The three types of specifier files define the grid, the distribution, and the class specific information needed to completely define a test.

The Grid specifier file defines the type of grid, its size, the topology of the domain, and the grid coordinates. The table below summarizes of what is defined by the grid specifier file.  
\begin{center}
\begin{tabular}{|l|} \hline \hline
Grid Specifier File \\
\hline
grid type (uniform and irregular rectilinear, or curvilinear) \\
grid rank \\
grid size \\
grid coordinates \\
grid connectivity (periodic, etc.) \\
\hline
\end{tabular}
\end{center}

The Distribution specifier file defines the size of the source and destination distribution. The table below summarizes of what is defined by this file. 
\begin{center}
\begin{tabular}{|l|} \hline \hline
Distribution Specifier File \\
\hline
distribution rank \\
distribution size \\
\hline
\end{tabular}
\end{center}
 Both the problem descriptor files and the specifier files are located in the subdirectory \texttt{tests/test\_config/} within the class directory.

The motivation for employing such a hierarchy configuration files is to allow a high degree of customization of the problem configuration by combining individual specification files. In addition it was desired to make the specification files as simple to read as is possbile so that user is not forced to engage in complicated encoding to specify a problem. The end result is that each class will have its own collection of specification files tailored to the needs of that class.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Specification of Test Configuration}
The ensemble of tests specific to an {ESMF\_CLASS} is specified by three levels of customizable configuration files. The top level file called \texttt{test\_harness.rc}. It is located within each classes' \texttt{tests/} directory and contains class specific attributes as well as a list of the next level of configuration files known as the \texttt{problem descriptor files}. The problem descriptor files contain the \texttt{problem descriptor strings}, which define a general family of problems, as well as the associated \texttt{problem specifier files} which are the final level of configuration files. The test harness combines these three levels of configuration files to generate the specific test configurations. 

The specifier files indicate which members of the family described by the \texttt{problem descriptor string} will be tested. The nature of the specifier files varies depending on whether a redistribution or remapping test is specified. A redistribution test takes a field associated with a grid and rearranges it in processor space. Therefore a source and destination distribution are needed, but only a single grid needs to be specified. A remapping test takes a field associated with a source grid and interpolates it to a destination grid. So both a source and destination grid specification are needed in addition to a source and destination distribution.

%\medskip
\begin{center}
\begin{tabular}{| c | c |} \hline \hline
{\em Redistribution} & {\em Remapping} \\
\hline
source grid & source \& destination grids  \\
source \& destination distribution &  source \& destination distribution \\
\hline
\end{tabular}
\end{center}
%\medskip

 
%%%%%%%%%%%%%%%%%%
\subsubsection{Top level helper file}
The top level helper file \texttt{test\_harness.rc} is unique to each class. It specifies the test class, the style of test result reporting, and lists the names of the \textit{problem descriptor files}. These descriptor files are categorized into two sets. The first set lists the filenames that associated with the \textbf{NONEXHAUSTIVE} test suite, and the second set lists the filename that associated with the \textbf{EXHAUSTIVE} test suite. 

Below is an example of the file \texttt{test\_harness.rc} for the \texttt{ESMF\_Field} class. Notice that comments are preceded by the {\#} sign, and that parameter values follow a single colon {:} punctuation mark, while tables follow, and are terminated, by a double set of colon {::} punctuation marks.  This file is read by the \texttt{ESMF\_Config} class methods, therefore must adhere to very specific syntax requirements. The entries can be in any order, but the name tags must be exact - including capitalization. In addition, while not strictly necessary, the file names are enclosed in quotation marks, either single or double, to guarantee they are read correctly.
\begin{verbatim}
# Field test Harness Config file

# test class
test_class: FIELD 

# request extra report
#       -2 = debug dump
#       -1 = report test failures 
#        0 = no output
#        1 = report successful tests
#        2 = report both successes and failures.
test_report: 0 

# descriptor file for the nonexhaustive case
nonexhaustive::
   'nonexhaustive_descriptor.rc'
::   # end of list

# descriptor files for the exhaustive case
exhaustive::
   'exhaustive_descriptor.rc'
   'even_more_exhaustive_descriptor.rc'
:: # end of list
\end{verbatim}

The argument for the tag \texttt{test\_class:} specifies the ESMF class to be tested. Here it is Field. The tag  \texttt{test\_report:} specifies the style of report to be constructed. This report is appended to the standard-out file which is located with the Unit test results. The tag \texttt{nonexhaustive::} delimits a table which contains the file names of problem descriptor files pertaining to a nonexhaustive test configuration. Likewise the tag \texttt{exhaustive::} delimits a table for the exhaustive case. Each table may contain any number of problem descriptor file names. Here the exhaustive case inputs two problem descriptor files, \texttt{exhaustive\_descriptor.rc} and \texttt{even\_more\_exhaustive\_descriptor.rc}.

%%%%%%%%%%%%%%%%%%
\subsubsection{Problem descriptor file}
All of the problem descriptor files pertaining to the current class live in the local directory \texttt{tests/test\_config}.

The problem descriptor files contain \textit{descriptor strings} that describe the family of problems with the same memory topology, distribution, and grid association. The files also contain the names of \textit{specifier files} which complete the descriptions contained within the descriptor strings. This structure allows a high level of customization of the test suite.

The problem descriptor file contains only one table, again conforming to the \texttt{ESMF\_Config} class standard. The contents of the table must be delimited by the tag \texttt{problem\_descriptor\_string::}. The first element on the line, enclosed by quotes, is the problem descriptor string itself. Since the descriptor strings have gaps, it is necessary that they are enclosed in quotation marks to guarantee they are read correctly. The problem descriptor table may contain any number of descriptor strings, up to the limit imposed by the \texttt{ESMF\_Config} class, each on a new line. Lines can be continued by use of an ampersand {\&} as a continuation symbol at the beginning of any continued line. The syntax of the problem descriptor string follows the field taxonomy syntax discussed in section~\ref{}. Here is a basic redistribution example.
\begin{verbatim}
# Basic redistribution example
#####################################
problem_descriptor_string::
'[B1G1;B2G2] --> [B1G1;B2G2]' -c FieldClass.rc -d DistGrid.rc -g Grid.rc 
'[B1G1;B2G2] --> [B1G2;B2G1]' -c fieldClass.rc -d DistGrid.rc 
 & otherDistGrid.rc yetanotherDistGrid.rc
 &  -g Grid.rc   
::   # end of list
\end{verbatim}
In the above example, the two problem descriptor strings specify that a redistribution test is to be conducted, indicated by the syntax  \texttt{-->}, between two rank two blocks of memory. Following the problem descriptor string, are multiple flags and the names of specifier files. Each flag indicates a portion of the configuration space which is defined by the contents of the indicated specifier files.  
\begin{center}
\begin{tabular}{| c | c |} \hline \hline
{\em argument } & {\em definition} \\
\hline
-c &  Class specific information \\
-d & DELayout/DistGrid specification \\
-g & Grid specification \\
\hline 
\end{tabular}
\end{center}
The files that follow a flag, are used to specify the values for the parameter associated with that flag. The specified values from each file are combined to define that parameter's span of values.  All the files associated with all the flags are combined to define the full ensemble of tests. So in the first problem descriptor string of the example, the ensemble of distribution configurations to be tested are specified by the configurations contained within the file \texttt{DistGrid.rc}. Similarly, the range of grid configurations are specified within the single file \texttt{Grid.rc}. For the second problem descriptor string, the ensemble of distribution configurations to be tested are specified by the union of configurations contained within the three files \texttt{DistGrid.rc}, \texttt{otherDistGrid.rc}, and \texttt{yetanotherDistGrid.rc}. Just as before, the range of grid configurations are specified within the single file \texttt{Grid.rc}.


%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Problem descriptor syntax}
The problem descriptor string is contained in the problem descriptor file and describes a class of tests to be conducted. The basic syntax describes a contiguous chunk of memory spanned by some sort of logically rectangular indexing, where the left most index varies fastest in memory. Each semicolon delineated entry is associated with a native array dimension. The index locations are replaced by signifiers that express associations and distributions of the memory through the use of short descriptors. 

For example $[ G1 \; ; G2 ]$ indicates that a 2D logically rectangular block of memory is associated with a 2D grid in its natural order. The signifier $G$ represents an undistributed grid. Reversing the grid signifiers $[ G2; G1 ]$ indicates that the fastest varying dimension is instead associated with the second grid dimension. Specific information about the grid, such as its size, type, topology are left to be defined by the specifier files. It is the associations between memory and the grid that are stressed with this syntax.

To distribute the grid, a distribution signifier is needed. The block distribution of each memory dimension is specified by the signifier $B$. Therefore $[B1 \; G1; \; B2 \; G2; \; G3]$ signifies that a 3D logically rectangular block of memory, which has a 3D associated grid, is distributed in its first two dimensions, and not its third.

The action of redistribution and remapping are signified by the symbols $-- \!\!\! >$ and $=X=>$ respectively, where $X$ is a key to the specific interpolation method.

\begin{center}
\begin{tabular}{| c | c |} \hline \hline
{X} & {\em Action} \\
\hline
  C & first order conservative interpolation \\
  S & second order conservative interpolation \\
  B & first order bilinear interpolation \\
  P & second order bilinear interpolation \\
  N & nearest neighbor distance weighted average interpolation \\
  X & unknown or user provided interpolation \\
\hline
\end{tabular}
\end{center}

Therefore, the problem descriptor string
\begin{center}
\begin{verbatim}
      [B1 G1; B2 G2 ] --> [B1 G1; B2 G2 ]
\end{verbatim}
\end{center}
indicates the redistribution of a distributed source field, associated with a grid, to the destination distribution. 

This document is organized as follows. The first section describes the grid classification syntax in detail. The second section describes the distribution classification. The third section describes how to construct general structures out of the memory chunks. 

\paragraph{Grid syntax}
The specification of additional grid information is supported by expanding the $G$ specifier. The default $G$ indicates a tensor grid, while the specifier $U$ indicates an unstructured grid. Information about the grid stagger is available by appending a coordinate subscript to the signifier, while an unknown or undefined staggering is indicated with an $X$.
The complete syntax for grid specification is $G i_g \; + H \{ \# : \# \}$ where
\begin{itemize}
	\item where $i_g$ is the grid axis,
	\item $H \{ \# : \# \}$ the optional signifier specifies the size of the  halo on both ends of the memory. This allows the specification of asymmetric haloes.
\end{itemize}

Notice that the halo specifiers are appended to the grid specifier through use of $+$ signs. The absence of any of these specifiers indicates no specified boundary information.
\begin{center}
\begin{tabular}{| c | c |} \hline \hline
{\em argument } & {\em definition} \\
\hline
 &   \\
 &  \\
 &  \\
\hline 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{| c | c |} \hline \hline
{\em Grid Stagger } & {\em coordinates} \\
\hline
A & (0,0) \\
 B & (1,1) \\
 C \& D & (0,1 and (1,0) \\
\hline 
\end{tabular}
\end{center}
The stagger location coordinate represents the location a field with respect to the cell center location. It is indicated by relative cartesian coordinates, where the cell center is placed at the origin of the cell. The coordinate attached to each dimension relative to the cell center. This approach generalizes well to higher dimensions. 

To illustrate this further consider the example of a 2D grid. The cell is represented by a unit square with the xy axis placed at its center with the positive x-axis oriented {\em East} and the positive y-axis oriented {\em North}. The actual values are suppressed, only the directions $+$, $-$, and $0$ are used. This geometry is for reference purposes only, and does not literally represent the shape of an actual cell. 

The A-grid location could be represented by attaching the coordinate pair $(0,0)$ dimension or alternatively left blank. The B-grid places the staggered location at the corner or the cell center. These are indicated by their relative position;
\begin{description}
	\item [Center] $(0,0)$
	\item [Corner] $(+,+)$
\end{description}  
The C and D-grid places the staggered location at one of two faces or the cell center. Again, these are indicated their relative location.
\begin{description}
	\item [Center] $(0,0)$
	\item [X normal face] $(+,0)$
	\item [Y normal face] $(0,+)$
\end{description}  

A C-grid configuration where {\em U} is located on the East face and {\em V} is located at the North face would look like $[ G1 @(+,0) ; G2 @ (0,+)]$. Similar descriptions can be constructed for the remaining Arakawa grid staggerings. 

The vertical stagger is indicated in a similar way;  
\begin{description}
	\item [top face] $(+)$
	\item [cell center] $(0)$
	\item [bottom face] $(-)$
\end{description}
where one of these signifiers is used as the third coordinate.

\paragraph{Distribution syntax}
The description of the distribution of a contiguous chunk of memory among the DEs is similar to the description for the grid association. Descriptors for two types of memory distribution are supported
\begin{description}
	\item[simple block] $B \; i_D \; \{ n_D \} $; where $i_D$ is the DELayout axis and $n_D$ is the number of DEs decomposed along the $i_D$ axis.
	\item[full block-cyclic] $C \; i_D \{ r,n_D \} $; where $i_D$ is the DELayout axis, $r$ is the repeat period, and $n_D$ is the number of DEs decomposed along the $i_D$ axis.
	\item[arbitrary] $A$ 
\end{description}
Assuming a two dimensional distribution, the expression $[ B1 \; G1; \; B2 \; G2 ]$ indicates that the previously described two dimensional logically rectangular block of memory is;
\begin{itemize}
	\item associated with a two dimensional grid, in its natural order,
	\item the first memory dimension is distributed according to the first distribution axis.
	\item the second memory dimension is distributed according to the second distribution axis.

\end{itemize}
The order of the distribution signifiers can be reversed just as with the grid association from the example above. 

Suppose a dimension is neither associated with a grid and/or distributed? The symbol $\ast$ is used as a placeholder. Therefore $[ B1 \; G1; \; B2 \; G2; \; \ast \ast ]$ indicates that only the first two dimensions have associated grids and are distributed. The two asterisks in the third dimension indicate that it is not distributed and has no associated grid. An example of this configuration could be a two dimensional spatial field with multiple species/tracers represented by the third dimension. Alternatively, if the third memory dimension has a spatial association, such as height, it would be represented as $[ B1 \; G1; \; B2 \; G2; \; \ast \; G3 ]$.

\subsection{General Data Structures}
More general data structures, which cannot be described by logically rectangular representations can be constructed by combining multiple contiguous data chunks separated by commas. Parentheses are used as delimiters to combine logically rectangular chunks of memory. Suppose you have an indexed structure with an embedded logically rectangular array. You might want to do this in order to hold a collection of arrays with different dimensions.  It would be represented $( patch , \; [ B1 \; G1; \; B2 \; G2 ] \; )$. This structure frequently arises in nested models or multigrid methods.

\subsection{Redistribution and Remapping}
Redistribution and remapping are just transformations from one space to another. In the case of redistribution, the spaces are DELayouts, while for remapping a field is interpolated from one grid to another. These transformations are signified by the symbols $-->$ and $=A=>$, respectively. Thus 
$[ B1 \; G1;\; B2 \; G2 ] -- \!\!\! >  [ B1 \; G1;\; B2 \; G2 ]$ indicates the redistribution of a 2D distributed gridded field from one DELayout to another, while $[ B1 \; G1;\; B2 \; G2 ] =C=>  [ B1 \; G1;\; B2 \; G2 ]$ indicates the interpolation of one distributed 2D gridded field to another 2D grid using a first order conservative method. A character is placed in between the equal signs to indicate the remapping method. $C$ is for first order conservative, and $S$ is for second order conservative. $B$ is for bilinear. $N$ is for nearest neighbor, and $X$ is for an unknown or user provided method. More methods will be added as needed.
 
For example, the string
\begin{displaymath}
[B1 \; G1+P; \; B2 \; G2 ] =C=> [B1 \; G1@(+,+)+P; \; B2 \; G2@(+,+) ] 
\end{displaymath}
indicates that a collection of regridding tests are to be run where a block distributed two dimensional field, is interpolated from one two dimensional grid onto a second two dimensional grid, using a first order conservative method. It is indicated that both grids are periodic in their first dimension. The source field data is located at the cell centers (an A-grid stagger location) and the destination field is to be located at north east corner (a B-grid stagger location). The additional information about a pair of grids and distributions must be specified to run an actual test. 


%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reporting test results}
The test harness offers the option of producing a human readable report on the test results. The report consists of a concise summary of the test configuration along with the test results. The test configuration is described in terms of the Field Taxonomy syntax and user provided 
strings. The intent is not to provide a exhaustive description of the test, but rather to provide a useful description of the failed tests.

Consider a problem descriptor string consisting of two descriptor strings describing an ensemble of remapping tests. 

\begin{verbatim}
[ B1 G1; B2 G2 ] =C=> [ B1 G1@(+,+); B2 G2@(+,+) ] 
[ B1 G1; B2 G2 ] =B=> [ B1 G1@(+,+); B2 G2@(+,+) ]
\end{verbatim}

Suppose the associated specifier files indicate that the source  grid is rectilinear and is 100 X 50 in size. The destination grid is also rectilinear and is 80 X 20 in size. The remapping is conducted from the A-grid position of the source grid to the B-grid stagger of the destination grid. Both grids are block distributed in two 
ways, 1 X NPETS and NPETS X 1. And suppose that the first dimension of both the source and destination grids are periodic. If the test succeeds for the conservative remapping, but fails for one of the first order bilinear remapping configurations, the reported results
could look something like

\begin{verbatim}
SUCCESS: [B1 G1; B2 G2 ] =C=> [B1 G1@(+,+); B2 G2@(+,+) ] 
FAILURE: [B1{1} G1{100}+P; B2{npets} G2{50} ] =B=> [B1{1} G1{80}@(+,+)+P; B2{npets} G2{20}@(+,+) ] 
     failure at line 101 of test.F90
SUCCESS: [ B1{npets} G1{100} +P; B2{1} G2{50} ] =B=> [ B1{npets} G1{80}@(+,+)+P; B2{1} G2{20}@(+,+) ] 
\end{verbatim}

The report indicates that all the test configurations for the conservative remapping are successful. This is indicated by the key word SUCCESS which is followed by the successful problem descriptor string. Since all of the tests in the first case pass,there is no need to include any of the specifier information. For the second ensemble of tests, one configuration passed, while the other failed. In this case,
since there is a mixture of successes and failures, the report includes 
specifier information for all configurations to help indicate the source of the test failure. 

Next consider a problem descriptor string consisting of three descriptor strings describing an ensemble of redistribution tests. 

\begin{verbatim}
[ B1 G1@(+,+); B2 G2@(+,+) ] --> [ B1 G1@(+,+); B2 G2@(+,+) ] 
[ C1 G1; C2 G2 ] --> [ B1 G1; B2 G2 ]
[ B1 G1; B2 G2 ] --> [ B2 G2; B1 G1 ]
\end{verbatim}


The supplemental information, while not a complete problem description since it lacks items such as the physical coordinates of the grid and the nature of the test field, includes information crucial to isolating the failed test.





