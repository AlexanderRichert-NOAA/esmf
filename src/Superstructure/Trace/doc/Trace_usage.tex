% $Id$
%
% Earth System Modeling Framework
% Copyright 2002-2018, University Corporation for Atmospheric Research, 
% Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
% Laboratory, University of Michigan, National Centers for Environmental 
% Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
% NASA Goddard Space Flight Center.
% Licensed under the University of Illinois-NCSA License.

%\subsection{Use and Examples}

\subsubsection{Output a Timing Profile to Text}
\label{sec:BasicProfiling}

ESMF profiling is disabled by default. To profile an application,
set the {\tt ESMF\_RUNTIME\_PROFILE} variable to {\tt ON} prior
to executing the application.  You do not need to recompile
your code to enable profiling.

\begin{verbatim}
# csh shell
$ setenv ESMF_RUNTIME_PROFILE ON

# bash shell
$ export ESMF_RUNTIME_PROFILE=ON

# (from now on, only the csh shell version will be shown)
\end{verbatim}

Then execute the application in the usual way. At the end of
the run the profile information will be available at the end
of each PET log (if ESMF Logs are turned on) or in a set of
separate files, one per PET, with names {\em ESMF\_Profile.XXX}
where XXX is the PET number.  Below is an example timing
profile.  Some regions are left out for brevity.

\begin{verbatim}
Region                                             Count  Total (s)   Self (s)    Mean (s)    Min (s)     Max (s)
  [esm] RunPhase1                                  1      1.3629      0.6119      1.3629      1.3629      1.3629 
    [OCN-TO-ATM] RunPhase1                         864    0.2441      0.2441      0.0003      0.0002      0.0252 
    [ATM-TO-OCN] RunPhase1                         864    0.1775      0.1775      0.0002      0.0001      0.0129 
    [OCN] RunPhase1                                864    0.1744      0.1744      0.0002      0.0002      0.0004 
    [ATM] RunPhase1                                864    0.1550      0.1550      0.0002      0.0001      0.0004 
  [esm] Init 1                                     1      0.9236      0.0139      0.9236      0.9236      0.9236 
    [OCN-TO-ATM] IPDv05p6b                         1      0.5447      0.5447      0.5447      0.5447      0.5447 
    [ATM-TO-OCN] IPDv05p6b                         1      0.3594      0.3594      0.3594      0.3594      0.3594 
    [ATM] IPDv00p2                                 1      0.0014      0.0014      0.0014      0.0014      0.0014 
    [OCN] IPDv00p2                                 1      0.0007      0.0007      0.0007      0.0007      0.0007 
    [ATM] IPDv00p1                                 1      0.0003      0.0003      0.0003      0.0003      0.0003 
  [esm] FinalizePhase1                             1      0.0010      0.0009      0.0010      0.0010      0.0010 
    [ATM-TO-OCN] FinalizePhase1                    1      0.0001      0.0001      0.0001      0.0001      0.0001 
    [OCN-TO-ATM] FinalizePhase1                    1      0.0000      0.0000      0.0000      0.0000      0.0000 
    [ATM] FinalizePhase1                           1      0.0000      0.0000      0.0000      0.0000      0.0000 
    [OCN] FinalizePhase1                           1      0.0000      0.0000      0.0000      0.0000      0.0000 
\end{verbatim}

A timed region is either an ESMF component phase (e.g., initialize,
run, or finalize) or a user-defined region of code surrounded by calls to
{\tt ESMF\_TraceRegionEnter()} and {\tt ESMF\_TraceRegionExit()}. (See
section \ref{ex:TraceUserEx} for more information on instrumenting
user-defined regions.)
Regions are organized hierarchically with sub-regions nested.
For example, in the profile above,
the {\tt [OCN] RunPhase1} is a sub-region of {\tt [esm] RunPhase1} and is
entirely contained inside that region. Regions with the same name may appear
at multiple places in the hierarchy, and so would appear in multiple rows
in the table.  The statistics in that row apply to that region at that
location in the hierarchy. Component names appear in square brackets,
e.g., {\tt [ATM]},  {\tt [OCN]}, and {\tt [ATM-TO-OCN]}.
By default, timings are based on elapsed wall clock time and are collected
on a per-PET basis. Therefore, regions timings may differ across PETs. Regions
are sorted with the most expensive regions appearing at the top. The following
describes the meaning of the statistics in each column:

\begin{itemize}
\item [{\tt Count}] the number of times the region is executed
\item [{\tt Total}] the aggregate time spent in the region, inclusive of all sub-regions
\item [{\tt Self}]  the aggregate time spend in the region, exclusive of all sub-regions
\item [{\tt Mean}]  the average amount of time for one execution of the region
\item [{\tt Min}]   time of the fastest execution of the region
\item [{\tt Max}]   time of the slowest execution of the region
\end{itemize}


\subsubsection{Summarize Timings across Multiple PETs}
\label{sec:SummaryProfiling}

By default, separate timing profiles are generated for each PET
in the application.  The per-PET profiles can be aggregated together
and output to a single file, {\em ESMF\_Profile.txt}, by setting the
{\tt ESMF\_RUNTIME\_PROFILE\_OUTPUT} environment variable as follows:

\begin{verbatim}
$ setenv ESMF_RUNTIME_PROFILE ON              # turn on profiling
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT SUMMARY  # specify summary output
\end{verbatim}

Note the {\tt ESMF\_RUNTIME\_PROFILE} environment variable must
also be set to {\tt ON} since this controls all profiling capabilities.
The {\em ESMF\_Profile.txt} file will contain a similar tree of
timed regions, but aggregated across all PETs.  For example, the
{\tt Total} column will contain the sum of all {\tt Total}s across
all PETs that were profiled.  In other words, this is the sum of the
total wall clock times across all PETs for each region. The {\tt Min}
will contain the global minimum execution time of the region
across all PETs and the {\tt Mean} will be the mean of all PET means.

To output both the per-PET and summary timing profiles,
set the {\tt ESMF\_RUNTIME\_PROFILE\_OUTPUT} environment variable as follows:

\begin{verbatim}
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT "TEXT SUMMARY"
\end{verbatim}


\subsubsection{Limit the Set of Profiled PETs}
\label{sec:LimitProfiling}

By default, all PETs in an application are profiled. It may be desirable
to only profile a subset of PETs to reduce the amount of output.
An explicit list of PETs can be specified by setting the
{\tt ESMF\_RUNTIME\_PROFILE\_PETLIST} environment variable.
The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the ``X-Y'' syntax where X < Y.
For example:

\begin{verbatim}
# only profile PETs 0, 20, and 35 through 39
$ setenv ESMF_RUNTIME_PROFILE_PETLIST "0 20 35-39"
\end{verbatim}

When used in conjunction with the {\tt SUMMARY} option above, the summarized
profile will only aggregate over the specified set of PETs. The one exception is that
PET 0 is always profiled if {\tt ESMF\_RUNTIME\_PROFILE=ON}, regardless of the
{\tt ESMF\_RUNTIME\_TRACE\_PETLIST} setting.


\subsubsection{Output a Detailed Trace for Analysis}


ESMF tracing is disabled by default. To enable tracing, set the
{\tt ESMF\_RUNTIME\_TRACE} environment variable to {\tt ON}. You
do not need to recompile your code to enable tracing.

\begin{verbatim}
# csh shell
$ setenv ESMF_RUNTIME_TRACE ON

# bash shell
$ export ESMF_RUNTIME_TRACE=ON
\end{verbatim}

When enabled, the default behavior is to trace all PETs of the
ESMF application. Although the ESMF tracer is designed to write 
events in a compact form, tracing can produce an extremely
large number of events depending on the total number of PETs and
the length of the run. To reduce output, it is possible to restrict
the PETs that produce trace output by setting the {\tt ESMF\_RUNTIME\_TRACE\_PETLIST}
environment variable. For example, this setting:

\begin{verbatim}
$ setenv ESMF_RUNTIME_TRACE_PETLIST "0 101 192-196"
\end{verbatim}

will instruct the tracer to only trace PETs 0, 101, and 192 through 196
(inclusive). The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the ``X-Y'' syntax where X < Y. For PET counts greater than 100, it is
recommended to set this environment variable. The one exception is that
PET 0 is always traced, regardless of the {\tt ESMF\_RUNTIME\_TRACE\_PETLIST}
setting.

ESMF's profiling and tracing options can be used together.  A typical
use would be to set {\tt ESMF\_RUNTIME\_PROFILE=ON} for all PETs to
capture summary timings, and set {\tt ESMF\_RUNTIME\_TRACE=ON} and
{\tt ESMF\_RUNTIME\_TRACE\_PETLIST} to a subset of of PETs,
such as the root PET of each ESMF component. This helps to keep trace
sizes small while still providing timing summaries over all PETs.

When tracing is enabled, {\tt phase\_enter} and {\tt phase\_exit} events will
automatically be recorded for all initialize, run, and finalize phases of all
Components in the application. To trace {\em only} user-instrumented regions (via
the {\tt ESMF\_TraceRegionEnter()} and {\tt ESMF\_TraceRegionExit()} calls),
Component-level tracing can be turned off by setting:

\begin{verbatim}
$ setenv ESMF_RUNTIME_TRACE_COMPONENT OFF
\end{verbatim}

After running an ESMF application with tracing enabled, a directory
called {\em traceout} will be created in the run directory and it will
contain a {\em metadata} file and an event stream file {\em esmf\_stream\_XXXX}
for each PET with tracing enabled. Together these files form a valid
CTF trace which may be analyzed with any of the tools listed above.

Trace events are flushed to file at a regular interval. If the application
crashes, some of the most recent events may not be flushed to file. To
maximize the number of events appearing in the trace, an option is available
to flush events to file more frequently. Because this option may have
negative performance implications due to increased file I/O, it is not
recommended unless needed. To turn on eager flushing use:

\begin{verbatim}
$ setenv ESMF_RUNTIME_TRACE_FLUSH EAGER
\end{verbatim}

\subsubsection{Set the Clock used for Profiling/Tracing}
\label{sec:TracingClocks}

There are three options for the kind of clock to use to timestamp
events when profiling/tracing an application.
These options are controlled by setting the environment variable
{\tt ESMF\_RUNTIME\_TRACE\_CLOCK}.
\begin{itemize}
\item [{\tt REALTIME}] The {\tt REALTIME} clock timestamps events with the current time on
      the system.  This is the default clock if the above environment
      variable is not set.  This setting can be useful when tracing PETs that
      span multiple physical computing nodes assuming that the system clocks
      on each node are adequately synchronized.  On most HPC systems, system
      clocks are periodically updated to stay in sync.  A disadvantage of this
      clock is that periodic adjustments mean the clock is not monotonically
      increasing so some timings may be inaccurate if the system clock jumps
      forward or backward significantly. Testing has shown that this is not
      typically an issue on most systems.
\item [{\tt MONOTONIC}] The {\tt MONOTONIC} clock is guaranteed to be monotonically increasing
      and does not suffer from periodic adjustments.  The timestamps represent
      an amount of time since some arbitrary point in the past.  There is no
      guarantee that these timestamps will be synchronized across physical
      computing nodes, so this option should only be used for tracing a set of PETs
      running on a single physical machine.
\item [{\tt MONOTONIC\_SYNC}] The {\tt MONOTONIC\_SYNC} clock is similar to the {\tt MONOTONIC} clock
      in that it is guaranteed to be monotonically increasing. In addition, at
      application startup, all PET clocks are synchronized to a common time
      by determining a PET-local offset to be applied to timestamps. Therefore this option
      can be used to compare trace streams across physical nodes.     
\end{itemize}
