%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\parskip        0pt
\parindent      0pt
\baselineskip  11pt
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_State.F90,  Date: Tue Jan 28 16:56:54 MST 2003
}

 
%/////////////////////////////////////////////////////////////
\subsection{Fortran:  Module Interface ESMF\_StateMod - Manage data states uniformly between F90 and C++  (Source File: ESMF\_State.F90)}


  
  
   The code in this file implements the Fortran interfaces to the
   {\tt State} class and associated functions and subroutines.  
  
  
  ------------------------------------------------------------------------------
\bigskip{\em USES:}
\begin{verbatim}       use ESMF_BaseMod
       use ESMF_IOMod
       !use ESMF_ComponentMod
       implicit none
 
  ------------------------------------------------------------------------------\end{verbatim}{\sf PRIVATE TYPES:}
\begin{verbatim}       private
 
  ------------------------------------------------------------------------------
       ! ESMF_StateImpExpType
       !   Enumerated value for storing Import or Export State type.
       type ESMF_StateImpExpType
       sequence
       private
          integer :: state
       end type
 
       type(ESMF_StateImpExpType), parameter :: &
                 ESMF_STATEIMPORT = ESMF_StateImpExpType(1), &
                 ESMF_STATEEXPORT = ESMF_StateImpExpType(2), &
                 ESMF_STATEUNKNOWN = ESMF_StateImpExpType(3)
 
  ------------------------------------------------------------------------------
       ! ESMF_StateObjectType
       !   Each entry in the list of states is either simply a name placeholder
       !   or an actual data item - Bundle, Field, or Array.  The state list
       !   can either be a linked list or an array of derived types.
       !   For a linked list, the Last is the end of the list.
       type ESMF_StateObjectType
       sequence
       private
          integer :: ot
       end type
 
       type(ESMF_StateObjectType), parameter :: &
                 ESMF_BUNDLE = ESMF_StateObjectType(1), &
                 ESMF_FIELD = ESMF_StateObjectType(2), &
                 ESMF_ARRAY = ESMF_StateObjectType(3), &
                 ESMF_DATANAME = ESMF_StateObjectType(4), &
                 ESMF_LAST = ESMF_StateObjectType(5), &
                 ESMF_OBJTYPEUNKNOWN = ESMF_StateObjectType(6)
 
  ------------------------------------------------------------------------------
       ! ESMF_StateDataNeeded
       !   For an Export State if all data which can potentially be created is
       !   not needed, this flag can be used to mark data which does not need
       !   to be created by the Component.
       type ESMF_StateDataNeeded
       sequence
       private
          integer :: needed
       end type
 
       type(ESMF_StateDataNeeded), parameter :: &
                 ESMF_NEEDED = ESMF_StateDataNeeded(1), &
                 ESMF_NOTNEEDED= ESMF_StateDataNeeded(2), &
                 ESMF_DONOTCARE = ESMF_StateDataNeeded(3), &
                 ESMF_NEEDUNKNOWN = ESMF_StateDataNeeded(4)
 
  ------------------------------------------------------------------------------
       ! ESMF_StateDataReady
       type ESMF_StateDataReady
       sequence
       private
          integer :: ready
       end type
 
       type(ESMF_StateDataReady), parameter :: &
                 ESMF_READYTOWRITE = ESMF_StateDataReady(1), &
                 ESMF_READYTOREAD= ESMF_StateDataReady(2), &
                 ESMF_DONOTCARE = ESMF_StateDataReady(3), &
                 ESMF_READYUNKNOWN = ESMF_StateDataReady(4)
 
 
  ------------------------------------------------------------------------------
       ! ESMF_DataHolder
       ! Make a single data type for Bundles, Fields, and Arrays.
       !  The ObjectType is one level up, because this structure is not
       !  allocated until it is actually needed.  This is a private type.
 
       type ESMF_DataHolder
       sequence
       private
           type(ESMC_Bundle), pointer :: bp
           type(ESMC_Field), pointer :: fp 
           type(ESMC_Array), pointer :: ap
       end type
 
  ------------------------------------------------------------------------------
       ! ESMF_StateData
       ! Description of next Data item in list, or simply a name
       !  which holds the place for an optional Data item.
 
       type ESMF_StateData
       sequence
       private
         type(ESMF_StateObjectType) :: otype
         character, pointer :: namep
         type(ESMF_DataHolder), pointer :: datap
         type(ESMF_StateDataNeeded) :: needed
         type(ESMF_StateDataReady) :: ready
         type(ESMF_StateData), pointer :: nextdata
       end type
 
  ------------------------------------------------------------------------------
       ! ESMF_StateType
       ! Internal State data type.
 
       type ESMF_StateType
       sequence
       private
         type(ESMF_StateImpExpType) :: st
         character (len=ESMF_MAXSTR) :: compname
         integer :: listlength
         ! this will be either an allocatable array (simpler to random access
         ! but harder to resize), or a linked list (slightly more overhead to
         ! iterate (less memory contiguity) but easy to add and delete items from.
         type(ESMF_StateData), pointer :: listhead
         ! or
         type(ESMF_StateData), dimension(:), pointer :: states
       end type
 
  ------------------------------------------------------------------------------
       ! ESMF_State
       ! State data type.
 
       type ESMF_State
       sequence
       private
         type(ESMF_StateType), pointer :: statep
       end type
 
  ------------------------------------------------------------------------------\end{verbatim}{\sf PUBLIC TYPES:}
\begin{verbatim}       public ESMF_State
  ------------------------------------------------------------------------------
 \end{verbatim}{\sf PUBLIC MEMBER FUNCTIONS:}
\begin{verbatim} 
       public ESMF_StateCreate           ! for import/for export
       public ESMF_StateDestroy
 
       public ESMF_StateSetData          ! interface does Bundles/Fields/Arrays
       public ESMF_StateGetData          ! interface does Bundles/Fields/Arrays
       public ESMF_StateGetInfo          ! comp name, type, data count
       public ESMF_StateAddNameOnly      ! placeholder name but no data
       !public ESMF_State{Get/Set}Needed ! set if data required
       !public ESMF_State{Get/Set}Ready  ! is data ready
       !public ESMF_State{Get/Set}CompName  ! set only if not given at create time
  
       public ESMF_StateCheckpoint
       public ESMF_StateRestore
  
       public ESMF_StatePrint\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateCreate -- Generic interface to create an State}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_StateCreate
 \end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}         module procedure ESMF_StateCreateNew
         module procedure ESMF_StateCreateEmpty
 \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   This interface provides a single entry point for the various 
    types of {\tt ESMF\_StateCreate} functions.   
     
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddData -- Add Bundles, Fields, and Arrays to a State}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_StateAddData
 \end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}         module procedure ESMF_StateAddBundle
         module procedure ESMF_StateAddBundleList
         module procedure ESMF_StateAddField
         module procedure ESMF_StateAddFieldList
         module procedure ESMF_StateAddArray
         module procedure ESMF_StateAddArrayList
 \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   This interface provides a single entry point for the various 
    types of {\tt ESMF\_StateAddData} functions.   
     
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateGetData -- Retrieve Bundles, Fields, or Arrays from a State}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_StateGetData
 \end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}         module procedure ESMF_StateGetBundle
         module procedure ESMF_StateGetField
         module procedure ESMF_StateGetArray
 \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   This interface provides a single entry point for the various 
    types of {\tt ESMF\_StateGetData} functions.   
     
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddNameOnly -- Add names as placeholders to the State}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_StateAddNameOnly
 \end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}         module procedure ESMF_StateAddDataName
         module procedure ESMF_StateAddDataNameList
 \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   This interface provides a single entry point for the various 
    types of {\tt ESMF\_StateAddNameOnly} functions.   
     
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateCreateNew -- Create a new State specifying all options.}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_StateCreateNew(rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_State) :: ESMF_StateCreateNew\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       integer, intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


    Create a new State and set the decomposition characteristics.
  
    The return value is a new State.
      
    The arguments are:
    \begin{description}
  
     \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateCreateEmpty -- Create a new State specifying no data}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_StateCreateEmpty(compname, statetype, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_State) :: ESMF_StateCreateEmpty\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       character(len=ESMF_MAXSTR), intent(in), optional :: compname 
       type(ESMF_StateImpExpType), intent(in), optional :: statetype
       integer, intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


    Create a new empty {\tt State}.  The return value is a new {\tt State}.
      
    The arguments are:
    \begin{description}
  
     \item[[compname]]
      Name of the {\tt Component} this {\tt State} is associated with.
  
     \item[[statetype]]
      Import or Export {\tt State}.  Returns either {\tt ESMF\_STATEIMPORT},
      {\tt ESMF\_STATEEXPORT}, or {\tt ESMF\_STATEUNKNOWN}.
  
     \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateDestroy(state, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State) :: state
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


       Releases all resources associated with this {\tt State}.
  
       The arguments are:
       \begin{description}
  
       \item[state]
         Destroy contents of this {\tt State}.
  
       \item[[rc]]
         Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddBundle - Add a Bundle to a State.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateAddBundle(state, bundle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state
       type(ESMF_Bundle), intent(in) :: bundle
       integer, intent(out), optional :: rc
       \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add a single {\tt Bundle} reference to an existing {\tt State}.
        The {\tt Bundle} name must be unique within the {\tt State}
  
\bigskip{\sf REQUIREMENTS:}
\begin{verbatim} \end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddBundleList - Add a list of Bundles to a State}

 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateAddBundleList(state, bcount, bundles, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state 
       integer, intent(in) :: bcount
       type(ESMF_Bundle), dimension(:), intent(in) :: bundles
       integer, intent(out), optional :: rc     \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add multiple bundles to a {\tt State}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateTypeAddBundleList - Add a list of Bundles to a StateType}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateTypeAddBundleList(statep, bcount, bundles, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_StateType), intent(inout) :: statep
       integer, intent(in) :: bcount
       type(ESMF_Bundle), dimension(:), intent(in) :: bundles
       integer, intent(out), optional :: rc     \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add multiple bundles to a {\tt State}.  Internal routine only.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddDataName - Add a Name as placeholder to a State.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateAddDataName(state, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state
       character (len=*), intent(in) :: name
       integer, intent(out), optional :: rc
       \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add a {\tt name} to an existing {\tt State}.
        The {\tt name} must be unique within the {\tt State}
        It is available to be marked {\tt needed} by the
        consumer of the export {\tt State}. Then the data 
        provider can replace the name with the actual {\tt Bundle},
        {\tt Field}, or {\tt Array} which carries the needed data.
  
\bigskip{\sf REQUIREMENTS:}
\begin{verbatim} \end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateAddDataNameList - Add a list of Names as placeholder to a State.}

 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateAddDataNameList(state, namecount, namelist, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state
       integer, intent(in) :: namecount
       character (len=*), intent(in) :: namelist(:)
       integer, intent(out), optional :: rc
       \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add a {\tt name} to an existing {\tt State}.
        The {\tt name} must be unique within the {\tt State}
        It is available to be marked {\tt needed} by the
        consumer of the export {\tt State}. Then the data 
        provider can replace the name with the actual {\tt Bundle},
        {\tt Field}, or {\tt Array} which carries the needed data.
        Unneeded data need not be generated.
  
\bigskip{\sf REQUIREMENTS:}
\begin{verbatim} \end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection{ESMF\_StateTypeAddDataNameList - internal routine}

 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateTypeAddDataNameList(statep, namecount, namelist, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_StateType), intent(inout) :: statep
       integer, intent(in) :: namecount
       character (len=*), intent(in) :: namelist(:)
       integer, intent(out), optional :: rc
       \end{verbatim}
{\sf DESCRIPTION:\\ }


        Add a list of {\tt name}s to an existing {\tt State}.
        The {\tt name}s must be unique within the {\tt State}
        They are available to be marked {\tt needed} by the
        consumer of the export {\tt State}. Then the data 
        provider can replace the name with the actual {\tt Bundle},
        {\tt Field}, or {\tt Array} which carries the needed data.
        Unneeded data need not be generated.
  
\bigskip{\sf REQUIREMENTS:}
\begin{verbatim} \end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateGetInfo(state, compname, statetype, statecount, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character (len=*), intent(out), optional :: compname
       type(ESMF_StateImpExpType), intent(out), optional :: statetype
       integer, intent(out), optional :: rc             
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns the name of the {\tt Component) this state is associated with.
        Also returns the type of {\tt State}, either {\tt Import} or 
        {\tt Export}.
  
    \begin{description}     
    \item[state]
      {\tt State} to query.
     \item[[compname]]
      Name of the {\tt Component} this {\tt State} is associated with.
     \item[[statetype]]
      Import or Export {\tt State}.  Returns either {\tt ESMF\_STATEIMPORT},
      {\tt ESMF\_STATEEXPORT}, or {\tt ESMF\_STATEUNKNOWN}.
     \item[[statecount]]
      Count of data items in this {\tt state}, including placeholder names.
     \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
    \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateGetBundle(state, name, bundle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: name
       type(ESMF_Bundle), intent(out) :: bundle
       integer, intent(out), optional :: rc             
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns a {\tt Bundle} from a {\tt State} by name.
  
    \begin{description}     
    \item[state]
      State to query for a {\tt Bundle} named {\tt name}.
    \item[name]
      {\tt Bundle} name to be returned.
    \item[bundle]
      Where the {\tt bundle} is returned.
    \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
    \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateGetField(state, name, field, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: name
       type(ESMF_Field), intent(out) :: field
       integer, intent(out), optional :: rc             
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns a {\tt Field} from a {\tt State} by name.
  
    \begin{description}     
    \item[state]
      State to query for a {\tt Field} named {\tt name}.
    \item[name]
      {\tt Field} name to be returned.
    \item[field]
      Where the {\tt field} is returned.
    \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
    \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateGetArray(state, name, array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: name
       type(ESMF_Array), intent(out) :: array
       integer, intent(out), optional :: rc             
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns a {\tt Array} from a {\tt State} by name.
  
    \begin{description}     
    \item[state]
      State to query for a {\tt Array} named {\tt name}.
    \item[name]
      {\tt Array} name to be returned.
    \item[array]
      Where the {\tt array} is returned.
    \item[[rc]]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
    \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateCheckpoint(state, iospec, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State):: state 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc            \end{verbatim}
{\sf DESCRIPTION:\\ }


        Used to save all data to disk as quickly as possible.  
        (see Read/Write for other options).  Internally this routine uses the
        same I/O interface as Read/Write, but the default options are to
        select the fastest way to save data to disk.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_StateRestore(name, iospec, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_State) :: ESMF_StateRestore\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       character (len = *), intent(in) :: name              ! state name to restore
       type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
       integer, intent(out), optional :: rc                 ! return code\end{verbatim}
{\sf DESCRIPTION:\\ }


        Used to reinitialize
        all data associated with a State from the last call to Checkpoint.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StatePrint(state, options, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State) :: state
       character (len = *), intent(in), optional :: options
       integer, intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


        Routine to print information about an state.
  
%...............................................................
