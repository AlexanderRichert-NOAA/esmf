! $Id: ESMF_Attribute.cppF90,v 1.23 2009/03/28 01:35:12 rokuingh Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2009, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
^include "ESMF.h"
#include "ESMF_TypeKindMacros.hcppF90"
^define ESMF_NO_INTEGER_1_BYTE
^define ESMF_NO_INTEGER_2_BYTE

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
!  and functions.  This is an
!  interface to the actual C++ Attribute class implementation 
!  in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_ArrayMod
  Use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_VMMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------

  type ESMF_Attribute
  sequence
    character(len=ESMF_MAXSTR)  :: attr_name
    type(ESMF_DataValue)        :: attr_value
  end type

!------------------------------------------------------------------------------
!
! !DESCRIPTION:
!     The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_ArrayBundle},
!     {\ESMF_DistGrid}, {\tt ESMF\_Field},{\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid}, 
!     and {\tt ESMF\_State}.  
!
! !PUBLIC MEMBER FUNCTIONS:
!
!   Classes
      public ESMF_Attribute
      
!  Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeRead
      public ESMF_AttributeWrite

!EOPI 
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id: ESMF_Attribute.cppF90,v 1.23 2009/03/28 01:35:12 rokuingh Exp $'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd  - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCstm
        module procedure ESMF_ArrayBundleAttAddPackCstm
        module procedure ESMF_CplCompAttAddPack
        module procedure ESMF_CplCompAttAddPackCstm
        module procedure ESMF_GridCompAttAddPack
        module procedure ESMF_GridCompAttAddPackCstm
        module procedure ESMF_DistGridAttAddPackCstm
        module procedure ESMF_FieldAttAddPack
        module procedure ESMF_FieldAttAddPackCstm
        module procedure ESMF_FieldBundleAttAddPackCstm
        module procedure ESMF_GridAttAddPack
        module procedure ESMF_GridAttAddPackCstm
        module procedure ESMF_StateAttAddPack
        module procedure ESMF_StateAttAddPackCstm
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that create
!     an Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy  - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_StateAttCopy
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that copy
!     an Attribute or Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove

! !DESCRIPTION:
!     This interface provides a single entry point for methods that destroy
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet  - Get Attributes, Attribute packages, count, 
!              info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet
   
! !PRIVATE MEMBER FUNCTIONS:
        TypeKindInterfaceMacro(ESMF_ArrayAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayAttGet1D)
        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount

        TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttGet1D)
        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_CplCompAttGet)
	TypeKindInterfaceMacro(ESMF_CplCompAttGet1D)
        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount

        TypeKindInterfaceMacro(ESMF_GridCompAttGet)
	TypeKindInterfaceMacro(ESMF_GridCompAttGet1D)
        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount

        TypeKindInterfaceMacro(ESMF_DistGridAttGet)
	TypeKindInterfaceMacro(ESMF_DistGridAttGet1D)
        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldAttGet)
	TypeKindInterfaceMacro(ESMF_FieldAttGet1D)
        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldBundleAttGet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttGet1D)
        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_GridAttGet)
	TypeKindInterfaceMacro(ESMF_GridAttGet1D)
        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount

        TypeKindInterfaceMacro(ESMF_StateAttGet)
	TypeKindInterfaceMacro(ESMF_StateAttGet1D)
        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     Attributes.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink  - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that link
!     Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove  - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_CplCompAttLinkRemoveCplComp
        module procedure ESMF_CplCompAttLinkRemoveGridComp
        module procedure ESMF_CplCompAttLinkRemoveState
        module procedure ESMF_GridCompAttLinkRemoveCplComp
        module procedure ESMF_GridCompAttLinkRemoveGridComp
        module procedure ESMF_GridCompAttLinkRemoveState
        module procedure ESMF_FieldBundleAttLinkRemoveField
        module procedure ESMF_StateAttLinkRemoveFieldBundle
        module procedure ESMF_StateAttLinkRemoveField
        module procedure ESMF_StateAttLinkRemoveState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that unlink
!     Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead  - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead
   
! !PRIVATE MEMBER FUNCTIONS:
! TODO
!        module procedure ESMF_ArrayAttRead
!        module procedure ESMF_ArrayBundleAttRead
!        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
!        module procedure ESMF_DistGridAttRead
!        module procedure ESMF_FieldAttRead
!        module procedure ESMF_FieldBundleAttRead
!        module procedure ESMF_GridAttRead
!        module procedure ESMF_StateAttRead

! !DESCRIPTION:
!     This interface provides a single entry point for methods that read
!     an Attribute or Attribute package.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet  - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet 
   
! !PRIVATE MEMBER FUNCTIONS:
	TypeKindInterfaceMacro(ESMF_ArrayAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayAttSet1D)
        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList

	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayBundleAttSet1D)
        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_CplCompAttSet)
	TypeKindInterfaceMacro(ESMF_CplCompAttSet1D)
        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridCompAttSet)
	TypeKindInterfaceMacro(ESMF_GridCompAttSet1D)
        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList

	TypeKindInterfaceMacro(ESMF_DistGridAttSet)
	TypeKindInterfaceMacro(ESMF_DistGridAttSet1D)
        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldAttSet)
	TypeKindInterfaceMacro(ESMF_FieldAttSet1D)
        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet1D)
        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList

	TypeKindInterfaceMacro(ESMF_GridAttSet)
	TypeKindInterfaceMacro(ESMF_GridAttSet1D)
        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList

	TypeKindInterfaceMacro(ESMF_StateAttSet)
	TypeKindInterfaceMacro(ESMF_StateAttSet1D)
        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     Attributes and Attribute packages, and link Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite
   
! !PRIVATE MEMBER FUNCTIONS:
        !module procedure ESMF_ArrayAttWrite
        !module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        !module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        !module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite

! !DESCRIPTION:
!     This interface provides a single entry point for methods that write
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate

! !DESCRIPTION:
!     This interface provides a single entry point for methods that update
!     an Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a standard Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPack(<object>, convention, purpose, attpacknestflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: convention
!     character (len = *), intent(in) :: purpose
!     type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Adds an Attribute package to <object> with Attribute names according
!     to the ESG convention.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [attpacknestflag]
!           The flag to tell whether this Attribute package is to be nested or not, possible values 
!           are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPackCstm(<object>, attrList, convention, purpose, &
!     count, attpacknestflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len=*), dimension(:), intent(in) :: attrList
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(in), optional :: count   
!     type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Adds a customized Attribute package to <object>.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [attrList]
!           The list of Attribute names to specify the custom Attribute package.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [count]
!           The number of Attributes to add to the custom Attribute package.
!     \item [attpacknestflag]
!           The flag to tell whether this Attribute package is to be nested or not, possible values
!           are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeCopy() 
!     subroutine ESMF_AttributeCopy(<object1>, <object2>, attcopyflag, atttreeflag, rc)
!
! !ARGUMENTS:
!     <object1>, see below for supported values  
!     <object2>, see below for supported values 
!     type(ESMF_AttCopyFlag), intent(in) :: attcopyflag
!     type(ESMF_AttTreeFlag), intent(in) :: atttreeflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Copies an Attribute hierarchy from <object1> to <object2>.
!     Supported values for <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     NOTE: Copies between like ESMF objects are recommended
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!           An {\tt ESMF} object.
!     \item [<object2>]
!           An {\tt ESMF} object.
!     \item [attcopyflag]
!           A flag to determine if the copy is to be by reference, value,
!           or both
!     \item [atttreeflag]
!           A flag to determine if the copy is supposed to descend the 
!           Attribute hierarchy
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!     NOTE:  The options for {\tt attcopyflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTCOPY\_HYBRID will copy the top base level
!		     Attributes by value, and all others by reference
!              \item ESMF\_ATTCOPY\_REFERENCE will copy all Attributes by reference
!              \item ESMF\_ATTCOPY\_VALUE will copy all Attributes by value
!            \end{enumerate}
!            The options for {\tt atttreeflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTTREE\_OFF will only descend the first base level 
!                    of the Attribute hierarchy
!              \item ESMF\_ATTTREE\_ON will descend the entire Attribute hierarchy
!            \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <value argument>, &
!                            <defaultvalue argument>, convention, purpose, &
!                            itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     <defaultvalue argument>, see below for supported values   
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns an Attribute value from the <object>, or from the Attribute package
!     specified by {\tt convention} and {\tt purpose}.  A default value 
!     argument may be given if a return code is not desired when the 
!     Attribute is not found.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: value
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: valueList
!     \item integer(ESMF\_KIND\_I8), intent(out) :: value
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R4), intent(out) :: value
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R8), intent(out) :: value
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: valueList
!     \item logical, intent(out) :: value
!     \item logical, dimension(:), intent(out) :: valueList
!     \item character (len = *), intent(out), value
!     \item character (len = *), dimension(count), intent(out), valueList
!     \end{description}
!     Supported values for <defaultvalue argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: defaultvalue
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: defaultvalueList
!     \item integer(ESMF\_KIND\_I8), intent(out) :: defaultvalue
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: defaultvalueList
!     \item real (ESMF\_KIND\_R4), intent(out) :: defaultvalue
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: defaultvalueList
!     \item real (ESMF\_KIND\_R8), intent(out) :: defaultvalue
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: defaultvalueList
!     \item logical, intent(out) :: defaultvalue
!     \item logical, dimension(:), intent(out) :: defaultvalueList
!     \item character (len = *), intent(out), defaultvalue
!     \item character (len = *), dimension(:), intent(out), defaultvalueList
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [<value argument>]
!           The value of the named Attribute.
!     \item [<defaultvalue argument>]
!           The default value of the named Attribute.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [itemCount]
!           The number of items in a multi-valued Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetCount(<object>, count, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(out) :: count
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns the Attribute count for <object>
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [count] 
!           The Attribute count for <object>.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNam(<object>, name, typekind, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns information associated with the named Attribute, 
!     including {\tt typekind} and {\tt itemCount}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to query.
!     \item [typekind]
!           The typekind of the Attribute.
!     \item [itemCount]
!           The number of items in this Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
!       typekind, itemcount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(in) :: attributeIndex
!     character (len = *), intent(out) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns information associated with the indexed Attribute, 
!     including {\tt name}, {\tt typekind} and {\tt itemCount}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [attributeIndex]
!           The index number of the Attribute to query.
!     \item [name]
!           Returns the name of the Attribute.
!     \item [typekind]
!           The typekind of the Attribute.
!     \item [itemCount]
!           Returns the number of items in this Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead  - Read an Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeRead(<object>, fileName, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len=*),   intent(in), optional :: fileName
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Read the Attribute package for <object>.  The Attribute package defines 
!     the convention, purpose, and object type of the associated Attributes.  
!     The fileName format is XML. 
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item[{[fileName]}]
!          The file name to be read from.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in), optional :: name
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Removes an Attribute on <object>.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to remove.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!     NOTE:  An entire Attribute package can be removed by specifying 
!            {\tt convention} and {\tt purpose} only, without {\tt name}.  By specifying
!            {\tt convention}, {\tt purpose}, and {\tt name} an Attribute will be removed 
!            from the corresponding Attribute package, if it exists.  An 
!            Attribute can be removed directly from <object> by specifying
!            {\tt name}, without {\tt convention} and {\tt purpose}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <value argument>, &
!                                 convention, purpose, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(in), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Attaches an Attribute to <object>, or sets an Attribute on an 
!     Attribute package.
!     The Attribute has a {\tt name} and either a {\tt value} or a 
!     {\tt valueList}, with an {\tt itemCount}, and a {\tt convention} and {\tt purpose}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_DistGrid), intent(inout) :: grid
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for the <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in) :: value
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(in) :: valueList
!     \item integer(ESMF\_KIND\_I8), intent(in) :: value
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R4), intent(in) :: value
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R8), intent(in) :: value
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(in) :: valueList
!     \item logical, intent(in) :: value
!     \item logical, dimension(:), intent(in) :: valueList
!     \item character (len = *), intent(in), :: value
!     \item character (len = *), dimension(:), intent(in), :: valueList
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to set.
!     \item [<value argument>]
!           The value of the Attribute to set.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [itemCount]
!           The number of items in a multi-valued Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Link a Component Attribute hierarchy to that of
!                                {\bf a Component or State}
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeSet()
!      subroutine ESMF_CplCompAttSetLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values  
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attaches a {\tt CplComp} or {\tt GridComp} Attribute hierarchy to the 
!     hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
!      
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp1
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp1
!     \end{description}
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp2
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp2
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link.
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Link a State Attribute hierarchy with the
!                               {\bf hierarchy of a FieldBundle, Field, or State}
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeSet()
!      subroutine ESMF_StateAttributeSetLink(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF\_State), intent(inout) :: state  
!      <object>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attaches a {\tt State} Attribute hierarchy to the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}. 
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
!     \item type(ESMF\_Field), intent(inout) :: field
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object.
!     \item [<object>]
!       The object with which to link hierarchies.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
!     subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     type(ESMF_VM), intent(in) :: vm
!     integer, dimension(:), intent(in) :: rootList
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Update an Attribute hierarchy during runtime.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [vm]
!           The virtural machine over which this Attribute hierarchy 
!           should be updated.
!     \item [rootList]
!           The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeWrite(<object>, convention, purpose, attwriteflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Write the Attribute package for <object>.  The Attribute package defines 
!     the convention, purpose, and object type of the associated Attributes.  Either
!     tab-delimited or xml format is acheived by using {\tt attwriteflag}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: cplcomp  
!     \item type(ESMF\_GridComp), intent(inout) :: gridcomp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [attwriteflag]
!           The flag to specify which format is desired for the write, the 
!           default is tab-delimited.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!     NOTE:  The options for {\tt attwriteflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTWRITE\_XML will write in xml format
!              \item ESMF\_ATTWRITE\_TAB will write in tab-delimited format
!            \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------


!-------------------------------------------------------------------------
!  Macro versions of the routines
!-------------------------------------------------------------------------

#define AttAddPackCustomMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCstm" @\
!BOPI @\
! !IROUTINE: AttAddPackCstm - Create the Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCstm(mthis, attrList, convention, & @\
      purpose, count, attpacknestflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), dimension(:), intent(in) :: attrList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: count @\
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Sets up a custom Attribute package for the object, or adds to an  @\
!     existing Attribute package. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [attrList] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [count] @\
!      The count of the number of Attributes to add to the package @\
!     \item [attpacknestflag] @\
!      The flag to tell whether this Attribute package is to be nested or not, possible values @\
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, directional, localCount                          ! Error status @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_AttPackNestFlag) :: attpacknest @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(count)) then @\
        if (localCount > size(attrList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "count cannot be larger than size(attrList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	localCount = count @\
      else @\
	localCount = size(attrList) @\
      end if @\
 @\
      if (localCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "attrList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      if (present(attpacknestflag)) then @\
        attpacknest = attpacknestflag @\
      else @\
        attpacknest = ESMF_ATTPACKNEST_OFF @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackCreate(mthisfield, fconvention, & @\
        fpurpose, fobject, attpacknest, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackCreate(mthisfield, convention, & @\
        fpurpose, fobject, attpacknest, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackCreate(mthisfield, fconvention, & @\
        purpose, fobject, attpacknest, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackCreate(mthisfield, convention, & @\
        purpose, fobject, attpacknest, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
 @\
      do i = 1, localCount @\
       @\
        select case (directional) @\
        case (0) @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), fconvention, & @\
          fpurpose, fobject, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        case (1) @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), convention, & @\
          fpurpose, fobject, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        case (2) @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), fconvention, & @\
          purpose, fobject, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        case (3) @\
        call c_ESMC_AttPackAddAttribute(mthisfield, attrList(i), convention, & @\
          purpose, fobject, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        end select @\
      end do @\
       @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCstm @\

!------------------------------------------------------------------------------ 

#define AttCopyMacro(mclass1, mclass2, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttributeCopy" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeCopy() @\
      subroutine mclass1##AttCopy(mthis1, mthis2, attcopyflag, atttreeflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1   @\
      type(mclass2), intent(inout) :: mthis2 @\
      type(ESMF_AttCopyFlag), intent(in) :: attcopyflag @\
      type(ESMF_AttTreeFlag), intent(in) :: atttreeflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Copy all Attributes in one hierarchy to another. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!     \item [attcopyflag] @\
!      A flag to determine if the copy is to be by reference, value, or both @\
!     \item [atttreeflag] @\
!      A flag to determine if the copy is supposed to descend the Attribute @\
!      hierarchy @\
!     \item [{[rc]}] @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeCopy(mthisfield1, mthisfield2, & @\
                                attcopyflag, atttreeflag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttCopy @\

!------------------------------------------------------------------------------

#define AttRemoveMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRemove() @\
      subroutine mclass##AttRemove(mthis, name, convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: name @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
! @\
! !DESCRIPTION: @\
!     Removes an Attribute on the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to destroy. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
   @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 3 .AND. .not.(present(name))) then @\
      call c_ESMC_AttPackRemove(mthisfield, convention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 0 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, fconvention, & @\
        fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, convention, & @\
        fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, fconvention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, convention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else if (present(name)) then @\
 @\
      call c_ESMC_AttributeRemove(mthisfield, name, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRemove @\

!------------------------------------------------------------------------------

#define AttGetDoc() \
!BOPI @\
!EOPI @\

#define AttGetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet##mtypekind(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(out) :: value @\
      mtype(ESMF_KIND_##mtypekind), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
         @\
      else @\
 @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet1D##mtypekind(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(out) :: valueList @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      else @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttGetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgcl(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(out) :: value @\
      logical, intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical Attribute from the {\tt array}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The logical value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue, present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, fpurpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, fpurpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, purpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, purpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
      value = localvalue @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgclList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(out) :: valueList @\
      logical, dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical list Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The logical values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of values in the Attribute. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
@\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgclList @\

!------------------------------------------------------------------------------

#define AttGetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetChar" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetChar(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(out) :: value @\
      character (len = *), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The character value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The character default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional  @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetChar(mthisfield, name, value, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @\
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = localrc @\
 @\
      end subroutine mclass##AttGetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCharList" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetCharList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len=*), dimension(:), intent(out) :: valueList @\
      character (len=*), dimension(:), intent(in), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The character list values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The character list default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The itemCount of the character items to retrieve @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      do  i=1,litemCount @\
        lens(i) = len (valueList) @\
      enddo @\
       @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (1) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (2) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      case (3) @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          do i=1,litemCount @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
          if (present(rc)) rc = ESMF_SUCCESS @\
          return @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalueList)) then @\
          do i=1,litemCount @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
          if (present(rc)) rc = ESMF_SUCCESS @\
          return @\
        else  @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                    "Attribute not found, and no default given", & @ \
                     ESMF_CONTEXT, rc) @\
          return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        valueList(i) = valueString(j:(j+lens(i)-1)) @\
        j = j + lens(i) @\
      enddo @\
 @\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCharList @\

!------------------------------------------------------------------------------

#define GetCountNameNumberMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCount" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet()  @\
      subroutine mclass##AttGetCount(mthis, count, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(out) :: count    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns the number of Attributes associated with the given object  @\
!     in the argument {\tt count}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [count] @\
!           The number of Attributes associated with this object. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetCount(mthisfield, count, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCount @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNam" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNam(mthis, name, typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character(len=*), intent(in) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns information associated with the named Attribute,  @\
!     including {\tt typekind} and {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to query. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           The number of items in this Attribute.  For character types, @\
!           the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc              @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoName(mthisfield, name, & @\
        localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNam @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNum" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNum(mthis, attributeIndex, name, & @\
        typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(in) :: attributeIndex @\
      character(len=*), intent(out) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns information associated with the indexed Attribute,  @\
!      including {\tt name}, {\tt typekind} and {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [attributeIndex] @\
!           The index number of the Attribute to query. @\
!     \item [name] @\
!           Returns the name of the Attribute. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           Returns the number of items in this Attribute.  For character types, @\
!           this is the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=len(name)) :: localName @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoNum(mthisfield, attributeIndex, & @\
        localName, localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      name = localName @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNum @\
 @\
      
!-----------------------------------------------------------------------------

#define AttLinkMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine mclass1##AttLink##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLink##mclass2short @\

!-----------------------------------------------------------------------------

#define ESMF_StateAttLinkMacro(mclass, mclassshort, mthis1, mthis2, mthisfield1, mthisfield2, mthisfield3, mobj) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAttLink" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLink() @\
      subroutine ESMF_StateAttLink##mclassshort(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(ESMF_State), intent(inout) :: mthis1 @\
      type(mclass), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt ESMF\_State} object. @\
!     \item [mthis2] @\
!      An {\tt mclass} object. @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
      type(ESMF_Logical) :: lvalue1, lvalue2 @\
      character (len=*), parameter :: lobject = #mobj @\
      character (len=*), parameter :: lname1 = 'import' @\
      character (len=*), parameter :: lname2 = 'export' @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,mthis1,rc) @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLink(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      ! set the import and export Attributes on any Field connected to this State @\
      lvalue1 = .true. @\
      lvalue2 = .false. @\
      if (mthis1%mthisfield3 == ESMF_STATE_IMPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (mthis1%mthisfield3 == ESMF_STATE_EXPORT) then @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname1, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) @\
        call c_ESMC_AttributeSetObjsInTree(mthisfield1, lobject, lname2, & @\
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine ESMF_StateAttLink##mclassshort @\

!-----------------------------------------------------------------------------

#define AttLinkRemoveMacro(mclass1, mclass2, mclass2short, mthis1, mthis2, mthisfield1, mthisfield2) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttLinkRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeLinkRemove() @\
      subroutine mclass1##AttLinkRemove##mclass2short(mthis1, mthis2, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass1), intent(inout) :: mthis1 @\
      type(mclass2), intent(inout)  :: mthis2 @\
      integer, intent(out), optional  :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Unattaches two Attribute hierarchies @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis1] @\
!      An {\tt mclass1} object. @\
!     \item [mthis2] @\
!      An {\tt mclass2} object. @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass1##GetInit,mthis1,rc) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass2##GetInit,mthis2,rc) @\
 @\
      call c_ESMC_AttributeLinkRemove(mthisfield1, mthisfield2, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass1##AttLinkRemove##mclass2short @\

!-----------------------------------------------------------------------------

#define AttReadMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRead" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRead() @\
      subroutine mclass##AttRead(mthis, fileName, convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character (len=*),   intent(in), optional :: fileName @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Read the Attribute package for the {\tt mthis}. @\
!     The Attribute package defines the convention, purpose, and object type @\
!     of the associated Attributes. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item[{[fileName]}] @\
!      The file name to be read from. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      ! initialize fileName length to zero for non-existent name @\
      integer :: fileNameLen, localrc @\
 @\
      fileNameLen = 0 @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call mclass##Validate(mthis, rc=localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
  @\
      ! get length of given fileName for C++ validation @\
      if (present(fileName)) then @\
        fileNameLen = len_trim(fileName) @\
      end if @\
 @\
      ! invoke C to C++ entry point @\
      ! TODO: convention, purpose @\
      call c_ESMC_AttributeRead(mthisfield, fileNameLen, fileName, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                              ESMF_ERR_PASSTHRU, & @\
                              ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRead @\

!------------------------------------------------------------------------------

#define AttSetDoc() \
!BOPI @\
!EOPI @\

#define AttSetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
 @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a 4-byte integer Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet##mtypekind(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a 4-byte integer Attribute to the object. @\
!      The Attribute has a {\tt name} and a {\tt value}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The integer value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional  @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a 4-byte integer list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet1D##mtypekind(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a 4-byte integer list Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of integer items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [valueList] @\
!           The integer values of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of integers in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
       @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttSetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgcl(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a logical Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      localvalue = value @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
 @\
      localvalue = value @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgclList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a logical list Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of logical items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false values of the Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of logicals in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
 @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) @\
 @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgclList @\

!------------------------------------------------------------------------------

#define AttSetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetChar" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetChar(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a character Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
 @\
      call c_ESMC_AttributeSetChar(mthisfield, name, value, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetCharList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetCharList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character(len=*), intent(in) :: name @\
      character (len = *), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a character Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, directional, litemCount @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
        if (itemCount > size(valueList)) then @\
          call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "itemCount cannot be larger than size(valueList)", & @\
                              ESMF_CONTEXT, rc) @\
          return @\
        endif @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      if (litemCount .le. 0) then @\
        call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & @\
                              "valueList is too small", & @\
                              ESMF_CONTEXT, rc) @\
        return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        lens(i) = len_trim(valueList(i)) @\
        valueString(j:(j+lens(i)-1)) = valueList(i) @\
        j = j + lens(i) @\
      enddo @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (1) @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (2) @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      case (3) @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end select @\
    else @\
 @\
      call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetCharList @\

!-----------------------------------------------------------------------------

#define AttUpdateMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttUpdate" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeUpdate() @\
      subroutine mclass##AttUpdate(mthis, vm, rootList, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      type(ESMF_VM), intent(in) :: vm @\
      integer, dimension(:), intent(in) :: rootList @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Update an Attribute hierarchy. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An {\tt mclass} object. @\
!     \item [vm] @\
!      The virtural machine over which this Attribute hierarchy  @\
!      should be updated. @\
!     \item [rootList] @\
!      The list of "root" PETs that are to be used to update. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, count                           ! Error status @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      count = size(rootList) @\
      call c_ESMC_AttributeUpdate(mthisfield, vm, rootList, count, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttUpdate @\

!-----------------------------------------------------------------------------

#define AttWriteMacro(mclass, mthis, mthisfield, mthisobj, mthistar) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttWrite" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file @\
 @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeWrite() @\
      subroutine mclass##AttWrite(mthis, convention, purpose, attwriteflag, rc) @\
 @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Write the Attribute package for the {\tt state}. @\
!     The Attribute package defines the convention, purpose, and object type  @\
!     of the associated Attributes. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [state] @\
!      An {\tt ESMF\_State} object. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [attwriteflag] @\
!      Flag to determine the format for writing the Attributes. @\
!     \item [{[rc]}]  @\
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthisobj @\
      character(len=*), parameter :: ftarobj=#mthistar @\
      type(ESMF_AttWriteFlag) :: writeflag @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (present(attwriteflag)) then @\
        writeflag = attwriteflag @\
      else @\
        writeflag = ESMF_ATTWRITE_TAB @\
      endif @\
 @\
      select case (directional) @\
      case (0) @\
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
        call c_ESMC_AttributeWriteTab(mthisfield, fconvention, & @\
          fpurpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
        call c_ESMC_AttributeWriteXML(mthisfield, fconvention, & @\
          fpurpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      endif @\
      case (1) @\
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
        call c_ESMC_AttributeWriteTab(mthisfield, convention, & @\
          fpurpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
        call c_ESMC_AttributeWriteXML(mthisfield, convention, & @\
          fpurpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      endif @\
      case (2) @\
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
        call c_ESMC_AttributeWriteTab(mthisfield, fconvention, & @\
          purpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
        call c_ESMC_AttributeWriteXML(mthisfield, fconvention, & @\
          purpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      endif @\
      case (3) @\
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then @\
        call c_ESMC_AttributeWriteTab(mthisfield, convention, & @\
          purpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then @\
        call c_ESMC_AttributeWriteXML(mthisfield, convention, & @\
          purpose, fobject, ftarobj, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end select @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttWrite @\

!-------------------------------------------------------------------------
!  ARRAY
!-------------------------------------------------------------------------
#if 0
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayAttAddPack"
!BOPI
! !IROUTINE: ESMF_ArrayAttAddPack - Create an array Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_ArrayAttAddPack(array, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt array}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!      An {\tt ESMF\_Array} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='array'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'standard_name'
      character (len=*), parameter :: name3 = 'long_name'
      character (len=*), parameter :: name4 = 'units'
      character (len=*), parameter :: name5 = 'import'
      character (len=*), parameter :: name6 = 'export'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(array, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(array, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(array, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(array, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(array, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(array, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(array, name6, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayAttAddPack
#endif
!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Array, array, array)
AttRemoveMacro(ESMF_Array, array, array)

TypeKind3DeclarationMacro(AttGet, ESMF_Array, array, array)
AttGetLogicalMacro(ESMF_Array, array, array)
AttGetCharacterMacro(ESMF_Array, array, array)

GetCountNameNumberMacro(ESMF_Array, array, array)      

TypeKind3DeclarationMacro(AttSet, ESMF_Array, array, array)
AttSetLogicalMacro(ESMF_Array, array, array)
AttSetCharacterMacro(ESMF_Array, array, array)

#if 0
AttUpdateMacro(ESMF_Array, array, array)
AttWriteMacro(ESMF_Array, array, array, array, array)
#endif

!-------------------------------------------------------------------------
!  ARRAYBUNDLE
!-------------------------------------------------------------------------
#if 0
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayBundleAttAddPack"
!BOPI
! !IROUTINE: ESMF_ArrayBundleAttAddPack - Create an arraybundle Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_ArrayBundleAttAddPack(arraybundle, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_ArrayBundle), intent(inout) :: arraybundle  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt arraybundle}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [arraybundle]
!      An {\tt ESMF\_ArrayBundle} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='arraybundle'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'standard_name'
      character (len=*), parameter :: name3 = 'long_name'
      character (len=*), parameter :: name4 = 'units'
      character (len=*), parameter :: name5 = 'import'
      character (len=*), parameter :: name6 = 'export'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(arraybundle, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(arraybundle, name6, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayBundleAttAddPack
#endif
!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttRemoveMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

TypeKind3DeclarationMacro(AttGet, ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttGetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

GetCountNameNumberMacro(ESMF_ArrayBundle, arraybundle, arraybundle)      

TypeKind3DeclarationMacro(AttSet, ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetLogicalMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttSetCharacterMacro(ESMF_ArrayBundle, arraybundle, arraybundle)

#if 0
AttUpdateMacro(ESMF_ArrayBundle, arraybundle, arraybundle)
AttWriteMacro(ESMF_ArrayBundle, arraybundle, arraybundle, arraybundle, arraybundle)
#endif

!-------------------------------------------------------------------------
!  CplComp
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttAddPack"
!BOPI
! !IROUTINE: ESMF_CplCompAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_CplCompAttAddPack(comp, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_CplComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='comp'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'full_name'
      character (len=*), parameter :: name3 = 'version'
      character (len=*), parameter :: name4 = 'discipline'
      character (len=*), parameter :: name5 = 'physical_domain'
      character (len=*), parameter :: name6 = 'agency'
      character (len=*), parameter :: name7 = 'institution'
      character (len=*), parameter :: name8 = 'author'
      character (len=*), parameter :: name9 = 'coding_language'
      character (len=*), parameter :: name10 = 'model_component_framework'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(comp%compp%base, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name6, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name7, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name8, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name9, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name10, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_CplComp, comp, comp%compp%base)
AttCopyMacro(ESMF_CplComp, ESMF_CplComp, comp1, comp2, comp1%compp%base, comp2%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_CplComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_CplComp, comp, comp%compp%base)

AttLinkMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_GridComp, GridComp, comp1, comp2,  & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_CplComp, ESMF_State, State, comp, state,  & @\
                comp%compp%base, state%statep%base)

AttRemoveMacro(ESMF_CplComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_CplComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_CplComp, comp, comp%compp%base)
AttWriteMacro(ESMF_CplComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  GridComp
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttAddPack"
!BOPI
! !IROUTINE: ESMF_GridCompAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_GridCompAttAddPack(comp, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_GridComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='comp'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'full_name'
      character (len=*), parameter :: name3 = 'version'
      character (len=*), parameter :: name4 = 'discipline'
      character (len=*), parameter :: name5 = 'physical_domain'
      character (len=*), parameter :: name6 = 'agency'
      character (len=*), parameter :: name7 = 'institution'
      character (len=*), parameter :: name8 = 'author'
      character (len=*), parameter :: name9 = 'coding_language'
      character (len=*), parameter :: name10 = 'model_component_framework'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(comp%compp%base, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name6, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name7, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name8, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name9, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(comp%compp%base, name10, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_GridComp, comp, comp%compp%base)
AttCopyMacro(ESMF_GridComp, ESMF_GridComp, comp1, comp2, comp1%compp%base, comp2%compp%base)
AttRemoveMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_GridComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_GridComp, comp, comp%compp%base)

AttLinkMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_CplComp, CplComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_GridComp, GridComp, comp1, comp2, & @\
                comp1%compp%base, comp2%compp%base)
AttLinkRemoveMacro(ESMF_GridComp, ESMF_State, State, comp, state, & @\
                comp%compp%base, state%statep%base)

AttReadMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_GridComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

AttUpdateMacro(ESMF_GridComp, comp, comp%compp%base)
AttWriteMacro(ESMF_GridComp, comp, comp%compp%base, comp, field)

!-------------------------------------------------------------------------
!  DISTGRID
!-------------------------------------------------------------------------

#if 0
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_DistGridAttAddPack"
!BOPI
! !IROUTINE: ESMF_DistGridAttAddPack - Create an distgrid Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_DistGridAttAddPack(distgrid, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_DistGrid), intent(inout) :: distgrid  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt distgrid}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [distgrid]
!      An {\tt ESMF\_DistGrid} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      ! There is no standard Attribute package for DistGrid at this point
      call c_ESMC_AttPackCreate(distgrid, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(distgrid, name6, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_DistGridAttAddPack
#endif
!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttGet, ESMF_DistGrid, distgrid, distgrid)
AttGetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttGetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

GetCountNameNumberMacro(ESMF_DistGrid, distgrid, distgrid)      

AttRemoveMacro(ESMF_DistGrid, distgrid, distgrid)

TypeKind3DeclarationMacro(AttSet, ESMF_DistGrid, distgrid, distgrid)
AttSetLogicalMacro(ESMF_DistGrid, distgrid, distgrid)
AttSetCharacterMacro(ESMF_DistGrid, distgrid, distgrid)

#if 0
AttWriteMacro(ESMF_DistGrid, distgrid, distgrid, distgrid, distgrid)
#endif

!-------------------------------------------------------------------------
!  FIELD
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldAttAddPack"
!BOPI
! !IROUTINE: ESMF_FieldAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_FieldAttAddPack(field, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Field), intent(inout) :: field  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt field}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!      An {\tt ESMF\_Field} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='field'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'standard_name'
      character (len=*), parameter :: name3 = 'long_name'
      character (len=*), parameter :: name4 = 'units'
      character (len=*), parameter :: name5 = 'import'
      character (len=*), parameter :: name6 = 'export'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(field%ftypep%base, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(field%ftypep%base, name6, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FieldAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_Field, field, field%ftypep%base)
AttGetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttGetCharacterMacro(ESMF_Field, field, field%ftypep%base)

GetCountNameNumberMacro(ESMF_Field, field, field%ftypep%base)

AttRemoveMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_Field, field, field%ftypep%base)
AttSetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttSetCharacterMacro(ESMF_Field, field, field%ftypep%base)

AttUpdateMacro(ESMF_Field, field, field%ftypep%base)
AttWriteMacro(ESMF_Field, field, field%ftypep%base, field, field)

!-------------------------------------------------------------------------
!  FIELDBUNDLE
!-------------------------------------------------------------------------

#if 0
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldBundleAttAddPack"
!BOPI
! !IROUTINE: ESMF_FielBundleAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_FieldBundleAttAddPack(fieldbundle, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_FieldBundle), intent(inout) :: fieldbundle  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt fieldbundle}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!      An {\tt ESMF\_FieldBundle} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='fieldbundle'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc)

      fconvention = convention
      fpurpose = purpose
      
       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      ! no standard attribute package for FieldBundle at this time
      localrc = ESMF_SUCCESS

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FieldBundleAttAddPack

!------------------------------------------------------------------------------
#endif 

AttAddPackCustomMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

GetCountNameNumberMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

AttLinkMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%btypep%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_FieldBundle, ESMF_Field, Field, fieldbundle, field, & @\
                fieldbundle%btypep%base, field%ftypep%base)

AttRemoveMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

AttUpdateMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttWriteMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base, fieldbundle, field)

!-------------------------------------------------------------------------
!  GRID
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridAttAddPack"
!BOPI
! !IROUTINE: ESMF_GridAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_GridAttAddPack(grid, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(inout) :: grid  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt grid}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!      An {\tt ESMF\_Grid} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='grid'
      character (len=*), parameter :: name1 = 'area'
      character (len=*), parameter :: name2 = 'dimension_order'
      character (len=*), parameter :: name3 = 'discretization_type'
      character (len=*), parameter :: name4 = 'geometry_type'
      character (len=*), parameter :: name5 = 'grid_type'
      character (len=*), parameter :: name6 = 'horizontal_dimension_value'
      character (len=*), parameter :: name7 = 'IsConformal'
      character (len=*), parameter :: name8 = 'IsRegular'
      character (len=*), parameter :: name9 = 'IsUniform'
      character (len=*), parameter :: name10 = 'north_pole_location'
      character (len=*), parameter :: name11 = 'number_of_cells'
      character (len=*), parameter :: name12 = 'number_of_dimensions'
      character (len=*), parameter :: name13 = 'pole_covered'
      character (len=*), parameter :: name14 = 'vertical_dimension_value'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(grid, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name2, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name3, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name4, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name5, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name6, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name7, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name8, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name9, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name10, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name11, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name12, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name13, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(grid, name14, fconvention, &
        fpurpose, fobject, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttGet, ESMF_Grid, grid, grid)
AttGetLogicalMacro(ESMF_Grid, grid, grid)
AttGetCharacterMacro(ESMF_Grid, grid, grid)

GetCountNameNumberMacro(ESMF_Grid, grid, grid)

AttRemoveMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttSet, ESMF_Grid, grid, grid)
AttSetLogicalMacro(ESMF_Grid, grid, grid)
AttSetCharacterMacro(ESMF_Grid, grid, grid)

#if 0
AttUpdateMacro(ESMF_Grid, grid, grid)
AttWriteMacro(ESMF_Grid, grid, grid, grid, grid)
#endif

!-------------------------------------------------------------------------
!  STATE
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttAddPack"
!BOPI
! !IROUTINE: ESMF_StateAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_StateAttAddPack(state, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt state}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='state'
      character (len=*), parameter :: name1 = 'import'
      character (len=*), parameter :: name2 = 'export'
      type(ESMF_Logical) :: lvalue
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(state%statep%base, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackAddAttribute(state%statep%base, name1, fconvention, &
        fpurpose, fobject, localrc)
      call c_ESMC_AttPackAddAttribute(state%statep%base, name2, fconvention, &
        fpurpose, fobject, localrc)

      lvalue = .true.
      if (state%statep%st == ESMF_STATE_IMPORT) then
        call c_ESMC_AttPackSetValue(state%statep%base, name1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue, &
          fconvention, fpurpose, fobject, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (state%statep%st == ESMF_STATE_EXPORT) then
        call c_ESMC_AttPackSetValue(state%statep%base, name2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue, &
          fconvention, fpurpose, fobject, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttAddPack


!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_State, state, state%statep%base)
AttCopyMacro(ESMF_State, ESMF_State, state1, state2, state1%statep%base, state2%statep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_State, state, state%statep%base)
AttGetLogicalMacro(ESMF_State, state, state%statep%base)
AttGetCharacterMacro(ESMF_State, state, state%statep%base)

GetCountNameNumberMacro(ESMF_State, state, state%statep%base)

ESMF_StateAttLinkMacro(ESMF_Field, Field, state, field, state%statep%base, & @\
                          field%ftypep%base, statep%st, field)
ESMF_StateAttLinkMacro(ESMF_FieldBundle, FieldBundle, state, fieldbundle, state%statep%base, & @\
                          fieldbundle%btypep%base, statep%st, field)
ESMF_StateAttLinkMacro(ESMF_State, State, state1, state2, state1%statep%base, & @\
                          state2%statep%base, statep%st, field)
AttLinkRemoveMacro(ESMF_State, ESMF_Field, Field, state, field, & @\
                state%statep%base, field%ftypep%base)
AttLinkRemoveMacro(ESMF_State, ESMF_FieldBundle, FieldBundle, state, fieldbundle, & @\
                state%statep%base, fieldbundle%btypep%base)
AttLinkRemoveMacro(ESMF_State, ESMF_State, State, state1, state2, & @\
                state1%statep%base, state2%statep%base)

AttRemoveMacro(ESMF_State, state, state%statep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_State, state, state%statep%base)
AttSetLogicalMacro(ESMF_State, state, state%statep%base)
AttSetCharacterMacro(ESMF_State, state, state%statep%base)

AttUpdateMacro(ESMF_State, state, state%statep%base)
AttWriteMacro(ESMF_State, state, state%statep%base, state, field)

!------------------------------------------------------------------------------

end module ESMF_AttributeMod
