% $Id: ESMF_archoverview.tex,v 1.12 2004/06/22 20:08:55 cdeluca Exp $

\section{Architectural Overview}
\label{sec:ArchOver}
The ESMF architecture is characterized by the layering strategy shown in Figure \ref{fig:TheESMFwich}. User code components that implement the {\it science} portions of an application, for example a sea ice or land model, are sandwiched 
between two layers. The upper layer is denoted the {\bf superstructure} layer 
and the lower layer the {\bf infrastructure} layer. The role of the superstructure layer is to provide a shell which encompasses user code and provides a context for interconnecting input and output
data streams between components. The key elements of the superstructure are described in section \ref{sec:superstructure}.
These elements include classes that wrap user code, ensuring that all
components present consistent interfaces. The infrastructure layer provides a foundation that developers of
user components can use to speed construction and to ensure consistent, guaranteed behavior of components.
The elements of the infrastructure include constructs to support parallel processing with data types tailored
to Earth science applications, specialized libraries to support consistent time and calendar management and
performance, error handling and scalable I/O tools. The infrastructure layer is described in section \ref{sec:infrastructure}.
A hierarchical combination of superstructure, user code components, and infrastructure are joined together to form an ESMF application.



\subsection{Key Concepts}

The ESMF architecture and programming paradigm are based upon 
five key concepts:  modularity, flexibility, scalability, local 
communication, and a uniform communication API.  

\subsubsection{Modularity}

The ESMF design is based upon modular components.  There
are two types of components, one of which represents models 
(GridComp) and one which represents couplers (CplComp).  Data
are always passed between components using a data structure 
called a State, which can store Fields, Bundles of Fields,
and Arrays.  A GridComp stores no information about the internals 
of the GridComps that it interacts with; this information is 
passed in through the argument lists of its initialize, run, 
and finalize methods.  The information that is 
passed in through the argument list can be a State from 
another GridComp, or it can be a function pointer that performs
a computation or communication on a State.  These function 
pointers (not yet implemented) are called Transforms, and they 
are created by CplComps.  They are called inside the GridComp they 
are passed into.  Although Transforms add some complexity to the 
framework (and their use is not required), they are what will
enable ESMF to accommodate virtually any model of communication 
between components. 

{\bf Modularity means that an ESMF component stores nothing about 
the internals of other components.  This allows components to be 
used more easily in multiple contexts.}

\subsubsection{Flexibility}
The ESMF does not dictate how models should be coupled, it
simply provides tools for creating couplers.  For example, 
both a hub-and-spokes type coupling strategy and  
pairwise strategies are supported.  The ESMF also allows model
communications to occur mid-timestep, if desired.  Sequential, 
concurrent, and mixed
modes of execution are supported.  

{\bf The ESMF does not impose restrictions on how data flows through 
an application.  This accommodates scientific innovation - if you 
want your atmospheric model to communicate with your sea ice model
mid-timestep, ESMF will not stop you.  It may, in fact, make
it easier.}

\subsubsection{Scalability}
The ESMF allows applications to be composed hierarchically.
For example, physics and dynamics modules can be defined as 
separate GridComps, coupled together with a CplComp, and this 
whole system can be nested within a single atmospheric GridComp.
The atmospheric GridComp can be run standalone, or can be included
in a larger climate or data assimilation application.  See Figure
\ref{fig:appunit} for an illustrative example.

The data structure that enables scalability in ESMF is the
derived type GridComp.  Fortran alone doesn't allow you to create
generic components - you'd have to create derived types for
PhysComp, and DynComp, and PhysDynCouplerComp, and AtmComp.  In 
ESMF, these are always of type GridComp or CplComp, so they 
can be called by the same drivers (whether that driver is a 
standard ESMF driver or another model), and use the same methods
without having to overload them with many specific derived 
types.  It's the same idea when you want to support different 
implementations of the same component, like multiple dynamics.

{\bf In short, the ESMF defines a sensible scalable 
architecture for organizing very complex applications, and
for allowing exchangeable components.}

\begin{figure}
\caption{A typical building block for an ESMF application consists of a 
parent GridComp, two or more child GridComps, and 
a CplComp.  The parent GridComp is called by an 
AppDriver.  All ESMF components have Initialize, Run, and 
Finalize methods.  The diagram shows that when the AppDriver calls 
Initialize on a parent GridComp, the call cascades down to
all of its children, so that the result is that the entire ``tree''
of components is initialized.  The Run and Finalize methods work the
same way.  In this example a hurricane simulation is built 
from ocean and atmosphere GridComps.  The data exchange between 
the ocean and atmosphere is handled by an ocean-atmosphere CplComp.  
Since the whole hurricane simulation is a GridComp,
it could be easily be treated as a child and coupled to another
GridComp, rather than being driven directly by the AppDriver.}
\label{fig:appunit}
\scalebox{1.0}{\includegraphics{ESMF_appunit.eps}}
\end{figure}

\subsubsection{Local Communication}
Communication in ESMF always occurs within a component.  It
can occur internal to a GridComp, and have nothing to do 
with interactions with other components (setting aside 
synchronization issues), or it can occur within a CplComp
or a Transform generated by a CplComp.  This means that
CplComps must always be defined on the union of all the
components that they couple together.  Models can choose to 
use whatever mechanism they want for intra-model communications.  

{\bf The point is that although the ESMF defines some simple rules 
for communication, the communication mechanism that the 
framework uses is not hardwired into its architecture -
the sends and receives or puts and gets are enclosed within 
the CplComps and Transforms. This is designed to accommodate 
multiple models of communication and technical innovations.}

\subsubsection{Uniform Communication API}
We are trying to create a single API for shared and distributed
memory that, unlike MPI, accounts for NUMA achitectures and 
does not treat all processes as being identical.  It's possible for
users to set ESMF communications to a strictly message passing 
mode and put in their own OpenMP commands.

{\bf The goal is to create a programming paradigm 
that is peformance sensitive to the architecture beneath it 
without being discouragingly complicated.}

\subsection{Superstructure}
\label{sec:superstructure}
The ESMF superstructure layers in an application furnish a unifying context within which user components are interconnected. The superstructure provides
the foundation for a flexible mechanism to address physical consistency between components that may use different dimensions or units to represent the
same quantity or that may partition physical data differently. Classes called {\bf Gridded Components}, 
{\bf Coupler Components}, and {\bf States} are used within the superstructure to achieve this flexibility.
We describe these classes below:

\subsubsection{Import and Export State Classes}
User code components under ESMF use special interface objects for component to component data exchanges. These objects are 
of type import State and export State. These special types support a variety of methods that allow user code components 
to, for example, fill an export State object with data to be shared with other components or query an import State object to 
determine its contents. In keeping with the overall requirements for high-performance it is permitted for import State and
export State contents to use references or pointers to component data, so that costly data copies of potentially
very large data structures can be avoided where possible. The content of an import State and an export State can be made 
self-describing.

\subsubsection{Interface Standards}
The import State and export State abstractions are designed to be flexible enough
that ESMF does not need to mandate a single standard for fields. For example ESMF does not prescribe the units
of quantities exported or imported, instead it provides mechanics to describe the units, memory layout, grid coordinates 
of the fields in States.  This allows the ESMF software to support a range of different policies for
physical fields. The interoperability experiments that we are using to demonstrate ESMF make use of the emerging
CF conventions \cite{ref:CF} for describing physical fields. This is a policy choice for that set of experiments. The ESMF 
software itself can support arbitrary conventions for labeling and characterizing the content of States.

\subsubsection{Gridded Component Class}
The Gridded Component class is used to for a user component that takes in one import State and produces one
export State, both based on the same discrete grid. Examples of Gridded Components are major Earth system 
model components such as land-surface models, ocean models, atmospheric models and sea-ice models. Components 
used for linear algebra manipulations in a state-estimation or data-assimilation optimization procedure are also 
created as Gridded Components. In general the Import State and the Export State of a Gridded Component will 
use the same base discrete grid.

\subsubsection{Coupler Component Class}
The other top-level component class supported in the current ESMF architecture is a Coupler Component class.
This class is used for components that take one or more Import States as input and map them through
spatial and temporal interpolation or extrapolation onto an output Export State. In a Coupler Component
it is often the case that the output Export State is on a different base discrete grid to that of
the Import State(s). The role of Coupler Components is generally mapping the Export States from one or
more Gridded Components to the Import State of another Gridded Component. For example, in a coupled
ocean-atmosphere simulation a Couple Component would be used to map a set of sea-surface fields 
in an ocean model to appropriate planetary boundary layer fields in an atmospheric model.
\subsubsection{Flexible data and control flow}
Import States, Export States, Gridded Components and Coupler Components can be arrayed flexibly
within a {\bf Superstructure} layer. Using these constructs it is possible to configure a set of concurrently
executing Gridded Components joined through a single Coupler Component of the style shown in figure 
\ref{fig:hubspoke}. Is is also possible to configure a set of sequentially executing components with multiple
pair-wise Coupler Components defined to support individual Gridded Component to Gridded 
Component mappings independently, figure \ref{fig:point2point}.

\begin{figure}
\caption{ESMF can support configurations with a single central Coupler Component. In this case inputs from all Gridded 
Components are transferred and regridded between all components in one place.}
\label{fig:hubspoke}
\scalebox{1.0}{\includegraphics{ESMF_hubandspokes.eps}}
\end{figure}

\begin{figure}
\caption{ESMF also supports configurations with multiple point to point Coupler Components. 
These take inputs from one Gridded
Component and transfer and regrid the data for passing to another Gridded Component. This schematic shows a 
flow of data between two Coupler Components that connect three Gridded Components:  an atmosphere model with a land model, and the same atmosphere model with a data assimilation system.}
\label{fig:point2point}
\scalebox{1.0}{\includegraphics{ESMF_pairwise.eps}}
\end{figure}

The set of {\bf Superstructure} abstractions allows flexible data-flow and control between components. However, 
components will often use different discrete grids, and time-stepping components may march forward with different time
intervals. In a parallel compute environment different components may be distributed in a different manner on the
underlying compute resources. The ESMF {\bf Infrastructure} layer provides elements to manage this complexity.

\subsection{Infrastructure}
\label{sec:infrastructure}
Figure \ref{fig:threecomponents} illustrates three Gridded Components that use three different grids being coupled together. In 
order to achieve this coupling several steps beyond defining {\bf Superstructure} Import State and Export State objects to act
as data conduits are required. Coupler Components are required that can map between the different
grids, this mapping may also involve mapping between different units and/or memory layout conventions for the fields that
pass between components. In a parallel compute environment the Coupler Components may also be required to map between different 
domain decompositions. In order to advance in time correctly the separate Gridded Components must have compatible notions
of time. Approaches to parallelism within the Gridded Components must also be compatible. The {\bf Infrastructure} layer
contains a set of classes that address these issues and assist in managing overall system complexity. We describe
these classes below:

\begin{figure}
\caption{Schematic showing the coupling of components that use different discrete grids and different time-stepping. 
In this example component {\it NCAR Atmosphere} might use a spectral grid based on spherical harmonics, component
{\it GFDL Ocean} might use a latitude-longitude grid but with a patched decomposition that does not include
land masses and component {\it NSIPP Land} might use a mosaic based grid for representing vegetation patchiness
and a catchment area based grid for river routings. The {\bf Infrastructure} layer contains tools to help develop 
software for coupling between components on different grids, mapping between components with different distributions in a 
multi-processor compute environment and to synchronize events between components with different time-stepping intervals 
and algorithms.  }
\label{fig:threecomponents}
\scalebox{0.5}{\includegraphics{regrid.eps}}
\end{figure}

\subsubsection{Field and Array Classes}
The {\it Field} and {\it Array} classes contain data together with descriptive
physical and computational attribute information. The physical attributes include information that describes the units
of the data. The computational attributes include information on the layout in memory of the field data. The Field class
is primarily geared toward structured data. A comparable class called {\it Location Stream} provides a self-describing
container for unstructured observational data streams.

\subsubsection{Physical Grid Class}
The {\it Physical Grid} class is an extensible class that holds discrete grid information. It has subtypes that allow
it to serve as a container for the full range of different physical grids that might arise in a coupled system.
In the example in figure \ref{fig:threecomponents} objects of type Physical Grid would hold grid information for
each of the spectral grid, the latitude-longitude grid, the mosaic grid and the catchment grid. 

\subsubsection{Regrid Class}
The {\it Regrid} class is an extensible class that allows conservative remapping between a field on one physical grid
to a field on a different physical grid \cite{ref:SCRIP}. It supports precomputation of grid interpolation weights and allows user selectable
corrections for global or local conservation requirements. Regrid is designed to be scalable on parallel platforms.
When mapping between grids
the Regrid class utilizes the Physical Grid object and Field and Array objects.

\subsubsection{Distributed Grid Class}
The {\it Distributed Grid} class is used to represent the decomposition of a data structure into sub-domains, typically for
parallel processing purposes. The class is designed to support a generalized ``ghosting'' for tiled 
decompositions of finite difference, finite volume and finite element codes. 

\subsubsection{Time and Calendar Management Class}
To support synchronization between components {\it Time} and {\it Calendar} classes along with an associated
{\it Clock} class are provided. These classes allow Gridded and Coupler Component processing
to be latched to a common controlling clock.

\subsubsection{I/O Classes}
The {\bf Infrastructure} layer defines a set of {\it I/O} classes for storing and retrieving Field and Grid information
to and from persistent storage. The I/O classes support a range of standard formats including binary I/O and netCDF, HDF5 and
GRIB based I/O.

\subsubsection{Communication Class}
To provide a mechanism for ensuring performance portability ESMF defines a {\it Communication} class. This class provides a set of
high-level platform independent interfaces to performance critical parallel processing communication routines. These routines can be tuned
to specific platforms to ensure optimal parallel performance on many platforms. The Communication class includes reduction
operations, transpose or redistribution operations and halo or ghost operations.

\subsubsection{Logging and Profiling Class}
The {\it Logging} and {\it Profiling} classes are designed to aid in managing the complexity of multi-component applications. They provide
ESMF with a unified mechanism for notification messages, for timing and counting events.





