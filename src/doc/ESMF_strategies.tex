\section{Design Strategies}

Given the computational demands of Earth system modeling, the ESMF is by 
necessity complicated software running on complicated hardware.  However,
our goal is to develop a framework that is straightforward to understand and 
start using, reasonable to maintain, and amenable to extension.  To these 
ends we have adopted a design approach that modularizes the framework in a 
systematic and intuitive way.  Our architecture combines elements of 
object-oriented design, component-based design, and software layering, 
complementary approaches for ordering and decomposing software that apply
at different scales.  Object-oriented design organizes software into families 
of related structures that include even 
small data elements and minor functions.  Component-based design addresses 
larger software elements that are consistently defined and that interact
in a prescribed manner.  By layering we mean roughly apportioning elements 
of a software system into a few levels of a calling hierarchy.
All of these are useful conceptual tools for designing, understanding, and
explaining the structure of ESMF.

\subsection{Object-Oriented Design}

The ESMF is being designed using object-oriented (OO) principles.  OO design
is based on {\it classes}, which organize data, attributes, and associated 
operations into well-defined structures.  The OO approach distinguishes between 
the abstract concept of a class and an actual implementation or instance of the 
class, which is called an {\it object}.  The actual implementation of an 
abstract {\it operation} is called a {\it method}.

OO design is characterized by {\it encapsulation}, {\it inheritance}, and 
{\it polymorphism}.  Encapsulation means making data 
private to a particular class so that the underlying representation
can be changed or extended without changing the user interface to the class.
Inheritance allows specialized classes to inherit standard behavior from one
or more base
classes.  Polymorphism allows a single method to accept a variety of 
different argument lists when performing conceptually similar operations.  
Together these OO strategies help to organize and streamline codes, making 
them more flexible, maintainable, and extensible. 

In this document we use the Unified Modeling Language (UML) as a visual tool 
to express the structure of 
classes, to define the relationships between classes, and to describe sequences
of actions.  The diagrams are reasonably intuitive, and we provide 
only a basic explanation of concepts.  A reader interested in more detail should 
refer to a text such as ``The Unified Modeling Language Reference Manual.''

\subsection{Component-Based Design}

In this section we describe the features of component-based software 
architecture, then outline how the ESMF borrows from that model.  Unlike
OO design, the basic concepts of component-based design are not especially
easy to grasp and are not widely understood throughout the Earth system 
modeling community.  We therefore go into some detail.

\subsubsection{What is Component-Based Design?}

In component-based design, applications are constructed using software entities 
called components, which are accessed only through {\it interfaces}.  
An interface is an array of function pointers.  Components usually have multiple 
interfaces, with each interface representing a collection of functionally 
related methods.  In addition to components, component 
architectures must define some sort of control mechanism that can handle tasks 
such as acquiring computing resources and starting an application, 
and creating, running, sequencing and synchronizing components.  We'll refer to
this mechanism as the Object Request Broker (ORB), as it's called in CORBA.  In the 
Common Component Architecture, this is called the framework - a different usage
of the word than we are accustomed to in ESMF.

The component model gets more complicated when, as in most ESMF applications, 
an application contains multiple processes.  Calling a 
method using a function pointer requires that the calling code share the 
same process as the called function.  

In COM and CORBA, component {\it proxies} are defined across
all the processes in the application.  A component proxy consists of gutted 
versions of all the functions in the interfaces of the component.  If the 
called function shares the same process as the caller, the proxy just 
calls the local function.  If the called component is in a different process, 
the proxy initiates some action such as a RPC through which a {\it stub} in 
the remote process actually makes the function call.\footnote{Different 
component systems call proxies and 
stubs by different names - skeletons, etc., but the concept remains the same.}  
The CCA architecture gets around this complication by 
requiring that all cross-process communication occur within a component, and
that all inter-component calls exchange only local data.  So, for example,
if you wanted to transfer data between two CCA components A and B, you would need 
to define a third component C on the union of A and B's processors and perform
the data transfer entirely within component C.

Another feature common to component architectures is an Interface Definition 
Language (IDL).  This is a language-independent way to express 
interfaces.  \footnote{In practice IDLs tend to look a lot like C++.}  Although 
an IDL isn't central to the notion of component architectures, it does enable 
niceties such as allowing the ORB to automatically generate proxies and stubs.

\subsubsection{ESMF Components}

The ESMF architecture is based on those aspects of component-based design that
provide the most immediate benefits, are feasible to implement within the
timeframe of our project, and will enable us to be compatible with projects 
such as the CCA as those projects evolve.  

For example, the ESMF architecture includes a a base class for
all ESMF components that defines a set of common and consistent attributes
and methods.  This enables a variety of components - with different functionality, from different sources, at both large scales and small - to be handled
in a coherent way and to reuse the same control, communication and utility
mechanisms.  It also provides a clear definition of ESMF components so that
project such as CCA can understand and support them.  

The ESMF, like CCA, requires that all cross-process communication occur
within a component, and that all inter-component calls exchange only
local data.  This greatly simplifies the architecture, without 
imposing undue restrictions on communication mechanisms within component
models or the ESMF.

There are also aspects of component-based design that we will not adopt.
IDLs require significant effort to implement and there is currently no
IDL which supports the languages we require, F90 and C++.  We see no pressing
reason to develop one or to use ESMF resources to accelerate the development
of one.  We will continue to track the 
development of and experiment with the Scientific IDL (SIDL) being 
developed by CCA, as described in the {\it ESMF Implementation Report}.

We do not anticipate using function pointers exclusively to manipulate
components in our initial implementation of ESMF.  We will conceptually
group related component methods into interfaces, and wherever possible 
make them consistent across different types of components.

\end{itemize}

\subsection{Layered Architecture}

The ESMF and the applications that use it will be layered.  Layering generally 
refers to a calling hierarchy, in which some pieces of the software are composed 
of and/or call other pieces.  This is true of most software systems, so 
saying simply that the ESMF is layered does not add much to our understanding.  
It is more useful to look at a number of layering strategies, 
and identify which of these apply to ESMF.

\subsubsection{Types of Layering}

We use the term {\it hardware layering} to refer to a strategy to encapsulate 
programming constructs and tools that reflect the structure of the underlying 
computing environment.  In hardware layering, a bottom layer typically includes 
vendor-specific constructs.  Middle layers may automatically 
handle standard operations, such as distributed transposes, that do not involve  
vendor-specific calls but still reflect the computer architecture.  At the highest
level, the user handles objects that represent the application 
domain and not the computing environment.  POOMA is an example of a framework
that employs hardware layering.  

Hardware layering is one form of {\it layering by generality}; general 
tools that can apply to many application domains are relegated to bottom layers, 
while domain-specific constructs are in top layers.  This paradigm is
common even in systems running on simple hardware architectures, where 
vendor-specific
constructs and other threats to portability and ease of use are not a concern.
Its pervasiveness is simply a reflection of the fact that general tools 
enable a variety of applications to be built upon them.

An alternative view of layers results from combining multiple modes of parallelism 
in a single application.  In Earth system models individual model 
components typically run as \htmladdnormallink{data parallel}{glos:DataParallel} 
operations.  When a number of 
these are combined in an application such as a coupled climate model, individual 
components or sets of individual components may run as \htmladdnormallink{task 
parallel}{glos:TaskParallel} operations 
on non-overlapping sets of nodes.  Data parallel operations can be viewed
as residing in a lower layer, while the task parallel constructs that 
synchronize and referee data transfers occur at a higher level. We refer to 
this as {\it task layering}.

Closely related to task layering is the {\it data structure layering} used 
in the Weather Research and Forecast (WRF) model.  The top ``driver'' layer 
in this approach specifies data decompositions and controls
the flow of execution.  The lowest ``model'' layer consists of physics routines that
operate on simple arrays.  The middle ``mediation''layer is responsible for 
extracting these simple arrays from the data structures in the driver.
While task layering places domain-specific constructs in lower layers, hardware 
layering place domain-specific constructs in the upper layers.  

Different layering strategies can be alternative ways of viewing the same
software; a coupled model can without inconsistency 
be developed both as an application with task layering and with hardware 
layering.  However, some layering strategies are more difficult to reconcile. 
Layering by generality encourages application developers to employ high-level 
data structures in the computational portions of their application codes.  In 
contrast, data structure layering prohibits the application developer from 
incorporating advanced data structures into application codes; instead the
user programs computations using simple arrays.  The latter approach can 
simplify coding
when computations are free from communications.  When communications or other
operations that reflect hardware are required within model computations, coding
model calcuations using more complex data objects can encapsulate some of 
these details and simplify codes.  Overture is an example of a framework 
that provides such complex data objects.

\subsubsection{ESMF Layers}

The ESMF utility infrastructure and superstructure utilize hardware layering, 
and multi-component applications running under ESMF can be viewed as 
being task layered.  The ESMF ``sandwich'' diagram presented in 
Section~\ref{sec:sandwich}, Figure~\ref{fig:sandwich}, is an amalgamation 
of both strategies.  The bottom layer utilities encapsulate 
machine-specific constructs and also includes general tools useful throughout
the framework.  The next layer of data objects representing
fields and grids reflects some hardware details but is portable and increasingly
geared to application constructs.  We consider these two layers, the ``bottom
slice of bread'', the ESMF infrastructure.  The ``filling'' is a set of 
mostly data parallel model components that utilize the underlying 
infrastructure.  The ``top slice of bread'' is the ESMF superstructure, 
which consists of tools for assembling and coupling applications.  The 
superstructure allows component models to execute in either a data or task 
parallel fashion.  It also allows the user to work with constructs that are part
of the application rather than the computing domain.  

The ESMF does not place any restriction on the computational strategy used 
within models.  Both the array-only WRF approach and the pervasive data 
objects of Overture, etc. are compatible with the ESMF.





