% $Id: ESMF_inframethodoverview.tex,v 1.3 2005/02/28 21:58:44 nscollins Exp $

\section{Overview of Distributed Data Methods}

Bundles, Fields, and Arrays all have versions of the following
data communication methods.  In ESMF, data is communicated 
between DEs.  Depending on the underlying communication 
mechanism, this may translate within the framework to a data 
copy, an MPI call, or something else.

There is a common object handle, an {\tt ESMF\_RouteHandle}, which
allows communication patterns to be precomputed during 
initialization and the information stored in that RouteHandle.
By specifying a RouteHandle at execution time, only
the source and destination data pointers must be supplied and the
runtime overhead is minimized.

\subsection{Higher Level Functions}
The following three methods are intended to map closely to 
needs of applications programs.  They represent higher level
communications and are described in more detail in the following
sections.  They are:

\begin{itemize}

\item {\bf Halo}
Halo operations update ghost-cell or halo regions at the boundaries
of a local data decomposition.
\item {\bf Regrid}
Regrid methods transform data from one Grid to another.
\item {\bf Redist}
Redistribution methods move data associated with a single Grid but
with different decompositions.

\end{itemize}

\subsection{Lower Level Functions}
The following methods correspond closely to the lower level
MPI communications primitives.  They are:

\begin{itemize}

\item {\bf Gather}
Reassembling data which is decomposed over a set of DEs into a single
block of data on one DE.
\item {\bf AllGather}
Reassembling data which is decomposed over a set of DEs into multiple
copies of a single block of data, one copy per original DE.
\item {\bf Scatter}
Spreading an undecomposed block of data on one DE over a set of DEs,
decomposing that single block into smaller subsets of data, one
data decomposition per DE.
\item {\bf AlltoAll}
Spreading an undecomposed block of data from multiple DEs onto
each of the other DEs in the set, resulting in a set of multiple decomposed 
data blocks per DE, one from each of the original source DEs.
\item {\bf Broadcast}
Spreading an undecomposed block of data from one DE onto all other
DEs, where the resulting data is still undecomposed and simply
copied to all other DEs.
\item {\bf Reduction}
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to a single DE.
\item {\bf AllReduce}
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to all DEs in the set.

\end{itemize}

\subsection{Common Options}

\input{../Infrastructure/Route/doc/Route_options}

\subsection{Design and Implementation Notes}

\begin{enumerate}

\item

All distributed methods use the same underlying code, provided
in an internal Route class.  There are 3 additional internal
classes which are related: XPacket, CommTable, and RTable.
The implementation is in C++, with interfaces in Fortran 90.

The general communication strategy is that each
DE computes its own route information in parallel, and
each DE has a different set of route table information
which is all relative to itself.

Exchange Packets (XPackets)
describe a region of memory.  They have
an offset, a contiguous run length, a stride per dimension
and a repeat count per dimension.  It therefore can describe an
n-dimensional cube of data to be communicated.
The methods include basic set/get, how to turn
a list of AxisIndex objects into an XPacket, 
compute a local XPacket from one
in global (undecomposed grid) space, and a method to
compute the intersection
of 2 XPackets and produce a 3rd XPacket describing
that region.  An AxisIndex structure captures
the min and max along each axis for a region -- it is an
index space type of object.  These are  
turned into XPackets by a Route method.

The CommTable code encapsulates which other DEs this
DE needs to talk to, and in what order.  There are
methods to create and destroy one, methods for higher
level code to set a DE number as having data to either
send or receive, and query routines that return an answer
to the question 'which DE should I talk to next'.  

The Route Table (RTable) code contains a list of
XPackets to be sent and received from other DEs.
It has create/destroy code, code to add exchange
packets to the list for each DE, and code
to retrieve the XPackets from any list.

Finally, the top level code is in Route.  A Route
object contains a send RTable, a recv RTable,
a CommTable, and the DELayout.   
The Route methods
include create/destroy, setting a send or recv XPacket
for a particular DE,
and some higher level functions specific to each
type of communication, for example RoutePrecomputeHalo
or RoutePrecomputeRedist.  These latter functions
are where the XPackets are actually computed and added to
the Route table.  Each DE computes its own set of intersections,
either source or destination, and fills its own table.
Then RouteRun executes the code which actually traverses
the table and sends the information between DEs.

\end{enumerate}

\newpage





