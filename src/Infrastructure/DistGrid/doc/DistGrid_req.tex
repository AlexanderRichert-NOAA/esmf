% $Id: DistGrid_req.tex,v 1.4 2002/03/18 10:07:54 wsawyer Exp $

This part covers all the requirements for defining, querying and
relating grid distributions or domain decompositions. The PElist and
the global domain are assumed retrievable (from Control and
GriddedComponent respectively). Here we set down requirements that
apply to all grids. The requirements specific to certain grid
types follow in Part~\ref{DG:gridtypes}.

\req{Grid definition}

\sreq{Generation of PE layout}

Given a global domain and a PElist, there will be methods to derive an
appropriate layout of PEs in multiple dimensions.

\sreq{User-specified PE layout}

It will be possible to override the internally generated PE layout above
by direct user specification.

\sreq{1D decomposition}

ESMF permits 1D domain decomposition, i.e. the distribution of a
(possibly multidimensional) array over a 1D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] probably can be treated as a special case of 2D with no
  loss of generality or performance.
\end{reqlist}

\ssreq{Index order}

1D domain decomposition may apply to any of the three spatial
dimensions, on data arrays specified in any index order (XYZ, XZY,
etc).

\begin{reqlist}
\item[Priority]
\item[Source] get detailed list of sources here for different index
  orders: full generality is potentially a lot of work.
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{2D decomposition}

ESMF permits 2D domain decomposition, i.e. the distribution of a
(2- or more dimensional) array over a 2D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] should NOT be treated as a special case of 3D!
\end{reqlist}

\ssreq{Index order}

2D domain decomposition may apply to any two of the three spatial
dimensions, on data arrays specified in any index order (XYZ, XZY,
etc).

\begin{reqlist}
\item[Priority]
\item[Source] get detailed list of sources here for different index
  orders: full generality is potentially a lot of work.
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{3D decomposition}

ESMF permits 3D domain decomposition, i.e. the distribution of a
(3- or more dimensional) array over a 3D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source] Anyone?
\item[Status]
\item[Verification]
\item[Notes] and no 4D!
\end{reqlist}

\sreq{Generation of a computational domain decomposition}

Given a global domain and a PE layout, there will be methods to assign
each point in the domain to one PE for computation. 

\begin{reqlist}
\item[Priority]
\item[Source] Anyone?
\item[Status]
\item[Verification]
\item[Notes] in multi-threaded applications, the PE assignment is done
  only for each ``MPI process''. Additional threaded PEs work on
  partitions within these computational domains.
\end{reqlist}

\sreq{User-specified computational domain decomposition}

It will be possible to override the internally generated computational
domain decomposition above by direct user specification of domain
extents.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]  WS: Is it really necessary to mention this? There will
be different methods to create decompositions, some more automated
(``distributed a 3-D XYZ array over a 2-D PE layout in a block-block
manner'') and others which are more user-specified (``map the global domain
to the following PE and local indices'').

\end{reqlist}

\sreq{Computational domain masks}

It shall be possible to mask domains from the computation: i.e
generate a domain decomposition where one or more computational
domains are assigned to no PE.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] possibly useful in an ocean model when a decomposition
  of the sphere yields entire computational domains containing only
  land points.
\end{reqlist}

\sreq{Generation of grid topology}

Given the data dependencies of the numerics, ESMF will be capable of
computing the connectivities required for data sharing and
synchronization of computational domains across a distributed grid.

WS:  "topology" (BLACS terminology) implies process layout.
Can we use ``communication pattern''?

\sreq{Validity of grid topology}

Given a data dependency specification, ESMF will be capable of
asserting whether or not a given distributed grid topology is
conformant with that pattern.

\sreq{Periodic boundary conditions}

ESMF will treat periodic boundary conditions along any spatial axis as
a particular kind of topological feature. It will be possible to
specify this as input information for grid topology generation.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] it is natural to treat this as a DistGrid feature, rather
  than having separate edge detection code in applications.
\end{reqlist}

\sreq{Data domain generation}

ESMF will have methods to return the data domain information required
for allocation of data arrays.

\sreq{Globally conformant data domain generation}

ESMF will have methods to return the data domain information required
for allocation of data arrays such that the numeric values of the
indices of a data point are independent of the decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] i.e if Madras is point (80,13) in the global grid, it
  will be (80,13) on the data domain of any decomposition. This
  involves setting appropriate lower bounds to the dimensions of an
  array, and thus may be F90-specific... it can also conceivably be
  done in C++ but array lower bounds are not naturally expressed
  there.  WS: Why should this be F90-specific?  
  It requires an efficient mechanism to ask for (80,13) and get 
  back the associated data point.
\end{reqlist}

\req{Grid information retrieval}

\sreq{PElist retrieval}

ESMF methods will be provided to publish and retrieve the PElist
associated with a distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Computational domain retrieval}

ESMF methods will be provided to publish and retrieve the list of
computational domains associated with each PE of a distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]  WS: can each PE get information about 
computational (or data) domains on other PEs, or can it only access 
info about its own domain?
\end{reqlist}

\sreq{Data domain retrieval}

ESMF methods will be provided to publish and retrieve the list of
data domains associated with each PE of a distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Global domain retrieval}

ESMF methods will be provided to publish and retrieve the global
domain of a distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] WS: Is it required that the global domain information 
be replicated on every PE?

\end{reqlist}

\sreq{Grid topology retrieval}

ESMF nethods will be provided to retrieve the network of
connectivities established by the data dependency patterns of the
distributed grid.

\sreq{Which PE is a point on?}

ESMF methods will be provided to query the PE associated with (i.e
``owning'' the computational domain containing) any point in a
distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] WS: which PE is it on and (optionally?) what 
is its local index.  Also: if one is given the PE and the local index, 
it should be possible to get the global index.  Is it a requirement that
these mappings be highly efficient (a challenging programming task)?
\end{reqlist}

\sreq{Cross-component queries}

It shall be possible to retrieve the distributed grid associated with
any component in an application in a form that permits all the query
operations listed above.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\req{Grid relations}

\sreq{Equality of global domains}

It shall be possible to state if two distributed grids share the same
global domain.

\sreq{Equality of domain decomposition}

It shall be possible to state if two distributed grids sharing a
global domain are identically decomposed.

\sreq{Equality of PE assignment}

It shall be possible to state if two distributed grids with identical
domain decompositions assign their computational domains to the
identical sequence of PEs.

\req{Halo update}

\sreq{Unblocked halo update}

ESMF shall provide an unblocked halo update: where the underlying
data transfer may not be complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] maybe we're pre-empting design issues, but I'd want
  issues like wait-for-completion dealt with within DistGrid.
\end{reqlist}

\sreq{Blocked halo update}

ESMF shall provide a blocked halo update: where the underlying
data transfer is complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] doesn't necessarily need separate call, same as unblocked
  + wait-for-completion.
\end{reqlist}

\sreq{Wait for completion}

ESMF shall provide a method to wait for the completion of a previously
issued unblocked halo update.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Bundling}

ESMF shall provide a method to bundle multiple data arrays on the same
distribution for aggregate data transfer.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Validation and invalidation of halo points}

ESMF shall provide methods to declare halo points valid or invalid
(i.e requiring a halo update prior to use).

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] This feature can be used to detect when to perform a halo
  update. This may also be used to reduce the frequency of halo
  updates on high-latency networks, by declaring wide halos and
  performing redundant computations within them. See \cite{ref:b2001}
  for details.  WS:  can this be simplified to halo is invalid
  if at least one point in halo is invalid?  Partial halo updates
  will complicate matters considerably.
\end{reqlist}

\req{Data transpose}

\sreq{Unblocked data transpose}

ESMF shall provide an unblocked data transpose: where the underlying
data transfer may not be complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] maybe we're pre-empting design issues, but I'd want
  issues like wait-for-completion dealt with within DistGrid.
\end{reqlist}

\sreq{Blocked data transpose}

ESMF shall provide a blocked data transpose: where the underlying
data transfer is complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] doesn't necessarily need separate call, same as unblocked
  + wait-for-completion.
\end{reqlist}

\sreq{Wait for completion}

ESMF shall provide a method to wait for the completion of a previously
issued unblocked data transpose.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Bundling}

ESMF shall provide a method to bundle multiple data arrays on the same
distribution for aggregate data transfer.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\req{Gather}

It shall be possible to create a copy on any PE of the entire global
array from a distributed array.

\req{Scatter}

It shall be possible to create a distributed array across a PElist
from a copy on any PE of the entire global array.

\req{Global reduction operations}

\sreq{Integer global sum}

ESMF shall provide methods to compute the global sum of a distributed
integer array.

\sreq{FP and complex global sum}

ESMF shall provide methods to compute the global sum of a distributed
floating-point or complex array.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{FP and complex global sum along one axis}

ESMF shall provide methods to compute the global sum of a 2D-decomposed
floating-point or complex array along either axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] required for computing zonal means.
\end{reqlist}

\ssreq{FP and complex bit-reproducible global sum}

ESMF shall provide methods to compute the global sum of a
2D-decomposed floating-point or complex array where the result is bitwise
identical on different decompositions. 

\begin{reqlist}
\item[Priority]
\item[Source] trace to GR.
\item[Status]
\item[Verification]
\item[Notes] Possibly a compile-time option of normal (optimized)
             global sum.
\end{reqlist}

\sreq{FP and complex global checksum}

ESMF shall provide methods to compute the global checksum of a
distributed floating-point or complex array. 

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] A checksum is different from a sum in that there is no
  data loss when thedata has a dynamic range exceeding the FP or
  complex precision. It is done by casting all FP numbers as integers before
  summing.
\end{reqlist}

%
%  2002.03.18 WS: consolidated with FP to shorten document
%
% \sreq{Complex global sum}

%ESMF shall provide methods to compute the global sum of a distributed
%complex array.

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\ssreq{Complex global sum along one axis}

%ESMF shall provide methods to compute the global sum of a 2D-decomposed
%complex array along either axis of decomposition.

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\ssreq{Complex bit-reproducible global sum}

%ESMF shall provide methods to compute the global sum of a
%2D-decomposed complex array where the result is bitwise identical on
%different decompositions.

%\begin{reqlist}
%\item[Priority]
%\item[Source] trace to GR.
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\sreq{Complex global checksum}

%ESMF shall provide methods to compute the global checksum of a
%distributed complex array. 

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes] A checksum is different from a sum in that there is no
%  data loss when the FP data has a dynamic range exceeding the FP
%  precision. It is done by casting all FP numbers as integers before
%  summing.
%\end{reqlist}

\sreq{Global maximum of integer or FP data}

ESMF shall provide methods to compute the global maximum of a
distributed integer or FP array.

\ssreq{Location of global maximum}

The location of this maximum on the distributed grid is also
retrievable.

\sreq{Global minimum of integer or FP data}

ESMF shall provide methods to compute the global minimum of a
distributed integer or FP array.

\ssreq{Location of global minimum}

The location of this minimum on the distributed grid is also
retrievable.

\req{Grid staggering}

There are many possible ways to specify staggered grids.  Currently
grid staggering are only required for logically rectilinear grids. We
use the notation of \cite{ref:a1966} to specify staggering (e.g. A-,
B-, C- and D-grids) together with a directional qualifier, e.g
\texttt{NE} to specify a forward index offset in \texttt{X} and
\texttt{Y}.

\newcommand{\agrid}{\texttt{AGRID}{}}
\newcommand{\bgrid}{\texttt{BGRID}{}}
\newcommand{\cgrid}{\texttt{CGRID}{}}
\newcommand{\dgrid}{\texttt{DGRID}{}}

\sreq{\agrid}

ESMF will support a \agrid stencil: where the vector
component array locations $u_{ij}$ and $v_{ij}$ are located at the
cell center $(i,j)$.

\sreq{\bgrid}

ESMF will support a \bgrid stencil: where the vector
component array locations $u_{ij}$ and $v_{ij}$ are located at the NE
cell corner $(i+\frac12,j+\frac12)$.

\sreq{\cgrid}

ESMF will support a \cgrid stencil: where the vector
component array locations $u_{ij}$ and $v_{ij}$ are located on the N
and E faces $(i+\frac12,j)$ and $(i,j+\frac12)$ respectively.

\sreq{\dgrid}

ESMF will support a \dgrid stencil: where the vector
component array locations $u_{ij}$ and $v_{ij}$ are located on the E
and N faces $(i,j+\frac12)$ and $(i+\frac12,j)$ respectively.

\part{Requirements for specific grid types} \label{DG:gridtypes}

The distributed grid module will provide support the following 
physical grids:

WS: should these be mentioned explicitly and in such detail here?

\req{Logically rectilinear grids}

\req{Tripolar grid}

The tripolar grid \cite{ref:m1996} is used to address the pole problem
in ocean models, by creating a grid with two poles in the Northern
Hemisphere, both over land. This creates a grid topology with a
fold. Vector components experience sign reversal on crossing a fold;
also some points on the vector stencil may be redundant.

(figure)

\sreq{Vector component reversal}

\sreq{Redundancy enforcement}

Certain locations on a staggered grid have multiple index locations
for a single physical location. While these points are redundant, the
data there may diverge because of FP roundoff error. ESMF will provide
methods to enforce exact redundancy.

\sreq{Validity of stencil}

It must be possible to check if the stencil and fold are conformant:
for instance, a southern fold with a \bgrid stencil is
invalid.

\req{Cubed-sphere grid}

The cubed-sphere grid \cite{ref:rpm1996} is used to address the pole
problem in ocean models, by creating a grid with eight weak poles,
which may also be moved over land if one chooses. This creates a grid
topology where vector components may need to be interchanged
($(u,v)\longrightarrow(v,-u)$) on crossing a cube edge. Some points on
the vecor stencil may be redundant.

\sreq{Vector component interchange}

ESMF will correctly treat vector components crossing faces of a cubed
sphere to perform the appropriate component interchanges.

\sreq{Redundancy enforcement}

Certain locations on a staggered grid have multiple index locations
for a single physical location. While these points are redundant, the
data there may diverge because of FP roundoff error. ESMF will provide
methods to enforce exact redundancy.

\req{Spectral grid}

\req{Exchange grid}

\req{Icosahedral grid}

See \cite{art:heikes+:geodesic,art:majewski+:gme} for extensive
discussions on these grids.

\req{Reduced grids}

\req{Nested grids}

\req{Unstructured grids and ungridded data}

WS: Arlindo and Jing Guo have explained the PSAS
observations are ``ungridded data.'' Their reasons are (i) there are
(initially) no data dependencies between the observations, and (2) an
"observation" location can have numerous data points.  From the
literature, it seems common in the remote sensing community to refer
to such data as ``ungridded.''  An observation vector is a derived
type, and communicating parts of it may not be as straightforward as for
gridded data.  This can be circumvented by copying data to 1-D arrays
when communication is required.  Keep in mind that an ESMF-compliant
PSAS is not in the list of milestones, so ``ungridded data'' might not
even be a requirement.  As for unstructured grids, it would be
worthwhile to support these in a general way which requires
considerable user specification of the mapping of global indices to
their PE, local index equivalents.


