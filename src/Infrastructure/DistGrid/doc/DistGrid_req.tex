% $Id: DistGrid_req.tex,v 1.9 2002/04/22 17:37:08 vbalaji Exp $

This part covers all the requirements for defining, querying and
relating grid distributions or domain decompositions. The PElist and
the global domain are assumed retrievable (from \textbf{Control} and
\textbf{GriddedComponent} respectively). Here we set down requirements
that apply to all grids. The requirements specific to certain grid
types follow in Part~\ref{DG:gridtypes}.

\req{Grid definition}

\sreq{Generation of PE layout}

Given a global domain and a PElist, there will be methods to derive an
appropriate layout of PEs in multiple dimensions.

\sreq{User-specified PE layout}

It will be possible to override the internally generated PE layout above
by direct user specification.

\sreq{1D decomposition}

ESMF permits 1D domain decomposition, i.e. the distribution of a
(possibly multidimensional) array over a 1D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] probably can be treated as a special case of 2D with no
  loss of generality or performance.
\end{reqlist}

\ssreq{Index order}

1D domain decomposition may apply to any of the three spatial
dimensions, on data arrays specified in any index order (XYZ, XZY,
etc).

\begin{reqlist}
\item[Priority]
\item[Source] get detailed list of sources here for different index
  orders: full generality is potentially a lot of work.
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{2D decomposition}

ESMF permits 2D domain decomposition, i.e. the distribution of a
(2- or more dimensional) array over a 2D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] should NOT be treated as a special case of 3D!
\end{reqlist}

\ssreq{Index order}

2D domain decomposition may apply to any two of the three spatial
dimensions, on data arrays specified in any index order (XYZ, XZY,
etc).

\begin{reqlist}
\item[Priority]
\item[Source] get detailed list of sources here for different index
  orders: full generality is potentially a lot of work.
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{1D distributed arrays associated with a 2D decompsition}

Within a 2D decomposition, it must be possible for arrays to be
distributed along a single axis of distribution.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] i.e given a 2D decompsition in \texttt{(i,j)}, it must be
  possible to have arrays that are functions of \texttt{(i,j)},
  \texttt{(i,j,k)}, etc but also \emph{(j,k)}.
\end{reqlist}

\sreq{3D decomposition}

ESMF permits 3D domain decomposition, i.e. the distribution of a
(3- or more dimensional) array over a 3D PE layout.

\begin{reqlist}
\item[Priority]
\item[Source] Anyone?
\item[Status]
\item[Verification]
\item[Notes] and no 4D!
\end{reqlist}

\sreq{Generation of a computational domain decomposition}

Given a global domain and a PE layout, there will be methods to assign
each point in the domain to one PE for computation. 

\begin{reqlist}
\item[Priority]
\item[Source] Requirements for specific flags to control the
  decomposition must be added here.
\item[Status]
\item[Verification]
\item[Notes] in multi-threaded applications, the PE assignment is done
  only for each ``MPI process''. Additional threaded PEs work on
  partitions within these computational domains.
  
  The partitions do not necessarily have a PE associated with it. The
  partitions may define a task queue from which PEs assigned to
  threads pop tasks. The pool of PEs available for threading is drawn
  from the associated PElist, of which not all are part of the PE
  layout.
  
  Threads can be mapped on to an anode, which can consist of multiple
  PEs.  The main thing I'm trying to arrive at is that the
  partitioning into threads is independent of assignment to PEs.
  Principally, one must be able to define an arbitrary number of
  partitions organized into a queue, off which shared-memory execution
  threads can pop tasks as resources get freed.
\end{reqlist}

\sreq{User-specified computational domain decomposition}

It will be possible to override the internally generated computational
domain decomposition above by direct user specification of domain
extents.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]  WS: Is it really necessary to mention this? There will
be different methods to create decompositions, some more automated
(``distributed a 3-D XYZ array over a 2-D PE layout in a block-block
manner'') and others which are more user-specified (``map the global domain
to the following PE and local indices'').

\end{reqlist}

\sreq{Computational domain masks} \label{DG:masklayout}

It shall be possible to mask domains from the computation: i.e
generate a domain decomposition where one or more computational
domains are assigned to no PE.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] possibly useful in an ocean model when a decomposition
  of the sphere yields entire computational domains containing only
  land points.

  Not the same mask as in Req.~\ref{DG:masksum}.
\end{reqlist}

\sreq{Generation of grid topology}

Given the data dependencies of the numerics, ESMF will be capable of
computing the connectivities required for data sharing and
synchronization of computational domains across a distributed grid.


\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] WS:  "topology" (BLACS terminology) implies process layout.
Can we use ``communication pattern''?

VB: I still prefer grid topology. This only sets up connectivities:
there may be no actual communication.

\end{reqlist}

\sreq{Validity of grid topology}

Given a data dependency specification, ESMF will be capable of
asserting whether or not a given distributed grid topology is
conformant with that pattern.

\sreq{Periodic boundary conditions}

ESMF will treat periodic boundary conditions along any spatial axis as
a particular kind of topological feature. It will be possible to
specify this as input information for grid topology generation.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] it is natural to treat this as a \textbf{DistGrid}
  feature, rather than having separate edge detection code in
  applications. There is more than one way to treat LBCs in a
  \textbf{DistGrid}: these will be spelt out anon.
\end{reqlist}

\req{Grid information retrieval}

\sreq{Computational domain retrieval}

\ssreq{Domain extents}

It shall be possible to retrieve the size of a computational domain
along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Domain begin and end indices}

It shall be possible to retrieve the beginning and ending indices of a
computational domain along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Maximum domain extent}

It shall be possible to retrieve the maximum size along each axis of
decomposition of all the computational domains in the \textbf{DistGrid}. 

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Computational domain list}

ESMF methods will be provided to retrieve the list of computational
domains associated with each PE of a  \textbf{DistGrid}.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Besides being able to retrieve one's own domain
  information, the full list of domains is also required for certain
  operations.
\end{reqlist}

\sreq{Data domain retrieval}

\ssreq{Domain extents}

It shall be possible to retrieve the size of a data domain
along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Domain begin and end indices}

It shall be possible to retrieve the beginning and ending indices of a
data domain along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Maximum domain extent}

It shall be possible to retrieve the maximum size along each axis of
decomposition of all the data domains in the \textbf{DistGrid}. 

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Index translation for globally non-conformant data domains}

Where the local array allocation is not globally-conformant, 
ESMF will have methods to translate the local indices to
globally-conformant indices.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] It is possible (using array lower bound specifications)
  to generate a \emph{globally conformant} array allocation: such that
  if Madras is point (80,13) in the global grid, it will be (80,13) on
  the data domain of any decomposition. Where this is not done, there
  must be methods to translate local indices to globally conformant
  indices.
\end{reqlist}

\ssreq{Data domain list}

ESMF methods will be provided to retrieve the list of data
domains associated with each PE of a  \textbf{DistGrid}.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Besides being able to retrieve one's own domain
  information, the full list of domains is also required for certain
  operations.
\end{reqlist}

\sreq{Global domain retrieval}

\ssreq{Domain extents}

It shall be possible to retrieve the size of a global domain
along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{Domain begin and end indices}

It shall be possible to retrieve the beginning and ending indices of the
domain domain along each axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{PE layout retrieval}

ESMF methods will be provided to publish and retrieve the PE layout
associated with a distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Grid topology retrieval}

ESMF nethods will be provided to retrieve the network of
connectivities established by the data dependency patterns of the
distributed grid.

\sreq{Which PE is a point on?}

ESMF methods will be provided to query the PE associated with (i.e
``owning'' the computational domain containing) any point in a
distributed grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] WS: which PE is it on and (optionally?) what 
is its local index.  Also: if one is given the PE and the local index, 
it should be possible to get the global index.  Is it a requirement that
these mappings be highly efficient (a challenging programming task)?
\end{reqlist}

\sreq{Cross-component queries}

It shall be possible to retrieve the \textbf{DistGrid} associated with
any component in an application in a form that permits all the query
operations listed above.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\req{Grid relations}

\sreq{Equality of global domains}

It shall be possible to state if two distributed grids share the same
global domain.

\sreq{Equality of domain decomposition}

It shall be possible to state if two distributed grids sharing a
global domain are identically decomposed.

\sreq{Equality of PE assignment}

It shall be possible to state if two distributed grids with identical
domain decompositions assign their computational domains to the
identical sequence of PEs.

\req{Halo update} \label{DG:halo}

\sreq{Unblocked halo update}

ESMF shall provide an unblocked halo update: where the underlying
data transfer may not be complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] maybe we're pre-empting design issues, but I'd want
  issues like wait-for-completion dealt with within \textbf{DistGrid}.
\end{reqlist}

\sreq{Blocked halo update}

ESMF shall provide a blocked halo update: where the underlying
data transfer is complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] doesn't necessarily need separate call, same as unblocked
  + wait-for-completion.
\end{reqlist}

\sreq{Wait for completion}

ESMF shall provide a method to wait for the completion of a previously
issued unblocked halo update.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Validation and invalidation of halo points}

ESMF shall provide methods to declare halo points valid or invalid
(i.e requiring a halo update prior to use).

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] This feature can be used to detect when to perform a halo
  update. This may also be used to reduce the frequency of halo
  updates on high-latency networks, by declaring wide halos and
  performing redundant computations within them. See \cite{ref:b2001}
  for details.  WS:  can this be simplified to halo is invalid
  if at least one point in halo is invalid?  Partial halo updates
  will complicate matters considerably.

  VB: partial updates are useful. This may not necessarily support
  arbitrary lists of halo points, but the following are useful:
  \begin{itemize}
  \item ``Update N and E halos only, including the NE corner.''
  \item ``Update only 1 row/column in each direction even if the halo
    width is 2''.
  \item `Update only the outer row/column of a 2-width halo.''
  \end{itemize}
\end{reqlist}

\sreq{Arrays of derived type}

All relevant operations in this Section~\ref{DG:halo} must apply to
data arrays where each array element is a derived data type.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] I hope this isn't required, but see
  Section~\ref{DG:Unstructured} below.
\end{reqlist}

\req{Data transpose} \label{DG:transpose}

\sreq{Unblocked data transpose}

ESMF shall provide an unblocked data transpose: where the underlying
data transfer may not be complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] maybe we're pre-empting design issues, but I'd want
  issues like wait-for-completion dealt with within \textbf{DistGrid}.
\end{reqlist}

\sreq{Blocked data transpose}

ESMF shall provide a blocked data transpose: where the underlying
data transfer is complete when the call returns.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] doesn't necessarily need separate call, same as unblocked
  + wait-for-completion.
\end{reqlist}

\sreq{Wait for completion}

ESMF shall provide a method to wait for the completion of a previously
issued unblocked data transpose.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Arrays of derived type}

All relevant operations in this Section~\ref{DG:transpose} must apply to
data arrays where each array element is a derived data type.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] I hope this isn't required, but see
  Section~\ref{DG:Unstructured} below.
\end{reqlist}

\req{Gather}

It shall be possible to create a copy on any PE of the entire global
array from a distributed array.

\sreq{Allgather}

It shall be possible to create a copy on all PEs of the associated
PElist of the entire global array from a distributed array.

\sreq{Partial gather} \label{DG:PartGather}

In a 2D decomposition, it shall be possible to perform a gather along
either axis.

\req{Scatter}

It shall be possible to create a distributed array across a PElist
from a copy on any PE of the entire global array.

\sreq{Partial scatter}

In a 2D decomposition, it shall be possible to perform a scatter along
either axis.

\req{Bundling}

ESMF shall provide a method to bundle multiple data arrays on the same
distribution for aggregate data transfer.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Note that all arrays in a bundle must share the same
  distribution, that's the only case where aggregate data transfer
  methods may be simple and efficient.
  
  Bundling methods with similar requirements may appear in other
  documents (e.g \textbf{Fields}, \textbf{Regrid}, \textbf{PhysGrid}),
  but the methods there will likely cascade to here, as the main
  utility of bundles lies in aggregate data transfer methods on
  distributed grids. The other documents should derive an equivalent
  list of methods listing the ones here as source.
\end{reqlist}

\sreq{Initiate a bundle}

It must be possible to initiate any number of instances of a bundle on
a distributed grid.

\sreq{Add an array}

It must be possible to add any array on a conformant \textbf{DistGrid}
to a bundle.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Mix-and-match data types allowed? Could be tricky... if
  array elements have differing bytelengths.
\end{reqlist}

\sreq{Delete an array}

It must be possible to delete any array from a bundle.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Merge bundles}

It must be possible to merge bundles sharing a \textbf{DistGrid}.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Two bundles on different \textbf{DistGrid}s may end up on the same
  one after a data transpose.
\end{reqlist}

\req{Global reduction operations}

\sreq{Integer global sum}

ESMF shall provide methods to compute the global sum of a distributed
integer array.

\sreq{FP and complex global sum}

ESMF shall provide methods to compute the global sum of a distributed
floating-point or complex array.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\ssreq{FP and complex global sum under a mask} \label{DG:masksum}

ESMF shall provide methods to compute the global sum of a 2D-decomposed
floating-point or complex array under control of a mask. The mask
omits an arbitrary list of array locations from the sum.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Not the same mask as in Req.~\ref{DG:masklayout}.
\end{reqlist}

\ssreq{FP and complex global sum along one axis}

ESMF shall provide methods to compute the global sum of a 2D-decomposed
floating-point or complex array along either axis of decomposition.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] required for computing zonal means.
\end{reqlist}

\ssreq{FP and complex bit-reproducible global sum}

ESMF shall provide methods to compute the global sum of a
2D-decomposed floating-point or complex array where the result is
bitwise identical on different decompositions.

\begin{reqlist}
\item[Priority]
\item[Source] trace to GR.
\item[Status]
\item[Verification]
\item[Notes] Possibly a compile-time option of normal (optimized)
             global sum.
\end{reqlist}

\sreq{FP and complex global checksum}

ESMF shall provide methods to compute the global checksum of a
distributed floating-point or complex array. 

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] A checksum is different from a sum in that there is no
  data loss when the data has a dynamic range exceeding the FP or
  complex precision. It is done by casting all FP numbers as integers
  before summing.
\end{reqlist}

%
%  2002.03.18 WS: consolidated with FP to shorten document
%
% \sreq{Complex global sum}

%ESMF shall provide methods to compute the global sum of a distributed
%complex array.

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\ssreq{Complex global sum along one axis}

%ESMF shall provide methods to compute the global sum of a 2D-decomposed
%complex array along either axis of decomposition.

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\ssreq{Complex bit-reproducible global sum}

%ESMF shall provide methods to compute the global sum of a
%2D-decomposed complex array where the result is bitwise identical on
%different decompositions.

%\begin{reqlist}
%\item[Priority]
%\item[Source] trace to GR.
%\item[Status]
%\item[Verification]
%\item[Notes]
%\end{reqlist}

%\sreq{Complex global checksum}

%ESMF shall provide methods to compute the global checksum of a
%distributed complex array. 

%\begin{reqlist}
%\item[Priority]
%\item[Source]
%\item[Status]
%\item[Verification]
%\item[Notes] A checksum is different from a sum in that there is no
%  data loss when the FP data has a dynamic range exceeding the FP
%  precision. It is done by casting all FP numbers as integers before
%  summing.
%\end{reqlist}

\sreq{Global maximum of integer or FP data}

ESMF shall provide methods to compute the global maximum of a
distributed integer or FP array.

\ssreq{Location of global maximum}

The location of this maximum on the distributed grid is also
retrievable.

\sreq{Global minimum of integer or FP data}

ESMF shall provide methods to compute the global minimum of a
distributed integer or FP array.

\ssreq{Location of global minimum}

The location of this minimum on the distributed grid is also
retrievable.

\req{Grid staggering}

There are many possible ways to specify staggered grids.  Currently
grid staggering is only required for logically rectilinear grids. We
use the notation of \cite{ref:a1966} to specify staggering (e.g. A-,
B-, C- and D-grids) together with a directional qualifier, e.g
\texttt{NE} to specify a forward index offset in \texttt{X} and
\texttt{Y}.

\newcommand{\agrid}{\texttt{AGRID~}}
\newcommand{\bgrid}{\texttt{BGRID~}}
\newcommand{\cgrid}{\texttt{CGRID~}}
\newcommand{\dgrid}{\texttt{DGRID~}}

\sreq{\agrid}

ESMF will support a \agrid stencil: where the vector
component array locations $u_{ij}$ and $v_{ij}$ are located at the
cell center $(i,j)$.

\sreq{\bgrid}

ESMF will support a \bgrid stencil: where the vector component array
locations $u_{ij}$ and $v_{ij}$ are located at the NE cell corner
$(i+\frac12,j+\frac12)$. Both NE and SW flavors are supported.

\sreq{\cgrid}

ESMF will support a \cgrid stencil: where the vector component array
locations $u_{ij}$ and $v_{ij}$ are located on the N and E faces
$(i+\frac12,j)$ and $(i,j+\frac12)$ respectively. Both NE and SW
flavors are supported.

\sreq{\dgrid}

ESMF will support a \dgrid stencil: where the vector component array
locations $u_{ij}$ and $v_{ij}$ are located on the E and N faces
$(i,j+\frac12)$ and $(i+\frac12,j)$ respectively. Both NE and SW
flavors are supported.

\part{Requirements for specific grid types} \label{DG:gridtypes}

The distributed grid module will provide support the following 
physical grids:

WS: should these be mentioned explicitly and in such detail here?

\req{Logically rectilinear grids}

\req{Tripolar grid}

The tripolar grid \cite{ref:m1996} is used to address the pole problem
in ocean models, by creating a grid with two poles in the Northern
Hemisphere, both over land. This creates a grid topology with a
fold. Vector components experience sign reversal on crossing a fold;
also some points on the vector stencil may be redundant.

(figure)

\sreq{Vector component reversal}

\sreq{Redundancy enforcement}

Certain locations on a staggered grid have multiple index locations
for a single physical location. While these points are redundant, the
data there may diverge because of FP roundoff error. ESMF will provide
methods to enforce exact redundancy.

\sreq{Validity of grid}

It must be possible to check if the grid and fold are conformant:
for instance, a southern fold with a \bgrid~ stencil needs an extra
vector row at the southern edge.

\req{Cubed-sphere grid}

The cubed-sphere grid \cite{ref:rpm1996} is used to address the pole
problem in ocean models, by creating a grid with eight weak poles,
which may also be moved over land if one chooses. This creates a grid
topology where vector components may need to be interchanged
($(u,v)\longrightarrow(v,-u)$) on crossing a cube edge. Some points on
the vecor stencil may be redundant.

\sreq{Vector component interchange}

ESMF will correctly treat vector components crossing faces of a cubed
sphere to perform the appropriate component interchanges.

\sreq{Redundancy enforcement}

Certain locations on a staggered grid have multiple index locations
for a single physical location. While these points are redundant, the
data there may diverge because of FP roundoff error. ESMF will provide
methods to enforce exact redundancy.

\req{Spectral grid}

Spectral models generally have two associated grids, one in physical
space, and one in spectral (wavenumber) space. The sequence of
transformations to pass data between the two grids is treated at its
highest level within the Regrid semantics. Within these, there is
generally a specific step to redistribute data to optimize specific
operations (FFTS and LTs). This section will highlight the specific
requirements of these redistributions.

\sreq{Globalize on one axis}

There will be an efficient method to create an array where all the
global data is available along one of the axes of distribution.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Already covered by Req.~\ref{DG:PartGather}, but
  highlighted here.
\end{reqlist}

\sreq{Transpose axis of globalization}

There will be an efficient method to transpose an array global along
one axis, into one global along another. Note that this is a matrix
transpose, as opposed to the general redistribution that we've called
a data transpose in~\ref{DG:transpose}.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] Already covered by Req.~\ref{DG:PartGather}, but
  highlighted here.
\end{reqlist}

\req{Exchange grid}

\req{Icosahedral grid}

See \cite{art:heikes+:geodesic,art:majewski+:gme} for extensive
discussions on these grids.

\req{Reduced grids}

\req{Nested grids}

Nested grids are overlapping grids with certain properties that may be
possible to exploit for efficiency. Many of the requirements having to
do with data exchange between nested grids will appear in the PhysGrid
and Regrid documents. Some requirements of nested grids appear here:
these concern the special case of \emph{mesh-aligned} nested
grids. Nesting is defined to be mesh-aligned when every coarse grid
point in the region of coverage of a fine nest is also a point on the
fine grid. The following requirements apply to mesh-aligned nested
grids:

\sreq{Discrete data shift on moving nests}

A method will be provided for data shifting by integral grid intervals
along axes of decomposition on a distributed moving mesh-aligned
nested grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] i.e, a moving mesh-aligned nested grid may support a
  lateral data shift: ``move all points on this distributed grid 2
  points south and 1 east''.
\end{reqlist}

\req{Unstructured grids and ungridded data} \label{DG:Unstructured}.

Unstructured grids and ungridded location streams will come associated
with an underlying background grid (see~\ref{DG:terms}). Requirements
in this section use the background grid to define operations on
unstructured grids and ungridded location streams. For the purpose of
\emph{DistGrid}, unstructured grids and ungridded location streams are
aligned on a single axis, each index of which is associated with a
background grid cell.

\sreq{Background grid retrieval}

It shall be possible to retrieve a structured background grid
associated with unstructured grids and ungridded location streams.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes] The method to generate the background grid requires
  location information, and belongs to \textbf{PhysGrid}.
\end{reqlist}

\sreq{Domain decomposition}

It shall be possible to apply domain decomposition to unstructured
grids and ungridded location streams, using the background grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Halos and halo updates}

It shall be possible to apply halos and halo update operations as
defined in~\ref{DG:halo} to unstructured grids and ungridded location
streams, using the background grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}

\sreq{Data transpose}

It shall be possible to apply data transposes as defined
in~\ref{DG:transpose} to unstructured grids and ungridded location
streams, using the background grid.

\begin{reqlist}
\item[Priority]
\item[Source]
\item[Status]
\item[Verification]
\item[Notes]
\end{reqlist}


