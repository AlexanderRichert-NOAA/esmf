// $Id: ESMC_Clock.C,v 1.45 2004/01/31 03:08:30 eschwab Exp $
//
// Earth System Modeling Framework
// Copyright 2002-2003, University Corporation for Atmospheric Research, 
// Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
// Laboratory, University of Michigan, National Centers for Environmental 
// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
// NASA Goddard Space Flight Center.
// Licensed under the GPL.

// ESMC Clock method code (body) file

//-------------------------------------------------------------------------
//
// !DESCRIPTION:
//
// The code in this file implements the C++ {\tt ESMC\_Clock} methods declared
// in the companion file {\tt ESMC\_Clock.h}
//
//-------------------------------------------------------------------------
//
 // higher level, 3rd party or system includes here
 #include <iostream.h>
 #include <string.h>
 #include <ctype.h>
 #include <ESMC_Alarm.h>

 // associated class definition file
 #include <ESMC_Clock.h>

//-------------------------------------------------------------------------
 // leave the following line as-is; it will insert the cvs ident string
 // into the object file for tracking purposes.
 static const char *const version = "$Id: ESMC_Clock.C,v 1.45 2004/01/31 03:08:30 eschwab Exp $";
//-------------------------------------------------------------------------

// initialize static clock instance counter
// TODO: inherit from ESMC_Base class
int ESMC_Clock::count=0;

//
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//
// This section includes all the Clock routines
//
//

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockCreate - Allocates and Initializes a Clock object
//
// !INTERFACE:
      ESMC_Clock *ESMC_ClockCreate(
//
// !RETURN VALUE:
//     pointer to newly allocated ESMC_Clock
//
// !ARGUMENTS:
      int                nameLen,          // in
      const char        *name,             // in
      ESMC_TimeInterval *timeStep,         // in
      ESMC_Time         *startTime,        // in
      ESMC_Time         *stopTime,         // in
      ESMC_TimeInterval *runDuration,      // in
      int               *runTimeStepCount, // in
      ESMC_Time         *refTime,          // in
      int               *rc) {             // out - return code

// !DESCRIPTION:
//      Allocates and Initializes a {\tt ESMC\_Clock} with given values
//
//EOP
// !REQUIREMENTS:  

    int returnCode;
    ESMC_Clock *clock;

    try {
      clock = new ESMC_Clock;
    }
    catch (...) {
      // TODO:  call ESMF log/err handler
      cerr << "ESMC_ClockCreate() memory allocation failed\n";
      if (rc != ESMC_NULL_POINTER) {
        *rc = ESMF_FAILURE;
      }
      return(ESMC_NULL_POINTER);
    }

    // TODO: use inherited methods from ESMC_Base or share with ESMC_Alarm
    if (name != ESMC_NULL_POINTER) {
      if (nameLen < ESMF_MAXSTR) {
        strncpy(clock->name, name, nameLen);
        clock->name[nameLen] = '\0';  // null terminate
      } else {
        // TODO: error, delete and return null clock?
        if (rc != ESMC_NULL_POINTER) {
          *rc = ESMF_FAILURE;
        }
        return(clock);
      }
    } else {
      // create default name "ClockNNN"
      sprintf(clock->name, "Clock%3.3d\0", clock->id);
    }

    if (timeStep  != ESMC_NULL_POINTER) clock->timeStep  = *timeStep;
    if (startTime != ESMC_NULL_POINTER) clock->startTime = *startTime;
    if (stopTime  != ESMC_NULL_POINTER) clock->stopTime  = *stopTime;

    if (runDuration != ESMC_NULL_POINTER) {
      clock->stopTime = clock->startTime + *runDuration;
    }
    if (runTimeStepCount != ESMC_NULL_POINTER) {
      clock->stopTime = clock->startTime + (*runTimeStepCount * *timeStep);
    }

    if (refTime   != ESMC_NULL_POINTER) clock->refTime   = *refTime;
    else clock->refTime = clock->startTime;

    clock->currTime = clock->startTime;
    clock->prevTime = clock->currTime;

    returnCode = clock->ESMC_ClockValidate();
    if (rc != ESMC_NULL_POINTER) {
      *rc = returnCode;
    }

    return(clock);

 } // end ESMC_ClockCreate

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockCreateCopy - Creates a copy of a clock
//
// !INTERFACE:
      ESMC_Clock *ESMC_ClockCreateCopy(
//
// !RETURN VALUE:
//     pointer to newly allocated ESMC_Clock
//
// !ARGUMENTS:
      ESMC_Clock *clock,  // in  - clock to copy
      int        *rc) {   // out - return code

// !DESCRIPTION:
//      Creates a new copy of the given clock.
//
//EOP
// !REQUIREMENTS:  

    int returnCode;
    ESMC_Clock *clockCopy;

    try {
      // allocate new clock and pass given clock to copy constructor.
      clockCopy = new ESMC_Clock(*clock);
    }
    catch (...) {
      // TODO:  call ESMF log/err handler
      cerr << "ESMC_ClockCreateCopy() memory allocation failed\n";
      if (rc != ESMC_NULL_POINTER) {
        *rc = ESMF_FAILURE;
      }
      return(ESMC_NULL_POINTER);
    }

    returnCode = clockCopy->ESMC_ClockValidate();
    if (rc != ESMC_NULL_POINTER) {
      *rc = returnCode;
    }

    return(clockCopy);

 } // end ESMC_ClockCreateCopy

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockDestroy - free a Clock created with Create
//
// !INTERFACE:
      int ESMC_ClockDestroy(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_Clock *clock) {  // in - ESMC_Clock to destroy
//
// !DESCRIPTION:
//      ESMF routine which destroys a Clock object previously allocated
//      via an {\tt ESMC\_ClockCreate} routine.  Define for deep classes only.
//
//EOP

  if (clock != ESMC_NULL_POINTER) {
    //clock->ESMC_ClockDestruct(); constructor calls it!
    delete clock;
    clock = ESMC_NULL_POINTER;
    return(ESMF_SUCCESS);
  } else {
    return(ESMF_FAILURE);
  }

 } // end ESMC_ClockDestroy

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockSet - Sets a Clock object's properties
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockSet(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int                nameLen,          // in
      const char        *name,             // in
      ESMC_TimeInterval *timeStep,         // in
      ESMC_Time         *startTime,        // in
      ESMC_Time         *stopTime,         // in
      ESMC_TimeInterval *runDuration,      // in
      int               *runTimeStepCount, // in
      ESMC_Time         *refTime,          // in
      ESMC_Time         *currTime,         // in
      ESMF_KIND_I8      *advanceCount) {   // in

// !DESCRIPTION:
//      Sets a {\tt ESMC\_Clock}'s properties
//
//EOP
// !REQUIREMENTS:  

    // save current values to restore in case of failure;
    ESMC_Clock saveClock = *this;

    // TODO: use inherited methods from ESMC_Base or share with ESMC_Alarm
    if (name != ESMC_NULL_POINTER) {
      if (nameLen < ESMF_MAXSTR) {
        strncpy(this->name, name, nameLen); 
        this->name[nameLen] = '\0';  // null terminate
      } else {
        // error, restore previous state and return ESMF_FAILURE
        *this = saveClock; 
        return(ESMF_FAILURE);
      }
    }

    if (timeStep  != ESMC_NULL_POINTER) this->timeStep  = *timeStep;
    if (startTime != ESMC_NULL_POINTER) this->startTime = *startTime;
    if (stopTime  != ESMC_NULL_POINTER) this->stopTime  = *stopTime;

    if (runDuration != ESMC_NULL_POINTER) {
      this->stopTime = this->startTime + *runDuration;
    }
    if (runTimeStepCount != ESMC_NULL_POINTER) {
      this->stopTime = this->startTime + (*runTimeStepCount * *timeStep);
    }

    if (refTime   != ESMC_NULL_POINTER) this->refTime   = *refTime;

    if (currTime  != ESMC_NULL_POINTER) {
      this->prevTime = this->currTime;
      this->currTime = *currTime;
    }

    if (advanceCount != ESMC_NULL_POINTER) this->advanceCount = *advanceCount;

    if (ESMC_ClockValidate() == ESMF_SUCCESS) return(ESMF_SUCCESS);
    else {
      // restore original clock values
      *this = saveClock;
      return(ESMF_FAILURE);
    }

 } // end ESMC_ClockSet

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGet - gets a Clock object's properties
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGet(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int                nameLen,          // in
      int               *tempNameLen,      // out
      char              *tempName,         // out
      ESMC_TimeInterval *timeStep,         // out
      ESMC_Time         *startTime,        // out
      ESMC_Time         *stopTime,         // out
      ESMC_TimeInterval *runDuration,      // out
      ESMF_KIND_R8      *runTimeStepCount, // out
      ESMC_Time         *refTime,          // out
      ESMC_Time         *currTime,         // out
      ESMC_Time         *prevTime,         // out
      ESMC_TimeInterval *currSimTime,      // out
      ESMC_TimeInterval *prevSimTime,      // out
      ESMF_KIND_I8      *advanceCount,     // out
      int               *alarmCount) {     // out

// !DESCRIPTION:
//      Gets a {\tt ESMC\_Clock}'s property values
//
//EOP
// !REQUIREMENTS:  

    int rc = ESMF_SUCCESS;

    // TODO: use inherited methods from ESMC_Base or share with ESMC_Alarm
    if (nameLen > 0) {
      if (strlen(this->name) < nameLen) {
        // copy all of it
        strcpy(tempName, this->name);
      } else {
        // TODO: copy what will fit and return ESMF_FAILURE ?
        strncpy(tempName, this->name, nameLen-1);
        tempName[nameLen] = '\0';  // null terminate
        rc = ESMF_FAILURE;
      }
      // report how many characters were copied
      *tempNameLen = strlen(tempName);
    }

    if (timeStep  != ESMC_NULL_POINTER) *timeStep  = this->timeStep;
    if (startTime != ESMC_NULL_POINTER) *startTime = this->startTime;
    if (stopTime  != ESMC_NULL_POINTER) *stopTime  = this->stopTime;

    if (runDuration != ESMC_NULL_POINTER) {
      *runDuration = this->stopTime - this->startTime;
    }
    if (runTimeStepCount != ESMC_NULL_POINTER) {
      *runTimeStepCount = (this->stopTime - this->startTime) / this->timeStep;
    }

    if (refTime   != ESMC_NULL_POINTER) *refTime   = this->refTime;
    if (currTime  != ESMC_NULL_POINTER) *currTime  = this->currTime;
    if (prevTime  != ESMC_NULL_POINTER) *prevTime  = this->prevTime;

    // Get the clock's current simulation time
    if (currSimTime != ESMC_NULL_POINTER) {
      *currSimTime = (this->currTime - this->refTime);
    }
    // Get the clock's previous simulation time
    if (prevSimTime != ESMC_NULL_POINTER) {
      *prevSimTime = (this->prevTime - this->refTime);
    }

    if (advanceCount != ESMC_NULL_POINTER) *advanceCount = this->advanceCount;
    if (alarmCount   != ESMC_NULL_POINTER) *alarmCount   = this->alarmCount;

    return(rc);

 } // end ESMC_ClockGet

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockAdvance - increment a clock's time
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockAdvance(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_TimeInterval *timeStep,               // in  - optional new timestep
      char              *ringingAlarmList1stElementPtr, // out - optional array
                                                 //        of ringing alarms
      char              *ringingAlarmList2ndElementPtr, // in - address of 2nd
                                                 //        element to calculate
                                                 //        F90 array element
                                                 //        size
      int               *sizeofRingingAlarmList, // in  - size of given array
                                                 //       of ringing alarms
      int               *ringingAlarmCount) {    // out - number of ringing
                                                 //       alarms
//
// !DESCRIPTION:
//     Advances a clock's current time by timestep, then checks
//     each of its alarms to see if its time to ring.
//
//EOP
// !REQUIREMENTS:  TMG 3.4.1

    int rc = ESMF_SUCCESS;

    // save current time, then advance it
    prevTime = currTime;

    // use passed-in timestep if specified, otherwise use the clock's
    currTime += (timeStep != ESMC_NULL_POINTER) ? *timeStep : this->timeStep;

    // count number of timesteps
    advanceCount++;

    // TODO: validate (range check) new time against its calendar ?

    if (ringingAlarmCount != ESMC_NULL_POINTER) *ringingAlarmCount = 0;

    // Calculate element size of F90 array of ESMC_Alarm pointers since we
    // cannont depend on C++ element size to be the same as F90's across all
    // platforms.  It is assumed that all F90 platforms allocate arrays
    // contiguously and uniformly in memory, in either ascending or descending
    // address order.
    // TODO:  calculate once during ESMF_FrameworkInitialize() (runtime),
    //        since this is a platform constant. compile-time constant ?
    // see also ESMC_ClockGetAlarmList().

    int f90ArrayElementSize = 0; 
    if (ringingAlarmList1stElementPtr != ESMC_NULL_POINTER &&
        ringingAlarmList2ndElementPtr != ESMC_NULL_POINTER) {
        f90ArrayElementSize = (int)(ringingAlarmList2ndElementPtr -
                                    ringingAlarmList1stElementPtr);
    }

    // traverse alarm list (i) for ringing alarms (j)
    for(int i=0, j=0; i<alarmCount; i++) {
      int rc;
      bool ringing;

      // check each alarm to see if it's time to ring
      ringing = alarmList[i]->ESMC_AlarmCheckRingTime(&rc);

      // report ringing alarms if requested
      if (ringing) {
        // report number of ringing alarms
        if (ringingAlarmCount != ESMC_NULL_POINTER) (*ringingAlarmCount)++;

        // report ringing alarm list
        if (ringingAlarmList1stElementPtr != ESMC_NULL_POINTER) {
          if (j < *sizeofRingingAlarmList) {
            // F90 equivalent: ringingAlarmList(j) = alarmList(i)
            //                 j = j + 1
            // calculate F90 array address for the j'th element ...
            char *f90ArrayElementJ;
            f90ArrayElementJ = ringingAlarmList1stElementPtr +
                               (j++ * f90ArrayElementSize);
            // ... then copy it in!
            *((ESMC_Alarm**)f90ArrayElementJ) = alarmList[i];
          } else rc = ESMF_FAILURE; // list overflow!
        }
      }
    }

    return(rc);

 } // end ESMC_ClockAdvance

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockIsStopTime - check if Clock's stop time has been reached
//
// !INTERFACE:
      bool ESMC_Clock::ESMC_ClockIsStopTime(
//
// !RETURN VALUE:
//    bool is stop time or not
//
// !ARGUMENTS:
      int  *rc) const {        // out - error return code
//
// !DESCRIPTION:
//    checks if {\tt ESMC\_Clock}'s stop time has been reached.
//
//EOP
// !REQUIREMENTS:

    if (rc != ESMC_NULL_POINTER) {
      *rc = ESMF_SUCCESS;
    }

    // TODO:  first check if stopTime has been specified; if not, return false.

    // positive time step ?
    if (stopTime > startTime) {
      return(currTime >= stopTime);

    // or negative time step ?
    } else if (stopTime < startTime) {
      return(currTime <= stopTime);

    // or no time step? (stopTime == startTime)
    } else return(currTime == stopTime);

 } // end ESMC_ClockIsStopTime

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetNextTime - calculates a Clock's next time 
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetNextTime(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_Time         *nextTime,       // out
      ESMC_TimeInterval *timeStep) {     // in

// !DESCRIPTION:
//      Calculates what the next time of the {\tt ESMF\_Clock} will be, based
//      on the clock's current timestep or an optionally passed-in timestep.

//
//EOP
// !REQUIREMENTS:  

    // initialize result to clock's current time
    //   (to copy calendar and timezone)
    // TODO:  delete when ESM[F,C]_Time overridden "+" operator is ready, which
    //        will do the copy of ESMC_Time's extra properties.
    *nextTime = currTime;

    if (timeStep != ESMC_NULL_POINTER) {
      // use passed-in timeStep if specified
      *nextTime = currTime + *timeStep;
    } else {
      // otherwise use clock's own timestep
      *nextTime = currTime + this->timeStep;
    }

    return(ESMF_SUCCESS);

 } // end ESMC_ClockGetNextTime

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetAlarm - get alarm from clock's alarm list
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetAlarm(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int          nameLen,   // in  - the length of the alarm name
      char        *name,      // in  - the alarm "name" to get
      ESMC_Alarm **alarm) {   // out - the alarm named "name"
//
// !DESCRIPTION:
//     Retrieve's the clock's alarm named "name" from the alarm list
//
//EOP
// !REQUIREMENTS:  TMG x.x

    if (nameLen >= ESMF_MAXSTR) {
      return(ESMF_FAILURE);
    }

    // TODO: use inherited methods from ESMC_Base
    char alarmName[ESMF_MAXSTR];
    strncpy(alarmName, name, nameLen);
    alarmName[nameLen] = '\0';  // null terminate

    // linear search for alarm name
    for(int i=0; i<alarmCount; i++) {
      if (strcmp(alarmName, alarmList[i]->name) == 0) {
        // found, return alarm
        *alarm = alarmList[i];
        return(ESMF_SUCCESS);
      }
    }

    // not found, return null ...
    *alarm = ESMC_NULL_POINTER;
    return(ESMF_FAILURE);

 } // end ESMC_ClockGetAlarm

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetAlarmList - Get a list of alarms from a clock
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetAlarmList(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_AlarmListType type,                   // in - list type to get
      char              *alarmList1stElementPtr, // out - array of alarms
      char              *alarmList2ndElementPtr, // in  - address of 2nd
                                                 //        element to calculate
                                                 //        F90 array element
                                                 //        size
      int               *sizeofAlarmList,        // in  - size of given array
                                                 //       of alarms
      int               *alarmCount,             // out - number of alarms
      ESMC_TimeInterval *timeStep) {             // in  - optional time step to
                                                 //         use instead of the
                                                 //         clock's (only use
                                                 //         with alarm list type
                                                 // ESMF_ALARMLIST_NEXTRINGING)
//
// !DESCRIPTION:
//    Gets an {\tt ESMF\_Clock}'s list of alarms.
//
//EOP
// !REQUIREMENTS:  TMG 4.3, 4.8

    int rc = ESMF_SUCCESS;

    *alarmCount = 0;

    // Calculate element size of F90 array of ESMC_Alarm pointers since we
    // cannont depend on C++ element size to be the same as F90's across all
    // platforms.  It is assumed that all F90 platforms allocate arrays
    // contiguously and uniformly in memory, in either ascending or descending
    // address order.
    // TODO:  calculate once during ESMF_FrameworkInitialize() (runtime),
    //        since this is a platform constant. compile-time constant ?
    // see also ESMC_ClockAdvance().

    int f90ArrayElementSize = 0; 
    if (alarmList2ndElementPtr != ESMC_NULL_POINTER) {
        f90ArrayElementSize = (int)(alarmList2ndElementPtr -
                                    alarmList1stElementPtr);
    }

    // traverse clock's alarm list (i) for alarms to return in
    //   requested list (j)
    for(int i=0, j=0; i < this->alarmCount; i++) {
      int rc;
      bool returnAlarm;

      // based on requested list type, check if this (i'th) alarm is
      //   to be returned
      switch (type)
      {
        case ESMF_ALARMLIST_ALL:
          // return all alarms!
          returnAlarm = true;
          break;

        case ESMF_ALARMLIST_RINGING:
          // return alarm if it's ringing
          returnAlarm = alarmList[i]->ESMC_AlarmIsRinging(&rc);
          break;

        case ESMF_ALARMLIST_NEXTRINGING:
          // return alarm if it will ring upon the next clock time step
          returnAlarm = alarmList[i]->ESMC_AlarmWillRingNext(timeStep, &rc);
          break;

        case ESMF_ALARMLIST_PREVRINGING:
          // return alarm if it was ringing on the previous clock time step
          returnAlarm = alarmList[i]->ESMC_AlarmWasPrevRinging(&rc);
          break;

        default :
          // unknown alarm list type; return empty list
          returnAlarm = false;
          rc = ESMF_FAILURE;
          break;
      }

      // copy alarm pointers to be returned into given F90 array
      if (returnAlarm) {
        // count and report number of returned alarms
        (*alarmCount)++;

        // copy if there's space in the given F90 array
        if (j < *sizeofAlarmList) {
          // F90/C++ equivalent: AlarmList(j) = this->alarmList[i]
          //                 j = j + 1
          // calculate F90 array address for the j'th element ...
          char *f90ArrayElementJ;
          f90ArrayElementJ = alarmList1stElementPtr +
                                                (j++ * f90ArrayElementSize);
          // ... then copy it in!
          *((ESMC_Alarm**)f90ArrayElementJ) = alarmList[i];
        } else rc = ESMF_FAILURE; // list overflow!
      }
    }
    return(rc);

 } // end ESMC_ClockGetAlarmList

#if 0
//
// possible native C++ versions
//
//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetAlarmList - get a clock's alarm list
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetAlarmList(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_Alarm ***alarmList,            // out - alarm list
      int          *alarmCount) const {   // out - number of alarms in list
//
// !DESCRIPTION:
//     Get a clock's alarm list and number of alarms
//
//EOP
// !REQUIREMENTS:  TMG 4.3

    // validate inputs
    if (alarmList == ESMC_NULL_POINTER || alarmCount == ESMC_NULL_POINTER) {
      return(ESMF_FAILURE);
    }

    // copy the list of alarm pointers
    for(int i=0; i<this->alarmCount; i++) {
      (*alarmList)[i] = this->alarmList[i];  
    }

    // return number of alarms
    *alarmCount = this->alarmCount;

    return(ESMF_SUCCESS);

 } // end ESMC_ClockGetAlarmList

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetRingingAlarm - get ringing alarm from clock's alarm list
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetRingingAlarm(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int          i,         // in  - the i'th alarm to get
      ESMC_Alarm **alarm) {   // out - the i'th alarm
//
// !DESCRIPTION:
//     Retrieve's the clock's i'th ringing alarm from the alarm list
//
//EOP
// !REQUIREMENTS:  TMG 4.1, 4.2

    // validate inputs
    if (i < 1 || i > alarmCount || alarm == ESMC_NULL_POINTER) {
      return(ESMF_FAILURE);
    }

    int rc;
    for (int j=0, r=0; j < alarmCount; j++) {
      if (alarmList[j]->ESMC_AlarmIsRinging(&rc)) {
        if (++r == i) *alarm = alarmList[j];
        return(ESMF_SUCCESS);
      }
    }

    return(ESMF_FAILURE);

 } // end ESMC_ClockGetRingingAlarm

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockGetAlarmList - get a clock's alarm list
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockGetAlarmList(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_Alarm **alarmList,            // out - alarm list
      int         *alarmCount) const {   // out - number of alarms in list
//
// !DESCRIPTION:
//     Get a clock's alarm list and number of alarms
//
//EOP
// !REQUIREMENTS:  TMG 4.3

    // validate inputs
    if (alarmList == ESMC_NULL_POINTER || alarmCount == ESMC_NULL_POINTER) {
      return(ESMF_FAILURE);
    }

    // copy the list of alarms
    for(int i=0; i<this->alarmCount; i++) {
      (*alarmList)[i] = *(this->alarmList[i]);  
    }

    // return number of alarms
    *alarmCount = this->alarmCount;

    return(ESMF_SUCCESS);

 } // end ESMC_ClockAddAlarm
#endif

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockSyncToRealTime - synchronize a clock to the wall clock time
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockSyncToRealTime(void) {
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//    Synchronize a clock to the wall clock time
//
//EOP
// !REQUIREMENTS:  TMG 3.4.5

    // set current time to wall clock time
    return(currTime.ESMC_TimeSyncToRealTime());

 } // end ESMC_ClockSyncToRealTime

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_Clock(==) - Clock equality comparison
// 
// !INTERFACE:
      bool ESMC_Clock::operator==(
//   
// !RETURN VALUE:
//    bool result
//
// !ARGUMENTS:
      const ESMC_Clock &clock) const {   // in - ESMC_Clock to compare
//
// !DESCRIPTION:
//      Compare for equality the current object's (this) {\tt ESMC\_Clock} with
//      given {\tt ESMC\_Clock}, return result
//   
//EOP
// !REQUIREMENTS:

    return(id == clock.id);

}  // end ESMC_Clock::operator==

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockReadRestart - restore contents of a Clock
//
// !INTERFACE:
      ESMC_Clock *ESMC_ClockReadRestart(
//
// !RETURN VALUE:
//    pointer to newly allocated and restored ESMC_Clock
//
// !ARGUMENTS:
      int          nameLen,  // in
      const char  *name,     // in
      ESMC_IOSpec *iospec,   // in
      int         *rc ) {    // out - return code

//
// !DESCRIPTION:
//      Restore information about an {\tt ESMC\_Clock}.
//      For persistence/checkpointing.
// 
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

    // TODO:  read clock state from iospec/name, then allocate/restore
    //        (share code with ESMC_ClockCreate()).

    return(ESMC_NULL_POINTER);

 } // end ESMC_ClockReadRestart

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockWriteRestart - save contents of a Clock
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockWriteRestart(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_IOSpec *iospec) const {
//
// !DESCRIPTION:
//      Save information about an {\tt ESMC\_Clock}.
//      For persistence/checkpointing
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

    // TODO:  save clock state using iospec/name.  Default to disk file.

    return(ESMF_SUCCESS);

 } // end ESMC_ClockWriteRestart

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockValidate - internal consistency check for a Clock
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockValidate(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const char *options) const {    // in - validate options
//
// !DESCRIPTION:
//      Validates that a {\tt ESMC\_Clock} is internally consistent.
//      Returns error code if problems are found.  {\tt ESMC\_Base}
//      class method.
//
//EOP
// !REQUIREMENTS:  XXXn.n, YYYn.n

    if(timeStep.ESMC_TimeIntervalValidate() != ESMF_SUCCESS ||
       startTime.ESMC_TimeValidate() != ESMF_SUCCESS ||
       stopTime.ESMC_TimeValidate() != ESMF_SUCCESS ||
       refTime.ESMC_TimeValidate() != ESMF_SUCCESS ||
       currTime.ESMC_TimeValidate() != ESMF_SUCCESS ||
       prevTime.ESMC_TimeValidate()) return(ESMF_FAILURE);

    // TODO:  if stoptime > startTime, then timeStep should be
    //        positive and vice versa
    // TODO:  if timeStep > 0, then currTime >= prevTime and vice versa
    
    return(ESMF_SUCCESS);

 } // end ESMC_ClockValidate

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockPrint - print contents of a Clock
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockPrint(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const char *options) const {    // in - print options
//
// !DESCRIPTION:
//      Prints a {\tt ESMC\_Clock}'s contents for testing/debugging
//
//EOP
// !REQUIREMENTS:  XXXn.n, YYYn.n

    cout << "Clock ----------------------------------" << endl;

    // print out individually selected components
    // TODO: enable multiple simultaneous options (token parsing)
    //       (currently mutually exclusive)
    if (options != ESMC_NULL_POINTER) {

      // make options case insensitive
      // TODO: put this into function to share
      char opts[ESMF_MAXSTR];
      int i;
      for(i=0; i<strlen(options) && i<ESMF_MAXSTR-1; i++) {
        opts[i] = tolower(options[i]);
      }
      opts[i] = '\0';

      if (strncmp(opts, "name", 4) == 0) {
        cout << "name = " << name << endl;
      }
      else if (strncmp(opts, "timestep", 8) == 0) {
        cout << "timeStep = " << endl;
        // TODO:  timeStep.ESMC_TimeIntervalPrint(&opts(8)); ?
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          timeStep.ESMC_TimeIntervalPrint("string");
        } else {
          timeStep.ESMC_TimeIntervalPrint();
        }
      }
      else if (strncmp(opts, "starttime", 9) == 0) {
        cout << "startTime = " << endl;
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          startTime.ESMC_TimePrint("string");
        } else {
          startTime.ESMC_TimePrint();
        }
      }
      else if (strncmp(opts, "stoptime", 8) == 0) {
        cout << "stopTime = " << endl;
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          stopTime.ESMC_TimePrint("string");
        } else {
          stopTime.ESMC_TimePrint();
        }
      }
      else if (strncmp(opts, "reftime", 7) == 0) {
        cout << "refTime = " << endl;
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          refTime.ESMC_TimePrint("string");
        } else {
          refTime.ESMC_TimePrint();
        }
      }
      else if (strncmp(opts, "currtime", 8) == 0) {
        cout << "currTime = " << endl;
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          currTime.ESMC_TimePrint("string");
        } else {
          currTime.ESMC_TimePrint();
        }
      }
      else if (strncmp(opts, "prevtime", 8) == 0) {
        cout << "prevTime = " << endl;
        if (strstr(opts, "string") != ESMC_NULL_POINTER) {
          prevTime.ESMC_TimePrint("string");
        } else {
          prevTime.ESMC_TimePrint();
        }
      }
      else if (strncmp(opts, "advancecount", 12) == 0) {
        cout << "advanceCount = " << advanceCount << endl;
      }
      else if (strncmp(opts, "numalarms", 9) == 0) {
        cout << "alarmCount = " << alarmCount << endl;
      }
      else if (strncmp(opts, "alarmlist", 9) == 0) {
        cout << "alarmList = " << endl;
        for (int i=0; i<alarmCount; i++) {
          cout << alarmList[i]->ESMC_AlarmPrint(&opts[9]);
        }
      }


    } else {
      // default:  print out all properties

      cout << "name = "      << name << endl;
      cout << "timeStep = "  << endl; timeStep.ESMC_TimeIntervalPrint(options);
      cout << "startTime = " << endl; startTime.ESMC_TimePrint(options);
      cout << "stopTime = "  << endl; stopTime.ESMC_TimePrint(options);
      cout << "refTime = "   << endl; refTime.ESMC_TimePrint(options);
      cout << "currTime = "  << endl; currTime.ESMC_TimePrint(options);
      cout << "prevTime = "  << endl; prevTime.ESMC_TimePrint(options);
      cout << "advanceCount = " << advanceCount << endl;
      cout << "alarmCount = "   << alarmCount   << endl;
      cout << "alarmList = " << endl;
      for (int i=0; i<alarmCount; i++) {
        cout << alarmList[i]->ESMC_AlarmPrint(options);
      }
    }

    cout << "end Clock ------------------------------" << endl << endl;

    return(ESMF_SUCCESS);

 } // end ESMC_ClockPrint

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_Clock - native C++ constructor
//
// !INTERFACE:
      ESMC_Clock::ESMC_Clock(void) {
//
// !RETURN VALUE:
//    none
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//      Calls standard ESMF deep or shallow methods for initialization
//      with default or passed-in values
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

    name[0] = '\0';
    advanceCount = 0;
    alarmCount = 0;
    id = ++count;  // TODO: inherit from ESMC_Base class

 } // end ESMC_Clock

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_Clock - native C++ copy constructor
//
// !INTERFACE:
      ESMC_Clock::ESMC_Clock(
//
// !RETURN VALUE:
//    none
//
// !ARGUMENTS:
      const ESMC_Clock &clock) {  // in - clock to copy
//
// !DESCRIPTION:
//      Copies members of given clock.
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

    *this = clock;

 } // end ESMC_Clock

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ~ESMC_Clock - native C++ destructor
//
// !INTERFACE:
      ESMC_Clock::~ESMC_Clock(void) {
//
// !RETURN VALUE:
//    none
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//      Calls standard ESMF deep or shallow methods for destruction
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

//
//  code goes here
//

 } // end ~ESMC_Clock

//-------------------------------------------------------------------------
// Private methods
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_ClockAddAlarm - add alarm to clock's alarm list
//
// !INTERFACE:
      int ESMC_Clock::ESMC_ClockAddAlarm(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      ESMC_Alarm *alarm) {   // in - alarm to add
//
// !DESCRIPTION:
//     Adds given alarm to a clock's alarm list. 
//     Used by {\tt ESMC\_AlarmCreate().}
//
//EOP
// !REQUIREMENTS:  TMG 4.1, 4.2

    int rc = ESMF_SUCCESS;

    // validate inputs
    if (alarmCount == MAX_ALARMS || alarm == ESMC_NULL_POINTER) {
      return(ESMF_FAILURE);
    }

    // append to list and count
    alarmList[alarmCount++] = alarm;

    // check new alarm to see if it's time to ring
    alarm->ESMC_AlarmCheckRingTime(&rc);

    return(rc);

 } // end ESMC_ClockAddAlarm
