% $Id: TimeMgr_inote_BaseTime.tex,v 1.1 2003/07/24 15:50:50 cdeluca Exp $

\begin{tabular}{|p{6in}|}
\hline
\vspace{.05in}
{\it Implementation Notes:\newline
Basing {\tt TimeIntervals} and {\tt Times} on the same internal representation} \\
\vspace{.05in}
It is useful to allow both {\tt TimeIntervals} and {\tt Times} to 
inherit from a single class, {\tt BaseTime}.  In C++, this can be
implemented by using inheritance.  In F90, it can be implemented
by having the derived types {\tt TimeIntervals} and {\tt Times}
contain a derived type {\tt BaseTime}.  In both cases, the 
{\tt BaseTime} class can be made private and invisible to the user.

The result of this strategy is that {\tt Time Intervals} and 
{\tt Times} gain a core representation of time as well a set
of basic methods.

The {\tt BaseTime} class can be designed with a minimum number of elements
to represent any required time.  The design is based on the idea used
in the real-time POSIX 1003.1b-1993 standard.  That is, to represent
time simply as a pair of integers: one for seconds (whole) and one for
nanoseconds (fractional).  These can then be converted at the interface
level to any desired format.

For ESMF, this idea can be modified and extended, in order to handle the
requirements for a large time range (> 200,000 years) and to exactly
represent any rational fraction, not just nanoseconds.  To handle the
large time range, a 64-bit or greater integer is used for whole seconds.
Any rational fractional second is expressed using two additional integers:
a numerator and a denominator.  Both the whole seconds and fractional
numerator are signed to handle negative time intervals and instants.
For arithmetic consistency both must carry the same sign (both positve
or both negative), except, of course, for zero values.  The fractional
seconds element (numerator) is \htmlref{normalized}{glos:Normalized}
(bounded) with respect to whole seconds. If the absolute value of the
numerator becomes greater than or equal to the denominator, the whole
seconds is incremented or decremented accordingly and the numerator is
reset to the remainder.  Conversions are performed upon demand by
interface methods within the {\tt TimeInterval} and
{\tt Time}.  This is done because different applications require different
representations of time intervals and time instances.

The {\tt BaseTime} class defines increment and decrement methods for basic
time interval calculations between time instants.  It is done here rather
than in the {\tt Calendar} class because it can be done with simple 
day-based arithmetic that is {\tt Calendar} independent.  

The {\tt TimeInterval} and {\tt Time} classes that are derived from 
{\tt BaseTime} contain an internal {\tt Calendar} class.  Upon demand by 
a user, the results of an increment or decrement operation are 
converted to user units, which may be calendar-dependent, via methods 
obtained from their internal {\tt Calendar}.

Comparison methods can also be defined in the {\tt BaseTime} class.  These
perform equality/inequality, less than, and greater than comparisons
between any two {\tt TimeIntervals} or {\tt Times}.  These methods capture
the common comparison logic between {\tt TimeIntervals} and {\tt Times} and
hence are defined here for sharing.

Methods or possibly a separate class can be included to handle fractional
arithmetic. 

For ease in calendar conversions, a time value of zero (both whole and
numerator) can correspond to the Julian date of zero. \\
\hline
\end{tabular}












