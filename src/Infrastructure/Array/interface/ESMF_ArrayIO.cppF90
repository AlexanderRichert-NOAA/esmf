! $Id: ESMF_ArrayIO.cppF90,v 1.5 2010/07/14 18:52:15 samsoncheung Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2010, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_ArrayIO.F90"
!==============================================================================
!
! ESMF ArrayIO module
module ESMF_ArrayIOMod
!
!==============================================================================
!
! This file contains the ArrayWrite() and ArrayRead() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_PIO_TKRMacros.hcppF90"

!------------------------------------------------------------------------------
!BOPI
! !MODULE: ESMF_ArrayIOMod - Provide TKR overloading for ESMF_ArrayWrite()
!                            and ESMF_ArrayRead()
!
! !DESCRIPTION:
!
! The code in this file is part of the {\tt ESMF\_Array} class Fortran API.
!
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod ! ESMF utility types
  use ESMF_InitMacrosMod ! ESMF initializer macros
  use ESMF_BaseMod ! ESMF base class
  use ESMF_LogErrMod ! ESMF error handling
  use ESMF_LocalArrayMod
  use ESMF_ArraySpecMod
  use ESMF_VMMod
  use ESMF_DELayoutMod
  use ESMF_DistGridMod
  use ESMF_RHandleMod
  use ESMF_F90InterfaceMod ! ESMF Fortran-C++ interface helper
  ! class sub modules
  use ESMF_ArrayCreateMod ! contains the ESMF_Array derived type definition
  use ESMF_ArrayGetMod
^ifdef ESMF_PIO  
  use pio
  use pio_support, only : piodie ! _EXTERNAL
^endif
  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
!
! !PUBLIC MEMBER FUNCTIONS:

! - ESMF-public methods:
  public ESMF_ArrayWrite
  public ESMF_ArrayRead

!EOPI
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_ArrayIO.cppF90,v 1.5 2010/07/14 18:52:15 samsoncheung Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================

! -------------------------- ESMF-public method -------------------------------
!BOPI

! !DESCRIPTION: 
! This interface provides a single entry point for the various 
!  types of {\tt ESMF\_ArrayIO} functions.
!EOPI 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayWrite"

!BOPI
! !IROUTINE: ESMF_ArrayWrite - Write Array via PIO

! !INTERFACE:
  subroutine ESMF_ArrayWrite(array, fname, rc)
!
! !ARGUMENTS:
    type(ESMF_Array), intent(inout) :: array
    character(*), intent(in) :: fname
    integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!   Write an {ESMF\_Array} object via PIO Library
!
!   Limitation:
!   (1) Currently only netCDF is supported
!   (2) Assume 1 DE per Pet
!
!  The arguments are:
!  \begin{description}
!  \item[array]
!    Existing {\tt ESMF\_Array} object without alloc for data
!   \item[fname]
!    The name of the file in which data written
!   \item[{[rc]}]
!    Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!
!EOPI
!------------------------------------------------------------------------------
    ! Local vars
    integer :: localrc                   ! local return code
    integer :: localtk
    integer :: rank

    type(ESMF_TypeKind)             :: typekind

^ifdef ESMF_PIO
    ! Initialize return code; assume routine not implemented
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Check init status of arguments
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, array, rc)

    ! Obtain typekind and rank
    call ESMF_ArrayGet( array, typekind=typekind, rank=rank, rc=localrc)
 
    ! Call a T/K/R specific interface in order to create the proper
    !  type of F90 pointer, allocate the space, set the values in the
    !  Array object, and return.  (The routine this code is calling is
    !  generated by macro.)

    localtk = typekind%dkind

    !! calling routines generated from macros by the preprocessor

    select case (localtk)
      !
      case (ESMF_TYPEKIND_I4%dkind)
        ! The PIO data type is PIO_int
        select case(rank)
          case (1)
            call ESMF_IntArrayWrite1DI4(array, PIO_int, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayWrite2DI4(array, PIO_int, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayWrite3DI4(array, PIO_int, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayWrite4DI4(array, PIO_int, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayWrite5DI4(array, PIO_int, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case (ESMF_TYPEKIND_R4%dkind)
        ! The PIO data type is PIO_real
        select case(rank)
          case (1)
            call ESMF_IntArrayWrite1DR4(array, PIO_real, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayWrite2DR4(array, PIO_real, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayWrite3DR4(array, PIO_real, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayWrite4DR4(array, PIO_real, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayWrite5DR4(array, PIO_real, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case (ESMF_TYPEKIND_R8%dkind)
        ! The PIO data type is PIO_double
        select case(rank)
          case (1)
            call ESMF_IntArrayWrite1DR8(array, PIO_double, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayWrite2DR8(array, PIO_double, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayWrite3DR8(array, PIO_double, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayWrite4DR8(array, PIO_double, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayWrite5DR8(array, PIO_double, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case default
        if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
          "Unsupported typekind", &
          ESMF_CONTEXT, rc)) return

    end select

    if (ESMF_LogMsgFoundError(localrc, &
      ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

^else
    ! Return indicating PIO not present
    if (present(rc)) rc = ESMF_RC_LIB_NOT_PRESENT
^endif

  end subroutine ESMF_ArrayWrite
!------------------------------------------------------------------------------


^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayRead"

!BOPI
! !IROUTINE: ESMF_ArrayRead - Read Array via PIO

! !INTERFACE:
  subroutine ESMF_ArrayRead(array, fname, rc)
!
! !ARGUMENTS:
    type(ESMF_Array), intent(inout) :: array
    character(*), intent(in)  :: fname
    integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!   Read an {ESMF\_Array} object via PIO Library 
! 
!   Limitation:  
!   (1) Currently only netCDF is supported 
!   (2) Assume 1 DE per Pet 
!
!  The arguments are:
!  \begin{description}
!  \item[array]
!    Existing {\tt ESMF\_Array} object without alloc for data
!   \item[fname]
!    The name of the file in which data read in
!   \item[{[rc]}]
!    Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!
!EOPI
!------------------------------------------------------------------------------
    ! Local vars
    integer :: localrc                   ! local return code
    integer :: localtk
    integer :: rank

    type(ESMF_TypeKind)             :: typekind

^ifdef ESMF_PIO
    ! Initialize return code; assume routine not implemented
    localrc = ESMF_RC_NOT_IMPL
    if (present(rc)) rc = ESMF_RC_NOT_IMPL

    ! Check init status of arguments
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, array, rc)

    ! Obtain typekind and rank
    call ESMF_ArrayGet( array, typekind=typekind, rank=rank, rc=localrc)

    ! Call a T/K/R specific interface in order to create the proper
    !  type of F90 pointer, allocate the space, set the values in the
    !  Array object, and return.  (The routine this code is calling is
    !  generated by macro.)

    localtk = typekind%dkind

    !! calling routines generated from macros by the preprocessor

    select case (localtk)
      !
      case (ESMF_TYPEKIND_I4%dkind)
        ! The PIO data type is PIO_int
        select case(rank)
          case (1)
            call ESMF_IntArrayRead1DI4(array, PIO_int, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayRead2DI4(array, PIO_int, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayRead3DI4(array, PIO_int, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayRead4DI4(array, PIO_int, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayRead5DI4(array, PIO_int, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case (ESMF_TYPEKIND_R4%dkind)
        select case(rank)
        ! The PIO data type is PIO_real
          case (1)
            call ESMF_IntArrayRead1DR4(array, PIO_real, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayRead2DR4(array, PIO_real, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayRead3DR4(array, PIO_real, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayRead4DR4(array, PIO_real, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayRead5DR4(array, PIO_real, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case (ESMF_TYPEKIND_R8%dkind)
        ! The PIO data type is PIO_double
        select case(rank)
          case (1)
            call ESMF_IntArrayRead1DR8(array, PIO_double, fname, rc=localrc)
          case (2)
            call ESMF_IntArrayRead2DR8(array, PIO_double, fname, rc=localrc)
          case (3)
            call ESMF_IntArrayRead3DR8(array, PIO_double, fname, rc=localrc)
          case (4)
            call ESMF_IntArrayRead4DR8(array, PIO_double, fname, rc=localrc)
          case (5)
            call ESMF_IntArrayRead5DR8(array, PIO_double, fname, rc=localrc)
          case default
            if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
              "Unsupported rank", &
              ESMF_CONTEXT, rc)) return
        end select

      case default
        if (ESMF_LogMsgFoundError(ESMF_RC_ARG_BAD, &
          "Unsupported typekind", &
          ESMF_CONTEXT, rc)) return

    end select

    if (ESMF_LogMsgFoundError(localrc, &
      ESMF_ERR_PASSTHRU, &
      ESMF_CONTEXT, rcToReturn=rc)) return

    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

^else
    ! Return indicating PIO not present
    if (present(rc)) rc = ESMF_RC_LIB_NOT_PRESENT
^endif

  end subroutine ESMF_ArrayRead
!------------------------------------------------------------------------------



^ifdef ESMF_PIO

  subroutine check_pioerr(ierr, localPet, file, line, str1, str2)

    implicit none
    integer,intent(in) :: ierr
    integer,intent(in) :: localPet
    character(len=*),intent(in) :: file
    integer,intent(in) :: line
    character(len=*),optional,intent(in) :: str1
    character(len=*),optional,intent(in) :: str2
    
    character(len=256) lstr1
    character(len=256) lstr2
    character(len=*),parameter :: myname_='check_pioerr'

    lstr1 = ''
    if (present(str1)) then
       lstr1 = trim(str1)
    endif
    lstr2 = trim(lstr1)
    if (present(str2)) then
       lstr2 = trim(str2)
    endif

    if(ierr /= PIO_noerr) then
       write(*,*) trim(myname_),':: ERROR on my_task=',localPet,' ierr=',ierr,'  ',trim(lstr1)
       call piodie(file,line,trim(lstr2))
    endif

  end subroutine check_pioerr

!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      subroutine WriteHeader(File,nxyz,dimid_xyz,spacedim)
      implicit none

      type (File_desc_t), intent(inout) :: File
      integer, intent(in) :: spacedim
      integer, intent(in) :: nxyz(spacedim)
      integer, intent(out) :: dimid_xyz(spacedim)

      character(len=80) :: text
      character(len=3) :: cdim
      integer :: itmp,iostat,i

      iostat = PIO_put_att(File,pio_global,'title','ESMF_Array')
      if(iostat /= pio_noerr) then
         write(*,*) 'testPIO:  Error writing TITLE to netCDF file'
      endif

      iostat = PIO_put_att(File,pio_global,'ivalue', 4)
      if(iostat /= pio_noerr) then
         write(*,*) 'testPIO:  Error writing iVALUE to netCDF file'
      endif

      text = 'Dimension'
      do i = 1,spacedim
        write(cdim,'(i3.3)') i
        text(10:12) = cdim
        iostat = PIO_def_dim(File,trim(text),nxyz(i),dimid_xyz(i))
        if(iostat /= pio_noerr) then
          write(*,*) 'testPIO:  Error defining dimension',i,' for netCDF file'
        endif
      enddo

      end subroutine WriteHeader

^endif


!===============================================================================
! IntArrayWrite() and IntArrayRead() interfaces
!===============================================================================


#define IntArrayWriteDoc() \
! -------------------------- ESMF-public method ----------------------------- @\
!BOP @\
! @\
! !IROUTINE: ESMF_IntArrayWrite - Write an ESMF_Array via PIO @\
! @\
! !INTERFACE: @\
! subroutine ESMF_IntArrayWrite<rank><type><kind>(array, basepiotype, fname, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Array),           intent(inout)           :: array @\
!   integer,                    intent(in)              :: basepiotype @\
!   character(*),               intent(in)              :: fname @\
!   integer,                    intent(out),  optional  :: rc @\
! @\
! @\
! !DESCRIPTION: @\
!   Write an {ESMF\_Array} object via PIO Library @\
! @\
!   Limitation:  @\
!   (1) Currently only netCDF is supported @\
!   (2) Assume 1 DE per Pet @\
! @\
!   The arguments are: @\
!   \begin{description} @\
!   \item[array] @\
!     The {\tt ESMF\_Array} object from which data will be gathered. @\
!   \item[basepiotype] @\
!     The PIO datatype: PIO_real, PIO_double, or PIO_int @\
!   \item[{[fname]}] @\
!     Optional output file name @\
!   \item[{[rc]}] @\
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!   \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define IntArrayWriteMacro(mtype, mtypekind, mrank, mdim, mlen, mrng, mloc) \
! -------------------------- ESMF-public method ----------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_IntArrayWrite" @\
  subroutine ESMF_IntArrayWrite##mrank##D##mtypekind(array, basepiotype, fname, rc) @\
@\
    type(ESMF_Array),           intent(inout)           :: array @\
    integer,                    intent(in)              :: basepiotype @\
    character(*),               intent(in)              :: fname @\
    integer,                    intent(out),  optional  :: rc @\
@\
^ifdef ESMF_PIO  @\
    ! ESMF VARIABLES @\
    type(ESMF_VM)       :: vm_opt @\
    integer :: pioDofCount @\
    integer, allocatable :: pioDofList(:) @\
    integer :: petCount,localPet,mpic @\
    mtype (ESMF_KIND_##mtypekind),pointer,dimension(mdim)  :: farraywr @\
    integer :: dimC @\
    integer, allocatable :: gDimsIndex(:), dimid_xyz(:) @\
    integer, allocatable :: minIndexPDimPPatch(:,:), maxIndexPDimPPatch(:,:) @\
@\
    ! PIO VARIABLES: @\
    type (iosystem_desc_t) :: PIOSYS @\
    type (File_desc_t)  :: File @\
    type(var_desc_t) :: vard @\
    type (IO_desc_t)    :: IOdesc @\
    integer :: mode, num_aggregator @\
    integer :: stride, base, num_iotasks, rearr_type @\
    integer(kind=PIO_OFFSET) :: one @\
@\
    ! OTHER VARIABLES: @\
    integer                       :: localrc        ! local return code @\
    integer                       :: i   @\
    real (ESMF_KIND_r8) :: st,et,dt_write  ! start/end times for timing @\
    character(len=30) :: varname         ! variable name @\
@\
    ! Initialize return code @\
    localrc = ESMF_RC_NOT_IMPL @\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
@\
    ! Check init status of arguments @\
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, array, rc) @\
@\
    ! Obtain localPet @\
    call ESMF_VMGetCurrent(vm_opt, rc=localrc) @\
    call ESMF_VMGet(vm_opt, mpiCommunicator=mpic, localPet=localPet, petCount=petCount, rc=localrc) @\
@\
    !-------------------------------- @\
    ! Obatin the DOF from  (pioDofList) @\
    !-------------------------------- @\
    call ESMF_ArrayConstructPioDof(array, localDe=0, pioDofCount=pioDofCount, rc=rc) @\
    allocate(pioDofList(pioDofCount)) @\
    !debug write(10+localPet,*) "pioDofCount=",pioDofCount  @\
    call ESMF_ArrayConstructPioDof(array, localDe=0, pioDofList=pioDofList, rc=rc) @\
    !debug write(10+localPet,*) "pioDofList=" @\
    !debug write(10+localPet,*) pioDofList @\
    !debug write(10+localPet,*) " " @\
@\
    !------------------------------------------- @\
    ! Get array dimension counts from ESMF array @\
    !------------------------------------------- @\
    call ESMF_ArrayGet(array, dimCount=dimC, rc=localrc) @\
    allocate (dimid_xyz(dimC)) @\
    allocate (gDimsIndex(dimC)) @\
    allocate ( minIndexPDimPPatch(dimC,1) ) @\
    allocate ( maxIndexPDimPPatch(dimC,1) ) @\
    call ESMF_ArrayGet(array, localDe=0, farrayPtr=farraywr, rc=localrc) @\
    call ESMF_ArrayGet(array, maxIndexPDimPPatch=maxIndexPDimPPatch, & @\
                    minIndexPDimPPatch=minIndexPDimPPatch, rc=localrc) @\
@\
    do i=1,dimC @\
      gDimsIndex(i) = maxIndexPDimPPatch(i,1)-minIndexPDimPPatch(i,1)+1 @\
    enddo @\
@\
    !debug write(10+localPet,*)'farraywr', farraywr @\
    !debug write(10+localPet,*)'gDimsIndex', gDimsIndex @\
    !debug write(10+localPet,*)'' @\
    !debug write(10+localPet,*)' ================== ' @\
    !debug write(10+localPet,*)'' @\
@\
    !-------------------------------------- @\
    ! parallel IO subsystem input @\
    !-------------------------------------- @\
    num_iotasks    = petCount    ! Same as Compute nodes. @\
    num_aggregator = 1    ! For MPI-IO @\
    stride         = 1    ! IO stride @\
    base           = 0    ! the CPU (myID) associated with striding @\
                          ! non-zero, will off load the master @\
    rearr_type     = 2    ! no rearrangement=0 (use box[2] they said) @\
@\
    !-------------------------------------- @\
    ! Initalizes the parallel IO subsystem @\
    !-------------------------------------- @\
    call PIO_init(localPet, mpic, num_iotasks, num_aggregator, stride, & @\
         rearr_type, PIOSYS, base) @\
@\
    !------------------------------------------------------- @\
    ! Explain the distributed array decomposition to PIOlib @\
    !------------------------------------------------------- @\
    call PIO_initDecomp(PIOSYS,basepiotype, gDimsIndex,pioDofList,IOdesc) @\
@\
    !------------ @\
    ! Open file{s} @\
    !------------ @\
    mode = pio_64bit_offset @\
    localrc = PIO_CreateFile(PIOSYS,File,iotype_netcdf,trim(fname), mode) @\
@\
    ! Set Frame to '1' in the PIO descriptor file @\
    one = 1 @\
    call PIO_SetFrame(vard,one) @\
@\
    !----------------------------------- @\
    ! for the single record real*8 file @\
    !----------------------------------- @\
    call WriteHeader(File,gDimsIndex,dimid_xyz,dimC) @\
    ! Output are dimid_x,dimid_y,dimid_z @\
@\
    localrc = 1 @\
    call ESMF_ArrayGet(array, name=varname, rc=localrc) @\
!    write(varname,'(a,i5.5)') 'field',localrc @\
    rc = PIO_def_var(File,varname,basepiotype,  &  @\
             dimid_xyz,vard) @\
    call check_pioerr(rc,localPet,__FILE__,__LINE__,' defvar') @\
    rc = PIO_enddef(File) @\
@\
    !------------------------- @\
    ! Time the parallel write @\
    !------------------------- @\
    dt_write = 0. @\
!    call MPI_Barrier(mpic,rc) @\
!    st = MPI_Wtime() @\
    call PIO_write_darray(File,vard, IOdesc, farraywr, localrc) @\
    call check_pioerr(rc,localPet,__FILE__,__LINE__,' write_darray') @\
!    et = MPI_Wtime() @\
@\
    call PIO_CloseFile(File) @\
!    call MPI_Barrier(mpic,localrc) @\
!    dt_write = dt_write + (et - st) @\
!@\
!!!!!!!!!!!!!!!!!!!!!!!!!!! @\
@\
    ! Maximum read/write times @\
!    if(localPet.eq.0) write(*,*) "Time for write:", dt_write @\
@\
    call pio_freedecomp(PIOSYS, IOdesc) @\
    call pio_finalize (PIOSYS, rc) @\
    deallocate (pioDofList) @\
    deallocate (dimid_xyz) @\
    deallocate (gDimsIndex) @\
    deallocate (minIndexPDimPPatch) @\
    deallocate (maxIndexPDimPPatch) @\
@\
    ! Return successfully @\
    if (present(rc)) rc = ESMF_SUCCESS @\
^else @\
    ! Return indicating PIO not present @\
    if (present(rc)) rc = ESMF_RC_LIB_NOT_PRESENT @\
^endif @\
@\
  end subroutine ESMF_IntArrayWrite##mrank##D##mtypekind @\
!---------------------------------------------------------------------------- @\




#define IntArrayReadDoc() \
! -------------------------- ESMF-public method ----------------------------- @\
!BOP @\
! @\
! !IROUTINE: ESMF_IntArrayRead - Read an ESMF_Array via PIO @\
! @\
! !INTERFACE: @\
! subroutine ESMF_IntArrayRead<rank><type><kind>(array, basepiotype, fname, rc) @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Array),           intent(inout)           :: array @\
!   integer,                    intent(in)              :: basepiotype @\
!   character(*),               intent(in)              :: fname @\
!   integer,                    intent(out),  optional  :: rc @\
! @\
! @\
! !DESCRIPTION: @\
!   Read an {ESMF\_Array} object via PIO Library @\
! @\
!   Limitation:  @\
!   (1) Currently only netCDF is supported @\
!   (2) Assume 1 DE per Pet @\
! @\
!   The arguments are: @\
!   \begin{description} @\
!   \item[array] @\
!     The {\tt ESMF\_Array} object from which data will be gathered. @\
!   \item[basepiotype] @\
!     The PIO datatype: PIO_real, PIO_double, or PIO_int @\
!   \item[{[fname]}] @\
!     Optional output file name @\
!   \item[{[rc]}] @\
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!   \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define IntArrayReadMacro(mtype, mtypekind, mrank, mdim, mlen, mrng, mloc) \
! -------------------------- ESMF-public method ----------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_IntArrayRead" @\
  subroutine ESMF_IntArrayRead##mrank##D##mtypekind(array, basepiotype, fname, rc) @\
@\
    type(ESMF_Array),           intent(inout)           :: array @\
    integer,                    intent(in)              :: basepiotype @\
    character(*),               intent(in)              :: fname @\
    integer,                    intent(out),  optional  :: rc @\
@\
^ifdef ESMF_PIO  @\
    ! ESMF VARIABLES @\
    type(ESMF_VM)       :: vm_opt @\
    type(ESMF_TypeKind) :: typekind @\
    integer :: pioDofCount @\
    integer, allocatable :: pioDofList(:) @\
    integer :: petCount,localPet,mpic @\
    mtype (ESMF_KIND_##mtypekind),pointer,dimension(mdim)  :: farrayrd @\
    integer :: dimC @\
    integer, allocatable :: gDimsIndex(:) @\
    integer, allocatable :: minIndexPDimPPatch(:,:), maxIndexPDimPPatch(:,:) @\
@\
    ! PIO VARIABLES: @\
    type (iosystem_desc_t) :: PIOSYS @\
    type (File_desc_t)  :: File @\
    type(var_desc_t) :: vard @\
    type (IO_desc_t)    :: IOdesc @\
    integer :: mode, num_aggregator @\
    integer :: stride, base, num_iotasks, rearr_type @\
    integer(kind=PIO_OFFSET) :: one @\
@\
    ! OTHER VARIABLES: @\
    integer                       :: localrc        ! local return code @\
    integer                       :: i   @\
    real (ESMF_KIND_r8) :: st,et,dt_read  ! start/end times for timing @\
    character(len=30) :: varname         ! variable name @\
@\
    ! Initialize return code @\
    localrc = ESMF_RC_NOT_IMPL @\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
@\
    ! Check init status of arguments @\
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit, array, rc) @\
@\
    ! Obtain localPet @\
    call ESMF_VMGetCurrent(vm_opt, rc=localrc) @\
    call ESMF_VMGet(vm_opt, mpiCommunicator=mpic, localPet=localPet, petCount=petCount, rc=localrc) @\
@\
    !-------------------------------- @\
    ! Obatin the DOF from  (pioDofList) @\
    !-------------------------------- @\
    call ESMF_ArrayConstructPioDof(array, localDe=0, pioDofCount=pioDofCount, rc=rc) @\
    allocate(pioDofList(pioDofCount)) @\
    write(10+localPet,*) "pioDofCount=",pioDofCount  @\
    call ESMF_ArrayConstructPioDof(array, localDe=0, pioDofList=pioDofList, rc=rc) @\
@\
@\
    !-------------------------------- @\
    ! Get array typekind from ESMF array @\
    !-------------------------------- @\
    call ESMF_ArrayGet(array, dimCount=dimC, rc=localrc) @\
    call ESMF_ArrayGet(array, typekind=typekind, rc=localrc) @\
    allocate (gDimsIndex(dimC)) @\
    allocate ( minIndexPDimPPatch(dimC,1) ) @\
    allocate ( maxIndexPDimPPatch(dimC,1) ) @\
    call ESMF_ArrayGet(array, localDe=0, farrayPtr=farrayrd, rc=localrc) @\
    call ESMF_ArrayGet(array, maxIndexPDimPPatch=maxIndexPDimPPatch, & @\
                    minIndexPDimPPatch=minIndexPDimPPatch, rc=localrc) @\
@\
    do i=1,dimC @\
      gDimsIndex(i) = maxIndexPDimPPatch(i,1)-minIndexPDimPPatch(i,1)+1 @\
    enddo @\
@\
    !-------------------------------------- @\
    ! parallel IO subsystem input @\
    !-------------------------------------- @\
    num_iotasks    = petCount    ! Same as Compute nodes. @\
    num_aggregator = 1    ! For MPI-IO @\
    stride         = 1    ! IO stride @\
    base           = 0    ! the CPU (myID) associated with striding @\
                          ! non-zero, will off load the master @\
    rearr_type     = 2    ! no rearrangement=0 (use box[2] they said) @\
@\
    !-------------------------------------- @\
    ! Initalizes the parallel IO subsystem @\
    !-------------------------------------- @\
    call PIO_init(localPet, mpic, num_iotasks, num_aggregator, stride, & @\
         rearr_type, PIOSYS, base) @\
@\
    !------------------------------------------------------- @\
    ! Explain the distributed array decomposition to PIOlib @\
    !------------------------------------------------------- @\
    call PIO_initDecomp(PIOSYS,basepiotype, gDimsIndex,pioDofList,IOdesc) @\
@\
    !-------------------------------- @\
    ! Open a file and check data @\
    !-------------------------------- @\
    mode = pio_64bit_offset @\
    localrc = PIO_OpenFile(PIOSYS,File,iotype_netcdf,fname) @\
    call check_pioerr(rc,localPet,__FILE__,__LINE__,' openfile') @\
@\
    ! Set Frame to '1' in the PIO descriptor file @\
    one = 1 @\
    call ESMF_ArrayGet(array, name=varname, rc=localrc) @\
    rc = PIO_inq_varid(File, trim(varname), vard) @\
    call check_pioerr(rc,localPet,__FILE__,__LINE__,' defvar') @\
    call PIO_SetFrame(vard,one) @\
@\
    !------------------------- @\
    ! Time the parallel read @\
    !------------------------- @\
    dt_read = 0. @\
!    call MPI_Barrier(mpic,rc) @\
!    st = MPI_Wtime() @\
    call PIO_read_darray(File,vard, IOdesc, farrayrd, localrc) @\
    call check_pioerr(rc,localPet,__FILE__,__LINE__,' read_darray') @\
!    et = MPI_Wtime() @\
@\
    call PIO_CloseFile(File) @\
!    call MPI_Barrier(mpic,localrc) @\
!    dt_read = dt_read + (et - st) @\
!@\
!!!!!!!!!!!!!!!!!!!!!!!!!!! @\
@\
    ! Maximum read/write times @\
!    if(localPet.eq.0) write(*,*) "Time for read:", dt_read @\
@\
    call pio_freedecomp(PIOSYS, IOdesc) @\
    call pio_finalize (PIOSYS, rc) @\
    deallocate (pioDofList) @\
    deallocate (gDimsIndex) @\
    deallocate (minIndexPDimPPatch) @\
    deallocate (maxIndexPDimPPatch) @\
@\
    ! Return successfully @\
    if (present(rc)) rc = ESMF_SUCCESS @\
^else @\
    ! Return indicating PIO not present @\
    if (present(rc)) rc = ESMF_RC_LIB_NOT_PRESENT @\
^endif @\
@\
  end subroutine ESMF_IntArrayRead##mrank##D##mtypekind @\


TypeKindRankDeclarationMacro(IntArrayWrite)
TypeKindRankDeclarationMacro(IntArrayRead)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
end module ESMF_ArrayIOMod

