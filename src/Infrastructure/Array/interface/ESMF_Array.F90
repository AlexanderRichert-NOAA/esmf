! $Id: ESMF_Array.F90,v 1.12 2004/06/07 05:20:51 nscollins Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2003, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the GPL.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Array.F90"
!
!     ESMF Array module
      module ESMF_ArrayMod
!
!==============================================================================
!
! This file contains the Array class definition and all Array
! class methods which are *not* generated by macro.  
! See ESMF_ArrayCreate.F90 and ESMF_ArrayGet.F90 for the 
! macro-generated interfaces.
!
!------------------------------------------------------------------------------
#include "ESMF.h"

!------------------------------------------------------------------------------
!BOPI
! !MODULE: ESMF_ArrayMod - Manage data arrays uniformly between F90 and C++     
!
! !DESCRIPTION:
!
! The code in this file implements the {\tt Array} class and 
!  associated functions and subroutines.  
!
! C and C++ arrays are simple pointers to memory.
! Fortran arrays contain shape and stride definitions and are strongly
! typed.  To enable interoperability between the languages the C++ code
! must be able to obtain this information from the Fortran description
! (which is called the "dope vector" in Fortran), either through a priori
! knowledge or through query.
!
!------------------------------------------------------------------------------
! !USES:
      use ESMF_BaseMod
      use ESMF_LogErrMod
      use ESMF_IOSpecMod
      use ESMF_ArraySpecMod
      use ESMF_LocalArrayMod
      use ESMF_DELayoutMod
      implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private
!------------------------------------------------------------------------------
!     ! ESMF_HaloDirection
! 
!     ! Object for specifiying halo directions (mostly a placeholder for now)

      type ESMF_HaloDirection
      sequence
      private
        integer :: edges
      end type


!------------------------------------------------------------------------------
!     ! ESMF_Mask
! 
!     ! Class for storing information about masked regions.

      type ESMF_Mask
      sequence
      private
        ! same size as data array
#if !defined(ESMF_NO_INITIALIZERS) && !defined(ESMF_AIX_8_INITBUG)
        type (ESMF_LocalArray), pointer :: maskvals => NULL()
#else
        type (ESMF_LocalArray), pointer :: maskvals 
#endif
      end type


!------------------------------------------------------------------------------
!     ! ESMF_Array
!
!     ! Array data type.  All information is kept on the C++ side inside
!     ! the class structure.

      type ESMF_Array
      sequence
        ! opaque pointer to the C++ class data
#if !defined(ESMF_NO_INITIALIZERS) && !defined(ESMF_AIX_8_INITBUG)
        type(ESMF_Pointer) :: this = ESMF_NULL_POINTER
#else
        type(ESMF_Pointer) :: this
#endif
      end type

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
      public ESMF_HaloDirection, ESMF_Mask
      public ESMF_Array
!------------------------------------------------------------------------------

! !PUBLIC MEMBER FUNCTIONS:
 
      public ESMF_ArrayGet, ESMF_ArraySet

      public ESMF_ArraySetAxisIndex, ESMF_ArrayGetAxisIndex  
      public ESMF_ArrayComputeAxisIndex

      public ESMF_ArrayWriteRestart
      public ESMF_ArrayReadRestart
      public ESMF_ArrayWrite
      public ESMF_ArrayRead
 
      public ESMF_ArrayValidate
      public ESMF_ArrayPrint
!EOPI

      public assignment(=)

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id: ESMF_Array.F90,v 1.12 2004/06/07 05:20:51 nscollins Exp $'
!
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

interface assignment (=)
 module procedure ESMF_aras
end interface

!==============================================================================

      contains

!==============================================================================

subroutine ESMF_aras(daval, saval)
 type(ESMF_LocalArray), intent(out) :: daval
 type(ESMF_Array), intent(in) :: saval

 daval%this = saval%this
end subroutine


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGet"
!BOP
! !IROUTINE: ESMF_ArrayGet
!
! !INTERFACE:
      subroutine ESMF_ArrayGet(array, rank, type, kind, counts, &
                               lbounds, ubounds, strides, haloWidth, &
                               base, name, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      integer, intent(out), optional :: rank
      type(ESMF_DataType), intent(out), optional :: type
      type(ESMF_DataKind), intent(out), optional :: kind
      integer, dimension(:), intent(out), optional :: counts
      integer, dimension(:), intent(out), optional :: lbounds
      integer, dimension(:), intent(out), optional :: ubounds
      integer, dimension(:), intent(out), optional :: strides
      integer, intent(out), optional :: haloWidth
      type(ESMF_Pointer), intent(out), optional :: base
      character(len=ESMF_MAXSTR), intent(out), optional :: name
      integer, intent(out), optional :: rc             

!
! !DESCRIPTION:
!  Return information about an {\tt ESMF\_Array}.
!  For queries where the caller only wants a single value, 
!  specify the argument by name.
!  All the arguments after the array input are optional to facilitate this.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[rank]}]
!           The number of dimensions in the {\tt array}.
!     \item [{[type]}]
!	    {\tt ESMF\_DataType}.  Will be one of: 
!           {\tt ESMF\_DATA\_INTEGER}, {\tt ESMF\_DATA\_REAL},
!           {\tt ESMF\_DATA\_LOGICAL}, {\tt ESMF\_DATA\_CHARACTER}, or
!           {\tt ESMF\_DATA\_COMPLEX}.
!     \item [{[kind]}]
!           {\tt ESMF\_DataKind} variable which indicates 
!           the item size in bytes.  Will be one of:
!           {\tt ESMF\_I1}, {\tt ESMF\_I2}, {\tt ESMF\_I4},
!           {\tt ESMF\_I8}, {\tt ESMF\_R4}, {\tt ESMF\_R8},
!           {\tt ESMF\_C8}, or {\tt ESMF\_C16}.
!     \item [{[counts]}]
!           The number of items in each dimension of the {\tt array}.
!     \item [{[lbounds]}]
!           The lower index value of each dimension of the {\tt array}.
!     \item [{[ubounds]}]
!           The upper index value of each dimension of the {\tt array}.
!     \item [{[strides]}]
!           If nonzero, the spacing between index values per dimension
!           of the {\tt array}.
!     \item [{[haloWidth]}]
!           Width of halo region.
!     \item [{[base]}]
!           Base memory address of the data region of the {\tt array}.
!     \item [{[name]}]
!           {\tt array} name.  If one was not specified at create time,
!           a unique name will have been generated.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      integer :: status      ! Error status
      logical :: rcpresent   ! Return code present
      integer :: lrank       ! Local use to get rank

      ! Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif


      if (present(rank)) then
         call c_ESMC_ArrayGetRank(array, rank, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(type)) then
         call c_ESMC_ArrayGetType(array, type, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(kind)) then
         call c_ESMC_ArrayGetKind(array, kind, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(counts)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetLengths(array, lrank, counts, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(lbounds)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetLbounds(array, lrank, lbounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(ubounds)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_ArrayGetUbounds(array, lrank, ubounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(haloWidth)) then
         call c_ESMC_ArrayGetHWidth(array, haloWidth, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(base)) then
         call c_ESMC_ArrayGetBaseAddr(array, base, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(strides)) then
         if (ESMF_LogWrite("Strides not yet supported", &
                               ESMF_LOG_WARNING, ESMF_CONTEXT)) continue
         strides(:) = 1
      endif

      if (present(name)) then
         call c_ESMC_GetName(array, name, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGet

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayGetAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [totalindex]
!           An array of index spaces for the total array size.
!     \item [{[compindex]}]
!           An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!           An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        integer :: status, i

        ! call c routine to get index
        if (present(totalindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_TOTAL, totalindex,&
                                        status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status

        end subroutine ESMF_ArrayGetAxisIndex

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayPrint"
!BOP
! !IROUTINE: ESMF_ArrayPrint - Print contents of an Array object
!
! !INTERFACE:
      subroutine ESMF_ArrayPrint(array, options, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Print information about an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           The standard print options. See {\ref:xx}.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       if (array%this .eq. ESMF_NULL_POINTER) then
         print *, "Array Print:"
         print *, " Empty or Uninitialized Array"
         if (present(rc)) rc = ESMF_SUCCESS
         return
       endif

       defaultopts = "brief"

       if(present(options)) then
           call c_ESMC_ArrayPrint(array, options, status) 
       else
           call c_ESMC_ArrayPrint(array, defaultopts, status) 
       endif

       if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return

       ! set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayPrint

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayRead"
!BOPI
! !IROUTINE: ESMF_ArrayRead
!
! !INTERFACE:
      function ESMF_ArrayRead(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayRead
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              ! array name to read
      type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
      integer, intent(out), optional :: rc                 ! return code
!
! !DESCRIPTION:
!     Read data from persistent storage in a variety of formats.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

!
!	Changed BOP/EOP to BOPI/EOPI until function is implemented.
!
        type (ESMF_Array) :: a

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayRead = a 

        if (present(rc)) rc = ESMF_FAILURE

        end function ESMF_ArrayRead

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayReadRestat"
!BOPI
! !IROUTINE: ESMF_ArrayReadRestart
!
! !INTERFACE:
      function ESMF_ArrayReadRestart(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayReadRestart
!
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name 
      type(ESMF_IOSpec), intent(in), optional :: iospec 
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!      Used to reinitialize
!      all data associated with an {\tt ESMF\_Array}
!      from the last call to writerestart.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

        type (ESMF_Array) :: a 

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayReadRestart = a 
 
        if (present(rc)) rc = ESMF_FAILURE

        end function ESMF_ArrayReadRestart

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayReorder"
!BOPI
! !IROUTINE: ESMF_ArrayReorder
!
! !INTERFACE:
      subroutine ESMF_ArrayReorder(array, newarrayspec, newarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array 
      type(ESMF_ArraySpec), intent(in) :: newarrayspec
      type(ESMF_Array):: newarray   
      integer, intent(out), optional :: rc       
!
! !DESCRIPTION:
!      Used to alter the local memory ordering (layout) of this Array.
!
!  !TODO: remove this note before generating user documentation
!
!      (i am not sure this makes sense now, or that the routine should be
!      in this class.  but i am leaving this here as a reminder that we
!      might need some low level reorder functions.  maybe the argument
!      should be another array or an arrayspec which describes what you
!      want, and the input array is what exists, and this routine can then
!      make one into the other.   is this a type of create?  or is this
!      a copy?)
!
!EOPI

!
! TODO: code goes here
!	Changed BOP/EOP to BOPI/EOPI until code is written.
!
        if (present(rc)) rc = ESMF_FAILURE

        end subroutine ESMF_ArrayReorder

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySetAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArraySetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArraySetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to annotate an {\tt ESMF\_Array} with information 
!      used to manage halo regions.
!           
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[totalindex]}]
!	    An array of index spaces for the total array size.
!     \item [{[compindex]}]
!	    An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!	    An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!       
!
!EOPI

        integer :: status
        integer :: i

        ! call c routine to add index
        if (present(totalindex)) then
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min - 1
            totalindex(i)%max = totalindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_TOTAL, &
                                        totalindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min - 1
            compindex(i)%max = compindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min - 1
            exclindex(i)%max = exclindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status
        end subroutine ESMF_ArraySetAxisIndex

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayComputeAxisIndex"
!BOPI
! !IROUTINE: ESMF_ArrayComputeAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArrayComputeAxisIndex(array, delayout, decompids, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_DELayout), intent(in) :: delayout
      integer, dimension(:), intent(in) :: decompids
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to annotate an {\tt ESMF\_Array} with information 
!      used to manage halo regions.
!           
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [delayout]
!           The {\tt ESMF\_DELayout} over which this {\tt ESMF\_Array}
!           is decomposed.
!     \item [decompids]
!           An integer array, one index per dimension, identifying
!           which axes are decomposed and in which order.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!       
!
!EOPI

        integer :: status
        integer :: i, dlength

        ! call c routine to do work
        dlength = size(decompids)
   !     call c_ESMC_ArrayComputeAxisIndex(array, delayout, decompids, &
   !                                       dlength, status)

        if (present(rc)) rc = status

        end subroutine ESMF_ArrayComputeAxisIndex

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArraySet"
!BOP
! !IROUTINE: ESMF_ArraySet - Set information about an Array
!
! !INTERFACE:
      subroutine ESMF_ArraySet(array, name, rc)

!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array
      character (len = *), intent(in), optional :: name
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Sets the name of the {\tt ESMF\_Array}.  
!     Note: Unlike most other ESMF objects there are
!     very few items which can be changed once an {\tt ESMF\_Array} 
!     is created.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[name]}]
!           The array name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

      integer :: status                           ! Error status
      logical :: rcpresent                        ! Return code present

      ! Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif

      if (present(name)) then
          call c_ESMC_SetName(array, "Array", name, status)
          if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return
      endif

      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArraySet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayValidate"
!BOP
! !IROUTINE: ESMF_ArrayValidate - Check validity of Array object
!
! !INTERFACE:
      subroutine ESMF_ArrayValidate(array, options, rc)
!
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Verify an {\tt ESMF\_Array} is internally consistent.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           The standard validation options.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "brief"

       ! Simple validity checks
       if (array%this .eq. ESMF_NULL_POINTER) then
          ! TODO: this will always return.  
          if (ESMF_LogFoundError(ESMF_RC_OBJ_BAD, &
                                ESMF_CONTEXT, rc)) return
       endif

       if(present(options)) then
           !call c_ESMC_ArrayValidate(array, options, status) 
       else
           !call c_ESMC_ArrayValidate(array, defaultopts, status) 
       endif

       !if (status .ne. ESMF_SUCCESS) then
       !  print *, "Array validate error"
       !  return
       !endif

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayValidate

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayWrite"
!BOP
! !IROUTINE: ESMF_ArrayWrite
!
! !INTERFACE:
      subroutine ESMF_ArrayWrite(array, iospec, filename, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      type(ESMF_IOSpec), intent(in), optional :: iospec
      character(len=*), intent(in), optional :: filename
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to write data to persistent storage in a variety of formats.  
!      (see writerestart/restore for quick data dumps.)  Details of I/O 
!      options specified with an {\tt ESMF\_IOSpec}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[filename]}]
!           The file name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

       character (len=16) :: defaultopts      ! default write options 
       character (len=16) :: defaultfile      ! default filename
       integer :: status                      ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "singlefile"
       defaultfile = "datafile"

       if(present(filename)) then
           call c_ESMC_ArrayWrite(array, defaultopts, trim(filename), status) 
       else
           call c_ESMC_ArrayWrite(array, defaultopts, trim(defaultfile), status) 
       endif
       if (ESMF_LogMsgFoundError(status, &
                                 ESMF_ERR_PASSTHRU, &
                                 ESMF_CONTEXT, rc)) return

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayWrite


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_ArrayWriteRestart"
!BOPI
! !IROUTINE: ESMF_ArrayWriteRestart
!
! !INTERFACE:
      subroutine ESMF_ArrayWriteRestart(array, iospec, rc)
!
! !ARGUMENTS:
      type(ESMF_Array):: array 
      type(ESMF_IOSpec), intent(in), optional :: iospec
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!      Used to save all data to disk as quickly as possible.  
!      (see read/write for other options).  Internally this routine uses the
!      same I/O interface as read/write, but the default options are to
!      select the fastest way to save data to disk.
!     
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI
! !REQUIREMENTS:

!
! TODO: code goes here
!
        if (present(rc)) rc = ESMF_FAILURE

        end subroutine ESMF_ArrayWriteRestart


!------------------------------------------------------------------------------


       end module ESMF_ArrayMod

