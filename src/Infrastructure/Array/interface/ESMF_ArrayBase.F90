! $Id: ESMF_ArrayBase.F90,v 1.12 2003/08/01 22:46:44 jwolfe Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2003, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the GPL.
!
!==============================================================================
!
!     ESMF Array module
      module ESMF_ArrayBaseMod
!
!==============================================================================
!
! This file contains the Array class definition and all Array
! class methods which are *not* generated by macro.  
! See ESMF_ArrayExpand.F90 for the macro-generated interfaces.
!
!------------------------------------------------------------------------------
!BOP
! !MODULE: ESMF_ArrayMod - Manage data arrays uniformly between F90 and C++     
!
! !DESCRIPTION:
!
! The code in this file implements the {\tt Array} class and 
!  associated functions and subroutines.  
!
! C and C++ arrays are simple pointers to memory.
! Fortran arrays contain shape and stride definitions and are strongly
! typed.  To enable interoperability between the languages the C++ code
! must be able to obtain this information from the Fortran description
! (which is called the "dope vector" in Fortran), either through a priori
! knowledge or through query.
!
!------------------------------------------------------------------------------
! !USES:
      use ESMF_BaseMod
      use ESMF_IOMod
      use ESMF_DELayoutMod
      use ESMF_GridMod
      use ESMF_DataMapMod
      use ESMF_LocalArrayMod
      implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private
!------------------------------------------------------------------------------
!     ! ESMF_Array
!
!     ! Array data type.  All information is kept on the C++ side inside
!     ! the class structure.

      type ESMF_Array
      sequence
        type(ESMF_Pointer) :: this       ! opaque pointer to the C++ class data
      end type

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
      public ESMF_CopyFlag, ESMF_DATA_COPY, ESMF_DATA_REF
      public ESMF_ArraySpec, ESMF_Array
!------------------------------------------------------------------------------

! !PUBLIC MEMBER FUNCTIONS:

 
      public ESMF_ArraySpecInit
      public ESMF_ArraySpecGet

      public ESMF_ArrayGet, ESMF_ArrayGetName

      public ESMF_ArraySetAxisIndex, ESMF_ArrayGetAxisIndex  
      public ESMF_ArrayGetAllAxisIndices

      public ESMF_ArrayRedist, ESMF_ArrayRegrid, ESMF_ArrayHalo

      public ESMF_ArrayAllGather, ESMF_ArrayGather, ESMF_ArrayScatter
      !public ESMF_ArrayReduce, ESMF_ArrayAllReduce
      !public ESMF_ArrayBroadcast, ESMF_ArrayAlltoAll

      public ESMF_ArrayCheckpoint
      public ESMF_ArrayRestore
      public ESMF_ArrayWrite
      public ESMF_ArrayRead
 
      public ESMF_ArrayValidate
      public ESMF_ArrayPrint
!EOP


!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id: ESMF_ArrayBase.F90,v 1.12 2003/08/01 22:46:44 jwolfe Exp $'
!
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================
!BOP
! !IROUTINE: ESMF_ArrayHalo - halo a distributed array
!
! !INTERFACE:
      interface ESMF_ArrayHalo

! !PRIVATE MEMBER FUNCTIONS:
          module procedure ESMF_ArrayHaloNew
          module procedure ESMF_ArrayHaloDeprecated

! !DESCRIPTION:
!     This interface provides both the revised entry point for
!      calling Halo on an {\tt ESMF\_Array} object, and temporarily
!      for backwards compatibility an older interface into the same code.

!EOP
      end interface

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayRedist - redistribute a distributed array
!
! !INTERFACE:
      interface ESMF_ArrayRedist

! !PRIVATE MEMBER FUNCTIONS:
          module procedure ESMF_ArrayRedistNew
          module procedure ESMF_ArrayRedistDeprecated

! !DESCRIPTION:
!     This interface provides both the revised entry point for
!      calling Redistribute on an {\tt ESMF\_Array} object, and temporarily
!      for backwards compatibility an older interface into the same code.

!EOP
      end interface

!==============================================================================

      contains

!==============================================================================


!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArraySetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArraySetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to annotate an Array with information used to manage halo
!      regions.
!
!EOP

        integer :: status
        integer :: i

        ! call c routine to add index
        if (present(totalindex)) then
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min - 1
            totalindex(i)%max = totalindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_TOTAL, &
                                        totalindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min - 1
            compindex(i)%max = compindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min - 1
            exclindex(i)%max = exclindex(i)%max - 1
          enddo
          call c_ESMC_ArraySetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status
        end subroutine ESMF_ArraySetAxisIndex

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an Array.
!
!EOP
! !REQUIREMENTS:

        integer :: status, i

        ! call c routine to get index
        if (present(totalindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_TOTAL, totalindex,&
                                        status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          call c_ESMC_ArrayGetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status

        end subroutine ESMF_ArrayGetAxisIndex

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayGetAllAxisIndices - get all AIs associated with a Grid
!
! !INTERFACE:
      subroutine ESMF_ArrayGetAllAxisIndices(array, grid, totalindex, &
                                             compindex, exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array 
      type(ESMF_Grid), intent(in) :: grid
      type(ESMF_AxisIndex), dimension(:,:), pointer, optional :: totalindex
      type(ESMF_AxisIndex), dimension(:,:), pointer, optional :: compindex
      type(ESMF_AxisIndex), dimension(:,:), pointer, optional :: exclindex
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!   Used to retrieve the index annotations from all {\tt ESMF\_Array}s
!    associated with a {\tt ESMF\_Grid}.  This computes the values
!    instead of broadcasting them.
!
!EOP
! !REQUIREMENTS:

      integer :: status, nDEs, i, j
      type(ESMF_AxisIndex), dimension(:,:), pointer :: globalindex
      type(ESMF_DELayout) :: layout

      ! get layout from the grid in order to get the number of DEs
      call ESMF_GridGetDELayout(grid, layout, status)
      call ESMF_DELayoutGetNumDEs(layout, nDEs, status)

      ! allocate globalindex array and get all of them from the grid
      allocate(globalindex(nDEs,ESMF_MAXGRIDDIM), stat=status)
      call ESMF_GridGetAllAxisIndex(grid, globalindex, status)

      ! call c routine to get indices
      call c_ESMC_ArrayGetAllAxisIndices(array, globalindex, nDEs, &
                                         totalindex, &
                                         compindex, exclindex, status)

      ! translate from C++ to F90
      if (present(totalindex)) then
        do j = 1,ESMF_MAXGRIDDIM
          do i = 1,nDEs
            totalindex(i,j)%min = totalindex(i,j)%min + 1
            totalindex(i,j)%max = totalindex(i,j)%max + 1
          enddo
        enddo
      endif
          
      if (present(compindex)) then
        do j = 1,ESMF_MAXGRIDDIM
          do i = 1,nDEs
            compindex(i,j)%min = compindex(i,j)%min + 1
            compindex(i,j)%max = compindex(i,j)%max + 1
          enddo
        enddo
      endif
          
      if (present(exclindex)) then
        do j = 1,ESMF_MAXGRIDDIM
          do i = 1,nDEs
            exclindex(i,j)%min = exclindex(i,j)%min + 1
            exclindex(i,j)%max = exclindex(i,j)%max + 1
          enddo
        enddo
      endif
          
      status = ESMF_SUCCESS

      if (present(rc)) rc = status

      end subroutine ESMF_ArrayGetAllAxisIndices


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayRegrid(srcarray, dstarray, srcgrid, srcdatamap, &
                                  dstgrid, dstdatamap, parentlayout, async, rc) 
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: srcarray
      type(ESMF_Array), intent(inout) :: dstarray
      type(ESMF_Grid), intent(in) :: srcgrid
      type(ESMF_DataMap), intent(in) :: srcdatamap
      type(ESMF_Grid), intent(in) :: dstgrid
      type(ESMF_DataMap), intent(in) :: dstdatamap
      type(ESMF_DELayout) :: parentlayout
      type(ESMF_Async), intent(inout), optional :: async
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to Regrid data in an Array.
!
!     \begin{description}
!     \item [srcarray]
!           {\tt ESMF\_Array} containing source data.
!     \item [dstarray]
!           {\tt ESMF\_Array} containing results.
!     \item [srcgrid]
!           {\tt ESMF\_Grid} which corresponds to how the data in the
!           source array has been decomposed.  
!     \item [srcdatamap]
!           {\tt ESMF\_DataMap} which describes how the array maps to
!           the specified source grid.
!     \item [dstgrid]
!           {\tt ESMF\_Grid} which corresponds to how the data in the
!           destination array should be decomposed.  
!     \item [dstdatamap]
!           {\tt ESMF\_DataMap} which describes how the array should map to
!           the specified destination grid.
!     \item [parentlayout]
!           {\tt ESMF\_Layout} which encompasses both {\tt ESMF\_Field}s,
!           most commonly the layout
!           of the Coupler if the regridding is inter-component, but could
!           also be the individual layout for a component if the
!           regridding is intra-component.
!     \item [{[async]}]
!           Optional argument which specifies whether the operation should
!           wait until complete before returning or return as soon
!           as the communication between {\tt DE}s has been scheduled.
!           If not present, default is to do synchronous communications.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!
!     \end{description}
!

!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_rank_trans
        integer :: size_decomp

! TODO: add code here
! TODO: query grids and datamaps to get what is needed for redist

        ! assume failure until success certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! query things implemented in F90 and pass them to the C++ side,
        !  assume we can directly reference members in the class.
        !call c_ESMC_ArrayRegrid()
        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayRegrid returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayRegrid

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayRedistNew(srcarray, dstarray, srcgrid, srcdatamap, &
                                  dstgrid, dstdatamap, parentlayout, async, rc) 
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: srcarray
      type(ESMF_Array), intent(inout) :: dstarray
      type(ESMF_Grid), intent(in) :: srcgrid
      type(ESMF_DataMap), intent(in) :: srcdatamap
      type(ESMF_Grid), intent(in) :: dstgrid
      type(ESMF_DataMap), intent(in) :: dstdatamap
      type(ESMF_DELayout) :: parentlayout
      type(ESMF_Async), intent(inout), optional :: async
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to redistribute an Array.
!
!     \begin{description}
!     \item [srcarray]
!           {\tt ESMF\_Array} containing source data.
!     \item [dstarray]
!           {\tt ESMF\_Array} containing results.
!     \item [srcgrid]
!           {\tt ESMF\_Grid} which corresponds to how the data in the
!           source array has been decomposed.  
!     \item [srcdatamap]
!           {\tt ESMF\_DataMap} which describes how the array maps to
!           the specified source grid.
!     \item [dstgrid]
!           {\tt ESMF\_Grid} which corresponds to how the data in the
!           destination array should be decomposed.  
!     \item [dstdatamap]
!           {\tt ESMF\_DataMap} which describes how the array should map to
!           the specified destination grid.
!     \item [parentlayout]
!           {\tt ESMF\_Layout} which encompasses both {\tt ESMF\_Field}s,
!           most commonly the layout
!           of the Coupler if the regridding is inter-component, but could
!           also be the individual layout for a component if the
!           regridding is intra-component.
!     \item [{[async]}]
!           Optional argument which specifies whether the operation should
!           wait until complete before returning or return as soon
!           as the communication between {\tt DE}s has been scheduled.
!           If not present, default is to do synchronous communications.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!
!     \end{description}
!

!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_rank_trans
        integer :: size_decomp

! TODO: add code here
! TODO: query grids and datamaps to get what is needed for redist

        ! assume failure until success certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! query things implemented in F90 and pass them to the C++ side,
        !  assume we can directly reference members in the class.
        !call c_ESMC_ArrayRedist()
        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayRedist returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayRedistNew

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayRedistDeprecated(array, layout, global_start, &
                                  global_dimlengths, rank_trans, olddecompids, &
                                  decompids, redistarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      type(ESMF_DELayout) :: layout
      integer, dimension(:), intent(in) :: global_start
      integer, dimension(:), intent(in) :: global_dimlengths
      integer, dimension(:), intent(in) :: rank_trans
      integer, dimension(:), intent(in) :: olddecompids
      integer, dimension(:), intent(in) :: decompids
      type(ESMF_Array), intent(in) :: redistarray
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to redistribute an Array.
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_rank_trans
        integer :: size_decomp
! TODO: create a subroutine that takes a grid as an argument instead of some of
!       these
! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

! call c routine to query index
        size_rank_trans = size(rank_trans)
        size_decomp = size(decompids)
        call c_ESMC_ArrayRedist(array, layout, global_start, global_dimlengths, &
                                rank_trans, size_rank_trans, olddecompids, &
                                decompids, size_decomp, redistarray, status)
        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayRedist returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayRedistDeprecated

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayHaloNew(array, grid, datamap, async, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array
      type(ESMF_Grid), intent(in) :: grid
      type(ESMF_DataMap), intent(in), optional :: datamap
      type(ESMF_Async), intent(inout), optional :: async
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!     Perform a {\tt Halo} operation over the data
!     in an {\tt ESMF\_Array}.  This routine updates the data
!     inside the {\tt ESMF\_Array} in place.  It uses the {\tt ESMF\_Grid}
!     and {\tt ESMF\_DataMap} as a template to understand how this
!     {\tt ESMF\_Array} relates to {\tt ESMF\_Array}s on other {\tt DE}s.
!
!     \begin{description}
!     \item [array]
!           {\tt ESMF\_Array} containing data to be halo'd.
!     \item [grid]
!           {\tt ESMF\_Grid} which matches how this array was decomposed.
!     \item [datamap]
!           {\tt ESMF\_DataMap} which matches how this array relates to the
!           given grid.
!     \item [{[async]}]
!           Optional argument which specifies whether the operation should
!           wait until complete before returning or return as soon
!           as the communication between {\tt DE}s has been scheduled.
!           If not present, default is to do synchronous communications.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!
!     \end{description}
!
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_decomp, size_AI
        integer, dimension(ESMF_MAXGRIDDIM) :: decompids
        integer :: gridrank
        type(ESMF_DELayout) :: layout
        integer :: i

! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif
 
! get layout, decompids from grid
        call ESMF_GridGetDELayout(grid, layout, status)
        !call ESMF_GridGet(grid, decompids=decompids, rc=status)
        !call ESMF_GridGet(grid, dimnum=size_decomp, rc=status)
        call ESMF_DataMapGet(datamap, gridrank=size_decomp, rc=status)

! call c routine to halo
        call c_ESMC_ArrayHalo(array, layout, decompids, size_decomp, status)
        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayHalo returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayHaloNew

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayHaloDeprecated(array, layout, &
                                          AI_global, global_dimlens, &
                                          decompids, periodic, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      type(ESMF_DELayout) :: layout
      type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_global
      integer, dimension(:), intent(in) :: global_dimlens
      integer, dimension(:), intent(in) :: decompids
      type(ESMF_Logical), dimension(:), intent(in) :: periodic
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to halo an Array.
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_decomp

! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif
 
! call c routine to halo
        size_decomp = size(decompids)
        call c_ESMC_ArrayHalo(array, layout, AI_global, global_dimlens, &
                              decompids, size_decomp, periodic, status)
        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayHalo returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayHaloDeprecated

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayAllGather(array, layout, decompids, &
                                     global_dimlengths, array_out, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array
      type(ESMF_DELayout), intent(in) :: layout
      integer, dimension(:), intent(in) :: decompids
      integer, dimension(:), intent(in) :: global_dimlengths
      type(ESMF_Array), intent(out) :: array_out
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to gather a distributed Array into a global Array on all DEs.
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_decomp
        integer :: i

! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif
 
! call c routine to allgather
        size_decomp = size(decompids)
        call c_ESMC_ArrayAllGather(array, layout, decompids, size_decomp, &
                                   global_dimlengths, array_out, status)

        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayAllGather returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayAllGather

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayGather(array, layout, decompids, &
                                  global_dimlengths, deid, array_out, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array
      type(ESMF_DELayout), intent(in) :: layout
      integer, dimension(:), intent(in) :: decompids
      integer, dimension(:), intent(in) :: global_dimlengths
      integer, intent(in) :: deid
      type(ESMF_Array), intent(out) :: array_out
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to gather a distributed Array into a global Array on all DEs.
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_decomp, size_AI
        integer :: i

! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif
 
! call c routine to allgather
        size_decomp = size(decompids)
        call c_ESMC_ArrayGather(array, layout, decompids, size_decomp, &
                                global_dimlengths, deid, array_out, status)

        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayGather returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayGather

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayScatter(array, layout, decompids, deid, array_out, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array
      type(ESMF_DELayout), intent(in) :: layout
      integer, dimension(:), intent(in) :: decompids
      integer, intent(in) :: deid
      type(ESMF_Array), intent(out) :: array_out
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Used to scatter a single Array into a distributed Array across all DEs.
!
!
!EOP
! !REQUIREMENTS:
        integer :: status         ! local error status
        logical :: rcpresent      ! did user specify rc?
        integer :: size_decomp
        integer :: i

! initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif
 
! call c routine to allgather
        size_decomp = size(decompids)
        call c_ESMC_ArrayScatter(array, layout, decompids, size_decomp, &
                                 deid, array_out, status)

        if (status .ne. ESMF_SUCCESS) then
          print *, "c_ESMC_ArrayScatter returned error"
          return
        endif

! set return code if user specified it
        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayScatter

!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayReorder(array, newarrayspec, newarray, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array 
      type(ESMF_ArraySpec), intent(in) :: newarrayspec
      type(ESMF_Array):: newarray   
      integer, intent(out), optional :: rc       
!
! !DESCRIPTION:
!      Used to alter the local memory ordering (layout) of this Array.
!
!  !TODO: remove this note before generating user documentation
!
!      (i am not sure this makes sense now, or that the routine should be
!      in this class.  but i am leaving this here as a reminder that we
!      might need some low level reorder functions.  maybe the argument
!      should be another array or an arrayspec which describes what you
!      want, and the input array is what exists, and this routine can then
!      make one into the other.   is this a type of create?  or is this
!      a copy?)
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
        end subroutine ESMF_ArrayReorder


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
     subroutine ESMF_ArraySpecInit(as, rank, type, kind, rc)
!
!
! !ARGUMENTS:
     type(ESMF_ArraySpec), intent(inout) :: as
     integer, intent(in) :: rank
     type(ESMF_DataType), intent(in) :: type
     type(ESMF_DataKind), intent(in) :: kind
     integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!  Creates a description of the data -- the type, the dimensionality, etc.  
!  This specification can be
!  used in an ArrayCreate call with data to create a full Array.
!    
!  The arguments are:
!  \begin{description}
!
!  \item[arrayspec]
!    Uninitialized array spec.
!
!  \item[rank]
!    Array rank (dimensionality, 1D, 2D, etc).  Maximum allowed is 5D.
!
!  \item[type]
!    Array type.  Valid types include {\tt ESMF\_DATA\_INTEGER},
!    {\tt ESMF\_DATA\_REAL}, {\tt ESMF\_DATA\_LOGICAL}, 
!    {\tt ESMF\_DATA\_CHARACTER}.
!
!  \item[kind]
!    Array kind.  Valid kinds include {\tt ESMF\_KIND\_I4}, 
!    {\tt ESMF\_KIND\_I8}, {\tt ESMF\_KIND\_R4}, {\tt ESMF\_KIND\_R8}, 
!    {\tt ESMF\_KIND\_C8}, {\tt ESMF\_KIND\_C16}. 
!
!   \item[[rc]]
!    Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!
!   \end{description}
!
!EOP
! !REQUIREMENTS:


        ! Local vars
        integer :: status                        ! local error status
        logical :: rcpresent                     ! did user specify rc?

        ! Initialize pointer
        status = ESMF_FAILURE
        rcpresent = .FALSE.

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Set arrayspec contents
      
        as%rank = rank   
        as%type = type
        as%kind = kind

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArraySpecInit



!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
! 
! Query for information from the array.
!
!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayGet(array, rank, type, kind, counts, &
                               lbounds, ubounds, strides, base, name, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      integer, intent(out), optional :: rank
      type(ESMF_DataType), intent(out), optional :: type
      type(ESMF_DataKind), intent(out), optional :: kind
      integer, dimension(:), intent(out), optional :: counts
      integer, dimension(:), intent(out), optional :: lbounds
      integer, dimension(:), intent(out), optional :: ubounds
      integer, dimension(:), intent(out), optional :: strides
      type(ESMF_Pointer), intent(out), optional :: base
      character(len=ESMF_MAXSTR), intent(out), optional :: name
      integer, intent(out), optional :: rc             

!
! !DESCRIPTION:
!      Returns information about the array.  For queries where the caller
!      only wants a single value, specify the argument by name.
!      All the arguments after the array input are optional to facilitate this.
!
!EOP
! !REQUIREMENTS:


      integer :: status ! Error status
      logical :: rcpresent ! Return code present
      integer :: lrank  ! Local use to get rank

      ! Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif


      if (present(rank)) then
         call c_ESMC_ArrayGetRank(array, rank, status)
         ! TODO: test status
      endif

      if (present(type)) then
         call c_ESMC_ArrayGetType(array, type, status)
      endif

      if (present(kind)) then
         call c_ESMC_ArrayGetKind(array, kind, status)
      endif

      if (present(counts)) then
         call c_ESMC_ArrayGetRank(array, lrank, status)
         call c_ESMC_ArrayGetLengths(array, lrank, counts, status)
      endif

   
      ! TODO: add these methods
      !integer, dimension(:), intent(out), optional :: lbounds
      !integer, dimension(:), intent(out), optional :: ubounds
      !integer, dimension(:), intent(out), optional :: strides
      !type(ESMF_Pointer), intent(out), optional :: base

      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGet

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayGetName - Retrieve the name of a Array
!
! !INTERFACE:
      subroutine ESMF_ArrayGetName(array, name, rc)

!
! !ARGUMENTS:
      type(ESMF_Array), intent(in) :: array
      character (len = *), intent(out) :: name
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!      Returns the name of the array.  If the array was created without
!      specifying a name, the framework will have assigned it a unique one.
!
!EOP
! !REQUIREMENTS: FLD1.5.1, FLD1.7.1

      integer :: status                           ! Error status
      logical :: rcpresent                        ! Return code present

!     Initialize return code; assume failure until success is certain
      status = ESMF_FAILURE
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
      endif

      ! TODO: add an interface to the C code here
      !call c_ESMC_ArrayGetName(array, name, status)
      !if(status .NE. ESMF_FAILURE) then
      !  print *, "ERROR in ESMF_ArrayGetName"
      !  return
      !endif

      name = "default array name"

      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayGetName


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArraySpecGet(as, rank, type, kind, rc)
!
! !ARGUMENTS:
      type(ESMF_ArraySpec), intent(in) :: as
      integer, intent(out), optional :: rank
      type(ESMF_DataType), intent(out), optional :: type
      type(ESMF_DataKind), intent(out), optional :: kind
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!  Return information about the contents of a ArraySpec type.
!
!  The arguments are:
!  \begin{description}
!
!  \item[as]
!    An {\tt ArraySpec} object.
!
!  \item[rank]
!    Array rank (dimensionality, 1D, 2D, etc).  Maximum allowed is 5D.
!
!  \item[type]
!    Array type.  Valid types include {\tt ESMF\_DATA\_INTEGER},
!    {\tt ESMF\_DATA\_REAL}, {\tt ESMF\_DATA\_LOGICAL}, 
!    {\tt ESMF\_DATA\_CHARACTER}.
!
!  \item[kind]
!    Array kind.  Valid kinds include {\tt ESMF\_KIND\_I4}, 
!    {\tt ESMF\_KIND\_I8}, {\tt ESMF\_KIND\_R4}, {\tt ESMF\_KIND\_R8}, 
!    {\tt ESMF\_KIND\_C8}, {\tt ESMF\_KIND\_C16}. 
!
!   \item[[rc]]
!    Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!
!   \end{description}
!
!EOP

        ! Local vars
        integer :: i
        integer :: status                        ! local error status
        logical :: rcpresent                     ! did user specify rc?

        ! Initialize return code; assume failure until success is certain
        status = ESMF_FAILURE
        rcpresent = .FALSE.
        if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_FAILURE
        endif

        ! Get arrayspec contents
      
        if(present(rank)) rank = as%rank
        if(present(type)) type = as%type
        if(present(kind)) kind = as%kind

        if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArraySpecGet


!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!
! This section is I/O for Arrays
!
!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayCheckpoint(array, iospec, rc)
!
! !ARGUMENTS:
      type(ESMF_Array):: array 
      type(ESMF_IOSpec), intent(in), optional :: iospec
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!      Used to save all data to disk as quickly as possible.  
!      (see Read/Write for other options).  Internally this routine uses the
!      same I/O interface as Read/Write, but the default options are to
!      select the fastest way to save data to disk.
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
        end subroutine ESMF_ArrayCheckpoint


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      function ESMF_ArrayRestore(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayRestore
!
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              ! array name to restore
      type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
      integer, intent(out), optional :: rc                 ! return code
!
! !DESCRIPTION:
!      Used to reinitialize
!      all data associated with a Array from the last call to Checkpoint.
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
        type (ESMF_Array) :: a 

!       this is just to shut the compiler up
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayRestore = a 
 
        end function ESMF_ArrayRestore


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      subroutine ESMF_ArrayWrite(array, iospec, filename, rc)
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      type(ESMF_IOSpec), intent(in), optional :: iospec
      character(len=*), intent(in), optional :: filename
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to write data to persistent storage in a variety of formats.  
!      (see Checkpoint/Restore for quick data dumps.)  Details of I/O 
!      options specified in the IOSpec derived type. 
!
!
!EOP
! !REQUIREMENTS:

       character (len=16) :: defaultopts      ! default write options 
       character (len=16) :: defaultfile      ! default filename
       integer :: status                      ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "singlefile"
       defaultfile = "datafile"

       if(present(filename)) then
           call c_ESMC_ArrayWrite(array, defaultopts, trim(filename), status) 
       else
           call c_ESMC_ArrayWrite(array, defaultopts, trim(defaultfile), status) 
       endif

       if (status .ne. ESMF_SUCCESS) then
         print *, "Array write error"
         return
       endif

!      set return values
       if (rcpresent) rc = ESMF_SUCCESS

        end subroutine ESMF_ArrayWrite


!------------------------------------------------------------------------------
!BOP
! !INTERFACE:
      function ESMF_ArrayRead(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_Array) :: ESMF_ArrayRead
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              ! array name to read
      type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
      integer, intent(out), optional :: rc                 ! return code
!
! !DESCRIPTION:
!      Used to read data from persistent storage in a variety of formats.
!
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
        type (ESMF_Array) :: a

!       this is just to shut the compiler up
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_ArrayRead = a 
 
        end function ESMF_ArrayRead


!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayValidate - Check validity of Array object
!
! !INTERFACE:
      subroutine ESMF_ArrayValidate(array, options, rc)
!
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!      Routine to print information about a array.
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "brief"

       ! Simple validity checks
       if (array%this .eq. ESMF_NULL_POINTER) then
           print *, "Array not initialized or Destroyed"
           return 
       endif

       if(present(options)) then
           !call c_ESMC_ArrayValidate(array, options, status) 
       else
           !call c_ESMC_ArrayValidate(array, defaultopts, status) 
       endif

       !if (status .ne. ESMF_SUCCESS) then
       !  print *, "Array validate error"
       !  return
       !endif

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayValidate


!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_ArrayPrint - Print contents of an Array object
!
! !INTERFACE:
      subroutine ESMF_ArrayPrint(array, options, rc)
!
!
! !ARGUMENTS:
      type(ESMF_Array) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!      Routine to print information about a array.
!
!EOP
! !REQUIREMENTS:

!
! TODO: code goes here
!
       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume failure until success is certain
       status = ESMF_FAILURE
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_FAILURE
       endif

       defaultopts = "brief"

       if(present(options)) then
           call c_ESMC_ArrayPrint(array, options, status) 
       else
           call c_ESMC_ArrayPrint(array, defaultopts, status) 
       endif

       if (status .ne. ESMF_SUCCESS) then
         print *, "Array print error"
         return
       endif

!      set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_ArrayPrint


       end module ESMF_ArrayBaseMod

