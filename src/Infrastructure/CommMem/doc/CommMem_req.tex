% $Id: CommMem_req.tex,v 1.6 2002/07/23 20:42:12 vbalaji Exp $

%===============================================================================
% Requirements may be itemized under a main topic:
%===============================================================================
%===============================================================================
\req{Setup}

Setup functions are run during the initialization phase of an ESMF
application and its components. They are not required to be scalable
or coded for optimal performance. They may require knowledge of (or
the ability to parse) higher-level constructs, e.g \textbf{DistGrid}.

\sreq{Setup communication map for a DistGrid}

Given a \textbf{DistGrid}, the ESMF setup phase will compute and store
an optimal memory strategy and communication pattern.

\begin{reqlist}
  {\bf Priority:} Priority 1 \\
  {\bf Source:}  MIT \\
  {\bf Status:}  \\
  {\bf Verification:} Unit tests, EVA tests \\
  {\bf Notes:} The optimal ``memory strategy'' might include hints on
  whether to allocate memory from a pool shared between PEs. The
  optimal communication design might include optimal assignment of
  domains to PEs, advocating the use of shared memory where
  appropriate, and a pre-computed and stored buffering pattern where
  message-passing is indicated.
\end{reqlist}

\sreq{Setup communication map for a Remapping}

Given a \textbf{Remapping} between \textbf{Distgrid}s, the ESMF setup
phase will compute and store an optimal memory strategy and
communication pattern. Domains may be reassigned for the individual
\textbf{DistGrid}s at this stage to optimize the layout for remapping.

\begin{reqlist}
{\bf Priority:} Priority 1 \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
\end{reqlist}

\sreq{Setup communication map for grid collectives}

Collective operations (e.g global reductions, global gather, global
barrier) have been defined for a \textbf{DistGrid}. Different
buffering and communication strategies may have to be used for
default, performance-critical, and bit-reproducible versions of these
routines.

\ssreq{Setup performance-critical collectives}

Given a \textbf{Distgrid}, the ESMF setup
phase will compute and store a communication map for
performance-critical grid collectives.

\begin{reqlist}
{\bf Priority:} Priority 1 \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
\end{reqlist}

\ssreq{Setup bit-reproducible collectives}

Given a \textbf{Distgrid}, the ESMF setup
phase will compute and store a communication map for
bit-reproducible grid collectives.

\begin{reqlist}
{\bf Priority:} Priority 1 \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
\end{reqlist}

\sreq{Setup performance profiling}

The \textbf{CMK} operations are all instrumented for memory and
communication profiling. The setup phase will include mechanisms for
turning on and off the available options for profiling, and assigning
a reporting mechanism (e.g write to stdout).

\begin{reqlist}
{\bf Priority:} Priority 1 \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
\end{reqlist}

\sreq{Determine platform attributes}

Primitives for determining key attributes of the computational
platform are required.
These include
\begin{itemize}
\item The MAP (mnode, anode, pnode layout);
\item Shared and distributed memory profiles (rated latency and
  bandwidth for different pipes, size of available memory pools);
\item Availability of low-level APIs.
\end{itemize}

\begin{reqlist}
{\bf Priority:} Priority ? \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
\end{reqlist}

\ssreq{Heterogeneous platform}

Platform attributes for multiple platforms must be available for
heterogeneous applications.

\sreq{Determine PE attributes}

Primitives for determining key PE attributes are required.
These include
\begin{itemize}
\item Identifier of the PE.
\item Identifiers of the memory and communication groupings a PE
belongs to e.g. m-node.1, a-node.1, p-node.3 etc...
\item Identifiers of the physical resources (CPU, memory, storage) associated with a PE.
\item Identifiers of the virtual attributes associated with a PE e.g. coordinate in a PElayout.
\end{itemize}

\begin{reqlist}
{\bf Priority:} Priority ? \\
{\bf Source:}  MIT \\
{\bf Status:}  \\
{\bf Verification:} Unit tests, EVA tests \\
{\bf Notes:}
In order to determine what resources to use to communicate between data domains 
{\bf \shortname} needs to know information about the PE associated with the
data domains. The binding of data domains to PE's is driven by the Control element
(if it exists!) and by components. The {\bf \shortname} needs to determine what
bindings were made.
\end{reqlist}

\req{Communication primitives}

% \sreq{Point-to-point primitives}

% \ssreq{Non-blocking send}
% A performance-critical non-blocking send operation to a specified
% target is required.

% \ssreq{Non-blocking receive}
% A performance-critical non-blocking receive operation from a specified
% source is required.

% \ssreq{Non-blocking receive from unspecific source}
% A performance-critical non-blocking receive operation from an unspecified
% source is required.

% \ssreq{Multiple outstanding messages}

% Both send and receive phases must be capable of tolerating multiple
% outstanding messages between source-target pairs, up to some specified
% queue limit.

% \ssreq{Wait}

% A performance-critical wait operation for a specified message must be present.

% \ssreq{Waitall}

% A performance-critical wait operation for all outstanding messages must be present.

% \ssreq{Barrier}

% A point-to-point barrier operation is required.

\sreq{Collective primitives}

\ssreq{All-to-all}

A general, non-blocking all-to-all collective communication operation
shall be the basic ESMF message-passing pathway.

\ssreq{Multiple outstanding messages}

Both send and receive phases must be capable of tolerating multiple
outstanding messages between source-target pairs, up to some specified
queue limit.

\ssreq{Collective wait}

There shall be a wait operation for the basic ESMF collective
communication pathway to ensure all outstanding \emph{local} messages
are completed.

\ssreq{Broadcast}

A performance-critical broadcast operation is required.

\ssreq{Sum}

A performance-critical sum operation is required.

\ssreq{Barrier}

A global barrier operation is required to be provided by ESMF, though
its use in performance-critical code sections is not recommended.

\ssreq{Min-max}

Other global reduction operations are not required to be performance-critical.

\ssreq{Allgather}

A performance-critical allgather operation is required.

\ssreq{Scatter}

A performance-critical scatter operation is required.

\sreq{Performance profiling}

All the communication operations listed above will be instrumented by
ESMF for performance using very lightweight mechanisms. Various times
will be recorded at runtime, and results collated in a post-execution
phase. Final output will show statistics across PEs, as well as
optionally on a per-message basis (though for climate runs the
internal storage required for this may be prohibitive).

\ssreq{Time spent in communication primitives}
\ssreq{Time spent in collectives}
\ssreq{Time spent waiting for message completion}
\ssreq{Message lengths}
\ssreq{Internal buffer usage}
\ssreq{Use of underlying APIs}

\ssreq{Calipers}

It shall be possible during the setup phase to set caliper points
around a code section, i.e:

% \begin{verbatim}
% ESMF_tick('radiation')
% ...radiation code
% ESMF_tock('radiation')
% \end{verbatim}

to have the reports above narrowed to this code section. The number of
caliper pairs is limited to a pre-specifed value.

\sreq{Bindings}

\ssreq{Default bindings}

The default binding for message-passing shall be MPI 1.2 and for
shared memory OpenMP 1.0. Other bindings will be made available on
platforms where they show advantages in terms of performance, or code
clarity at little cost. The implementation priorities for non-default
bindings will in general be lower (later). ESMF is not required to run
in parallel on platforms which support neither MPI 1.2 nor OpenMP 1.0.

The requirement for other bindings is really asking for a certain
implementation. Arguably the requirement could be stated as ``ESMF
performance and resource utilization on a system which has shmem
pointers available must be competitive to an approach that binds ESMF
communication directly to shmem pointers reads and writes (with
appropriate memory instructions inserted to reconcile memory
inconsistency).''

\ssreq{System V IPC}

System V IPC bindings for message passing shall be optionally
available on appropriate platforms.

\ssreq{SHMEM}

SHMEM bindings for message passing shall be optionally
available on appropriate platforms.

\ssreq{Posix threads}

Posix bindings for message passing shall be optionally
available on appropriate platforms.

\ssreq{MPI 2.0}

MPI 2.0 bindings for message passing shall be optionally
available on appropriate platforms.

\ssreq{Extensibility}

Extension to allow bindings of performance-critical communication
primitives to systems like LAPI, elan3, Myrinet GM, raw ethernet and
to Infiniband and VI Architecture like systems should be possible.

\req{Memory management}

For various operations being implemented for ESMF, there is need to
control where memory is allocated (e.g heap, stack, shared arena,
etc). For this reason we will define some apparatus for managing
``ESMF memory'' which will have the required attributes for optimal
use of ESMF primitives.

\sreq{Preallocate ESMF memory}

It shall be possible during the setup phase to declare the size of the
ESMF memory pool that is anticipated for use. Subsequent requests for
ESMF memory will operate out of this pool without needing system
calls.

\sreq{Allocating ESMF memory}

It shall be possible to request ESMF memory of a specified length for
a data object.

\ssreq{Stack objects? Automatic objects? Persistent objects?}

\sreq{Deallocating ESMF memory}

It shall be possible to free ESMF memory for a data object.

\sreq{Native memory bindings}

Objects whose memory was allocated using language-native allocation
methods (e.g fortran \texttt{allocate}, C \texttt{malloc}) are not
required to deliver the same performance as with ESMF memory.

\req{Heart-beat}

Support and adherence to a heart-beat function is required.

\begin{reqlist}
  {\bf Priority:} Priority 1 \\
  {\bf Source:}  MIT \\
  {\bf Status:}  \\
  {\bf Verification:} Unit tests, EVA tests \\
  {\bf Notes:} Some mechanism should be available to detect the
  failure or dead-lock of one or more communication end-points. This
  can be queried at the application level. When this happens the ESMF
  application should either take a recovery action or shutdown
  gracefully (``user checkpointing''). This should include appropriate
  freeing of system resources reserved for {\bf \shortname} purposes.
\end{reqlist}
