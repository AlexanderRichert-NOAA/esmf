%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_Array.F90,  Date: Tue Apr 29 12:10:57 MDT 2003
}

 
%/////////////////////////////////////////////////////////////
\subsection{Fortran:  Module Interface ESMF\_ArrayMod - Manage data arrays uniformly between F90 and C++ (Source File: ESMF\_Array.F90)}


  
  
   The code in this file implements the {\tt Array} class and
   associated functions and subroutines.
  
   C and C++ arrays are simple pointers to memory.
   Fortran arrays contain shape and stride definitions and are strongly
   typed. To enable interoperability between the languages the C++ code
   must be able to obtain this information from the Fortran description
   (which is called the "dope vector" in Fortran), either through a priori
   knowledge or through query.
  
  ------------------------------------------------------------------------------
\bigskip{\em USES:}
\begin{verbatim}       use ESMF_BaseMod
       use ESMF_IOMod
       use ESMF_DELayoutMod
       implicit none
  ------------------------------------------------------------------------------\end{verbatim}{\sf PRIVATE TYPES:}
\begin{verbatim}       private
  ------------------------------------------------------------------------------
   ! ESMF_CopyFlag
   ! Indicates whether a data array should be copied or referenced.
   ! TODO: Should this be moved down to the base class? Is it useful
   ! anyplace else outside of the Array context?
       type ESMF_CopyFlag
       sequence
       private
         integer :: docopy
       end type
       type(ESMF_CopyFlag), parameter :: &
                             ESMF_DATA_COPY = ESMF_CopyFlag(1), &
                             ESMF_DATA_REF = ESMF_CopyFlag(2), &
                             ESMF_DATA_SPACE = ESMF_CopyFlag(3) ! private
  ------------------------------------------------------------------------------
   ! ESMF_ArrayOrigin
   ! Private flag which indicates the create was initiated on the F90 side.
   ! This matches an enum on the C++ side and the values must match.
   ! Update ../include/ESMC_Array.h if you change these values.
       type ESMF_ArrayOrigin
       sequence
       private
         integer :: origin
       end type
       type(ESMF_ArrayOrigin), parameter :: &
                             ESMF_FROM_FORTRAN = ESMF_ArrayOrigin(1), &
                             ESMF_FROM_CPLUSPLUS = ESMF_ArrayOrigin(2)
  ------------------------------------------------------------------------------
   ! ESMF_ArraySpec
   ! Data array specification, with no associated data buffer.
       type ESMF_ArraySpec
       sequence
       private
         integer :: rank ! number of dimensions
         type(ESMF_DataType) :: type ! real/float, integer, etc enum
         type(ESMF_DataKind) :: kind ! fortran "kind" enum/integer
       end type
  ------------------------------------------------------------------------------
   ! ESMF_Array
   ! Array data type. All information is kept on the C++ side inside
   ! the class structure.
       type ESMF_Array
       sequence
       private
         type(ESMF_Pointer) :: this ! opaque pointer to the C++ class data
       end type
  ------------------------------------------------------------------------------
   ! Internal wrapper structures for passing f90 pointers to C++ and
   ! guaranteeing they are passed by reference on all compilers and all
   ! platforms. These are never seen outside this module.
       ! < these expand into defined type declarations >
 
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI21D 
  integer (ESMF_IKIND_I2),dimension(:),pointer :: I21Dptr 
  end type ESMF_ArrWrapI21D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI41D 
  integer (ESMF_IKIND_I4),dimension(:),pointer :: I41Dptr 
  end type ESMF_ArrWrapI41D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI81D 
  integer (ESMF_IKIND_I8),dimension(:),pointer :: I81Dptr 
  end type ESMF_ArrWrapI81D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI22D 
  integer (ESMF_IKIND_I2),dimension(:,:),pointer :: I22Dptr 
  end type ESMF_ArrWrapI22D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI42D 
  integer (ESMF_IKIND_I4),dimension(:,:),pointer :: I42Dptr 
  end type ESMF_ArrWrapI42D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI82D 
  integer (ESMF_IKIND_I8),dimension(:,:),pointer :: I82Dptr 
  end type ESMF_ArrWrapI82D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI23D 
  integer (ESMF_IKIND_I2),dimension(:,:,:),pointer :: I23Dptr 
  end type ESMF_ArrWrapI23D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI43D 
  integer (ESMF_IKIND_I4),dimension(:,:,:),pointer :: I43Dptr 
  end type ESMF_ArrWrapI43D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI83D 
  integer (ESMF_IKIND_I8),dimension(:,:,:),pointer :: I83Dptr 
  end type ESMF_ArrWrapI83D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI24D 
  integer (ESMF_IKIND_I2),dimension(:,:,:,:),pointer :: I24Dptr 
  end type ESMF_ArrWrapI24D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI44D 
  integer (ESMF_IKIND_I4),dimension(:,:,:,:),pointer :: I44Dptr 
  end type ESMF_ArrWrapI44D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI84D 
  integer (ESMF_IKIND_I8),dimension(:,:,:,:),pointer :: I84Dptr 
  end type ESMF_ArrWrapI84D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI25D 
  integer (ESMF_IKIND_I2),dimension(:,:,:,:,:),pointer :: I25Dptr 
  end type ESMF_ArrWrapI25D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI45D 
  integer (ESMF_IKIND_I4),dimension(:,:,:,:,:),pointer :: I45Dptr 
  end type ESMF_ArrWrapI45D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapI85D 
  integer (ESMF_IKIND_I8),dimension(:,:,:,:,:),pointer :: I85Dptr 
  end type ESMF_ArrWrapI85D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR41D 
  real (ESMF_IKIND_R4),dimension(:),pointer :: R41Dptr 
  end type ESMF_ArrWrapR41D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR81D 
  real (ESMF_IKIND_R8),dimension(:),pointer :: R81Dptr 
  end type ESMF_ArrWrapR81D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR42D 
  real (ESMF_IKIND_R4),dimension(:,:),pointer :: R42Dptr 
  end type ESMF_ArrWrapR42D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR82D 
  real (ESMF_IKIND_R8),dimension(:,:),pointer :: R82Dptr 
  end type ESMF_ArrWrapR82D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR43D 
  real (ESMF_IKIND_R4),dimension(:,:,:),pointer :: R43Dptr 
  end type ESMF_ArrWrapR43D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR83D 
  real (ESMF_IKIND_R8),dimension(:,:,:),pointer :: R83Dptr 
  end type ESMF_ArrWrapR83D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR44D 
  real (ESMF_IKIND_R4),dimension(:,:,:,:),pointer :: R44Dptr 
  end type ESMF_ArrWrapR44D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR84D 
  real (ESMF_IKIND_R8),dimension(:,:,:,:),pointer :: R84Dptr 
  end type ESMF_ArrWrapR84D 
  
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR45D 
  real (ESMF_IKIND_R4),dimension(:,:,:,:,:),pointer :: R45Dptr 
  end type ESMF_ArrWrapR45D 
  
  ! <Created by macro - do not edit directly > 
  type ESMF_ArrWrapR85D 
  real (ESMF_IKIND_R8),dimension(:,:,:,:,:),pointer :: R85Dptr 
  end type ESMF_ArrWrapR85D 
  
   < end macro - do not edit directly > 
  
 
  ------------------------------------------------------------------------------\end{verbatim}{\sf PUBLIC TYPES:}
\begin{verbatim}       public ESMF_CopyFlag, ESMF_DATA_COPY, ESMF_DATA_REF
       public ESMF_ArraySpec, ESMF_Array
  ------------------------------------------------------------------------------\end{verbatim}{\sf PUBLIC MEMBER FUNCTIONS:}
\begin{verbatim}       public ESMF_ArrayCreate
       public ESMF_ArrayDestroy
       public ESMF_ArraySpecInit
       public ESMF_ArraySpecGet
       public ESMF_ArraySetData, ESMF_ArrayGetData
       !public ESMF_ArraySetInfo, ESMF_ArrayGetInfo
       public ESMF_ArraySetAxisIndex, ESMF_ArrayGetAxisIndex
       public ESMF_ArrayRedist, ESMF_ArrayHalo
       public ESMF_ArrayAllGather, ESMF_ArrayGather, ESMF_ArrayScatter
       public ESMF_ArrayGet, ESMF_ArrayGetName
       public ESMF_ArrayF90Allocate
       public ESMF_ArrayF90Deallocate
       public ESMF_ArrayConstructF90Ptr ! needed for C++ callback only
       public ESMF_ArrayCheckpoint
       public ESMF_ArrayRestore
       public ESMF_ArrayWrite
       public ESMF_ArrayRead
       public ESMF_ArrayValidate
       public ESMF_ArrayPrint\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate -- Generic interface to create an Array}


\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_ArrayCreate\end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}         module procedure ESMF_ArrayCreateByList ! specify TKR
         module procedure ESMF_ArrayCreateBySpec ! specify ArraySpec
         ! Plus interfaces for each T/K/R\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

   This interface provides a single (heavily overloaded) entry point for
   the various types of {\tt ESMF\_ArrayCreate} functions.
  
   There are 3 options for setting the contents of the {\tt ESMF\_Array}
   at creation time:
   \begin{description}
   \item[Allocate Space Only]
   Data space is allocated but not initialized. The caller can query
   for a pointer to the start of the space to address it directly.
   The caller must not deallocate the space; the
   {\tt ESMF\_Array} will release the space when it is destroyed.
   \item[Data Copy]
   An existing Fortran array is specified and the data contents are copied
   into new space allocated by the {\tt ESMF\_Array}.
   The caller must not deallocate the space; the
   {\tt ESMF\_Array} will release the space when it is destroyed.
   \item[Data Reference]
   An existing Fortran array is specified and the data contents reference
   it directly. The caller is responsible for deallocating the space;
   when the {\tt ESMF\_Array} is destroyed it will not release the space.
   \end{description}
  
   There are 3 options for
   specifying the type/kind/rank of the {\tt ESMF\_Array} data:
   \begin{description}
   \item[List]
   The characteristics of the {\tt ESMF\_Array} are given explicitly
   by individual arguments to the create function.
   \item[ArraySpec]
   A previously created {\tt ESMF\_ArraySpec} object is given which
   describes the characteristics.
   %\item[Fortran array]
   % An existing Fortran array is used to describe the characteristics.
   % (Only available from the Fortran interface.)
   \item[Fortran 90 Pointer]
   An associated or unassociated Fortran 90 array pointer is used to
   describe the array.
   (Only available from the Fortran interface.)
   \end{description}
  
   The concept of an ``empty'' {\tt Array} does not exist. To make an
   ESMF object which stores the Type/Kind/Rank information create an
   {\tt ESMF\_ArraySpec} object which can then be used repeatedly in
   subsequent {\tt Array} Create calls.
  
 end interface 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayGetData] {ESMF\_ArrayGetData -- Get an F90 pointer to the data contents}


\bigskip{\sf INTERFACE:}
\begin{verbatim}      interface ESMF_ArrayGetData\end{verbatim}{\sf PRIVATE MEMBER FUNCTIONS:}
\begin{verbatim}       ! < declarations of interfaces for each T/K/R >
  ------------------------------------------------------------------------------ 
   <This section created by macro - do not edit directly> 
  module procedure ESMF_ArrayGetDataI21D 
  module procedure ESMF_ArrayGetDataI41D 
  module procedure ESMF_ArrayGetDataI81D 
  module procedure ESMF_ArrayGetDataI22D 
  module procedure ESMF_ArrayGetDataI42D 
  module procedure ESMF_ArrayGetDataI82D 
  module procedure ESMF_ArrayGetDataI23D 
  module procedure ESMF_ArrayGetDataI43D 
  module procedure ESMF_ArrayGetDataI83D 
  module procedure ESMF_ArrayGetDataI24D 
  module procedure ESMF_ArrayGetDataI44D 
  module procedure ESMF_ArrayGetDataI84D 
  module procedure ESMF_ArrayGetDataI25D 
  module procedure ESMF_ArrayGetDataI45D 
  module procedure ESMF_ArrayGetDataI85D 
  module procedure ESMF_ArrayGetDataR41D 
  module procedure ESMF_ArrayGetDataR81D 
  module procedure ESMF_ArrayGetDataR42D 
  module procedure ESMF_ArrayGetDataR82D 
  module procedure ESMF_ArrayGetDataR43D 
  module procedure ESMF_ArrayGetDataR83D 
  module procedure ESMF_ArrayGetDataR44D 
  module procedure ESMF_ArrayGetDataR84D 
  module procedure ESMF_ArrayGetDataR45D 
  module procedure ESMF_ArrayGetDataR85D 
   < end macro - do not edit directly > 
  ------------------------------------------------------------------------------ 
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   This interface provides a single entry point for the various
   types of {\tt ESMF\_ArrayGetData} functions.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByList] {ESMF\_ArrayCreateByList -- Create an Array specifying all options.}


\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_ArrayCreateByList(rank, type, kind, counts, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Array) :: ESMF_ArrayCreateByList\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       integer, intent(in) :: rank
       type(ESMF_DataType), intent(in) :: type
       type(ESMF_DataKind), intent(in) :: kind
       integer, dimension(:), intent(in) :: counts
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create a new Array and allocate data space, which remains uninitialized.
   The return value is a new Array.
  
   The arguments are:
   \begin{description}
  
   \item[rank]
   Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 5D.
  
   \item[type]
   Array type. Valid types include {\tt ESMF\_DATA\_INTEGER},
   {\tt ESMF\_DATA\_REAL}, {\tt ESMF\_DATA\_LOGICAL},
   {\tt ESMF\_DATA\_CHARACTER}.
  
   \item[kind]
   Array kind. Valid kinds include {\tt ESMF\_KIND\_I4},
   {\tt ESMF\_KIND\_I8}, {\tt ESMF\_KIND\_R4}, {\tt ESMF\_KIND\_R8},
   {\tt ESMF\_KIND\_C8}, {\tt ESMF\_KIND\_C16}.
  
   \item[counts]
   The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank.
  
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateBySpec] {ESMF\_ArrayCreateBySpec -- Create a new Array from an ArraySpec}


\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_ArrayCreateBySpec(spec, counts, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Array) :: ESMF_ArrayCreateBySpec\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_ArraySpec), intent(in) :: spec
       integer, intent(in), dimension(:) :: counts
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create a new Array and allocate data space, which remains uninitialized.
   The return value is a new Array.
  
   The arguments are:
   \begin{description}
  
   \item[spec]
   ArraySpec object.
  
   \item[counts]
   The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank.
  
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByMTArr<type>] {ESMF\_ArrayCreateByMTArr<type> - make an ESMF array from an unallocated F90 array }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  function ESMF_ArrayCreateByMTArr<type>(f90arr, counts, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  type(ESMF_Array) :: ESMF_ArrayCreateByMTArr<type> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  integer (ESMF_KIND), dimension(:), target :: f90arr 
  !integer (ESMF_KIND), dimension(:), allocatable, target :: f90arr 
  integer, dimension(:), intent(in) :: counts 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Creates an {\tt Array} based on an unallocated (but allocatable) Fortran 
   90 array. This routine allocates memory to the array and fills in 
   the array object with all necessary information. 
   
   The function return is an ESMF\_Array type with space allocated for data. 
   
   The arguments are: 
   \begin{description} 
   \item[f90arr] 
   An allocatable (but currently unallocated) Fortran 90 array. 
   
   \item[counts] 
   An integer array of counts. Must be the same length as the rank. 
   
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
   
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByFullArr<type>] {ESMF\_ArrayCreateByFullArr<type> - make an ESMF array from an Allocated F90 array }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  function ESMF_ArrayCreateByFullArr<type>(f90arr, docopy, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  type(ESMF_Array) :: ESMF_ArrayCreateByFullArr<type> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  integer (ESMF_KIND), dimension(:), target :: f90arr 
  !integer (ESMF_KIND), dimension(:), allocatable, target :: f90arr 
  type(ESMF_CopyFlag), intent(in), optional :: docopy 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Creates an {\tt Array} based on an already allocated Fortran 
   90 array. This routine can make a copy or reference the existing data 
   and fills in the array object with all necessary information. 
   
   The function return is an ESMF\_Array type. 
   
   The arguments are: 
   \begin{description} 
   \item[f90arr] 
   An allocated Fortran 90 array. 
   
   \item[{[docopy]}] 
   Default to {\tt ESMF\_DATA\_REF}, makes the {\tt ESMF\_Array} reference 
   the existing data array. If set to {\tt ESMF\_DATA\_COPY} this routine 
   allocates new space and copies the data from the pointer into the 
   new array. 
   
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
   
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByMTPtr<type>] {ESMF\_ArrayCreateByMTPtr<type> - make an ESMF array from an unallocated F90 pointer }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  function ESMF_ArrayCreateByMTPtr<type>(f90ptr, counts, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  type(ESMF_Array) :: ESMF_ArrayCreateByMTPtr<type> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  integer (ESMF_KIND), dimension(:), pointer :: f90ptr 
  integer, dimension(:), intent(in) :: counts 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Creates an {\tt Array} based on an unassociated Fortran 90 pointer. 
   This routine allocates memory to the array pointer and fills in 
   the array object with all necessary information. 
   
   The function return is an ESMF\_Array type with space allocated for data. 
   
   The arguments are: 
   \begin{description} 
   \item[f90ptr] 
   An unassociated Fortran 90 array pointer. 
   
   \item[counts] 
   An integer array of counts. Must be the same length as the rank. 
   
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
   
  
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByMTPtr<type>] {ESMF\_ArrayCreateByMTPtr<type> - make an ESMF array from an unallocated F90 pointer }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  function ESMF_ArrayCreateByMTPtr<type>(f90ptr, counts, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  type(ESMF_Array) :: ESMF_ArrayCreateByMTPtr<type> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  integer (ESMF_KIND), dimension(:), pointer :: f90ptr 
  integer, dimension(:), intent(in) :: counts 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Creates an {\tt Array} based on an unassociated Fortran 90 pointer. 
   This routine allocates memory to the array pointer and fills in 
   the array object with all necessary information. 
   
   The function return is an ESMF\_Array type with space allocated for data. 
   
   The arguments are: 
   \begin{description} 
   \item[f90ptr] 
   An unassociated Fortran 90 array pointer. 
   
   \item[counts] 
   An integer array of counts. Must be the same length as the rank. 
   
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
     
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreateByFullPtr<type>] {ESMF\_ArrayCreateByFullPtr<type> - make an ESMF array from an Allocated F90 pointer }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  function ESMF_ArrayCreateByFullPtr<type>(f90ptr, docopy, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  type(ESMF_Array) :: ESMF_ArrayCreateByFullPtr<type> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  integer (ESMF_KIND), dimension(:), pointer :: f90ptr 
  type(ESMF_CopyFlag), intent(in), optional :: docopy 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Creates an {\tt Array} based on an already allocated Fortran 90 array 
   pointer. This routine can make a copy or reference the existing data 
   and fills in the array object with all necessary information. 
   
   The function return is an ESMF\_Array type. 
   
   The arguments are: 
   \begin{description} 
   \item[f90ptr] 
   An allocated Fortran 90 array pointer. 
   
   \item[{[docopy]}] 
   Default to {\tt ESMF\_DATA\_REF}, makes the {\tt ESMF\_Array} reference 
   the existing data array. If set to {\tt ESMF\_DATA\_COPY} this routine 
   allocates new space and copies the data from the pointer into the 
   new array. 
   
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
     
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}  subroutine ESMF_ArrayGetData<type>(array, f90ptr, docopy, rc) 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  type(ESMF_Array) :: array 
  integer (ESMF_KIND), dimension(:), pointer :: f90ptr 
  type(ESMF_CopyFlag), intent(in), optional :: docopy 
  integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Return an F90 pointer to the data buffer, or return an F90 pointer 
   to a new copy of the data. 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayDestroy(array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Releases all resources associated with this {\tt Array}.
  
   The arguments are:
   \begin{description}
  
   \item[array]
   Destroy contents of this {\tt Array}.
  
   \item[[rc]]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
  
   To reduce the depth of crossings of the F90/C++ boundary we first
   query to see if we are responsible for deleting the data space. If so,
   first deallocate the space and then call the C++ code to release
   the object space. When it returns we are done and can return to the user.
   Otherwise we would need to make a nested call back into F90 from C++ to do
   the deallocate() during the object delete.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySetData] {ESMF\_ArraySetData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArraySetData(array, dataspec, databuf, docopy, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       type(ESMF_ArraySpec), intent(in) :: dataspec
       real, dimension (:), pointer :: databuf
       type(ESMF_CopyFlag), intent(in) :: docopy
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used only with the version of ArrayCreate which creates an empty
   Array and allows the Data to be specified later. Otherwise it is an
   error to replace the data contents associated with a Array.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySetAxisIndex] {ESMF\_ArraySetAxisIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArraySetAxisIndex(array, indexlist, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(inout) :: array
       type(ESMF_AxisIndex), intent(in) :: indexlist(:)
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to annotate an Array with information used to map local to global
   indicies.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayGetAxisIndex] {ESMF\_ArrayGetAxisIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayGetAxisIndex(array, indexlist, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(inout) :: array
       type(ESMF_AxisIndex), intent(out) :: indexlist(:)
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to retrieve the index annotation from an Array.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayRedist(array, layout, rank_trans, olddecompids, &
                                   decompids, redistarray, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       type(ESMF_DELayout) :: layout
       integer, dimension(:), intent(in) :: rank_trans
       integer, dimension(:), intent(in) :: olddecompids
       integer, dimension(:), intent(in) :: decompids
       type(ESMF_Array), intent(in) :: redistarray
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to redistribute an Array.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayHalo(array, layout, decompids, AI_exc, AI_tot, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       type(ESMF_DELayout) :: layout
       integer, dimension(:), intent(in) :: decompids
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_exc
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_tot
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to halo an Array.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayAllGather(array, layout, decompids, &
                                      AI_exc, AI_tot, array_out, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(in) :: array
       type(ESMF_DELayout), intent(in) :: layout
       integer, dimension(:), intent(in) :: decompids
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_exc
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_tot
       type(ESMF_Array), intent(out) :: array_out
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to gather a distributed Array into a global Array on all DEs.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayGather(array, layout, decompids, &
                                      AI_exc, AI_tot, deid, array_out, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(in) :: array
       type(ESMF_DELayout), intent(in) :: layout
       integer, dimension(:), intent(in) :: decompids
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_exc
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_tot
       integer, intent(in) :: deid
       type(ESMF_Array), intent(out) :: array_out
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to gather a distributed Array into a global Array on all DEs.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayScatter(array, layout, decompids, &
                                      AI_exc, AI_tot, deid, array_out, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(in) :: array
       type(ESMF_DELayout), intent(in) :: layout
       integer, dimension(:), intent(in) :: decompids
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_exc
       type(ESMF_AxisIndex), dimension(:), intent(inout) :: AI_tot
       integer, intent(in) :: deid
       type(ESMF_Array), intent(out) :: array_out
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to scatter a single Array into a distributed Array across all DEs.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayReorder(array, newarrayspec, newarray, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       type(ESMF_ArraySpec), intent(in) :: newarrayspec
       type(ESMF_Array):: newarray
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to alter the local memory ordering (layout) of this Array.
  
   !TODO: remove this note before generating user documentation
  
   (i am not sure this makes sense now, or that the routine should be
   in this class. but i am leaving this here as a reminder that we
   might need some low level reorder functions. maybe the argument
   should be another array or an arrayspec which describes what you
   want, and the input array is what exists, and this routine can then
   make one into the other. is this a type of create? or is this
   a copy?)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}      subroutine ESMF_ArraySpecInit(as, rank, type, kind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_ArraySpec), intent(inout) :: as
      integer, intent(in) :: rank
      type(ESMF_DataType), intent(in) :: type
      type(ESMF_DataKind), intent(in) :: kind
      integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Creates a description of the data -- the type, the dimensionality, etc.
   This specification can be
   used in an ArrayCreate call with data to create a full Array.
  
   The arguments are:
   \begin{description}
  
   \item[arrayspec]
   Uninitialized array spec.
  
   \item[rank]
   Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 5D.
  
   \item[type]
   Array type. Valid types include {\tt ESMF\_DATA\_INTEGER},
   {\tt ESMF\_DATA\_REAL}, {\tt ESMF\_DATA\_LOGICAL},
   {\tt ESMF\_DATA\_CHARACTER}.
  
   \item[kind]
   Array kind. Valid kinds include {\tt ESMF\_KIND\_I4},
   {\tt ESMF\_KIND\_I8}, {\tt ESMF\_KIND\_R4}, {\tt ESMF\_KIND\_R8},
   {\tt ESMF\_KIND\_C8}, {\tt ESMF\_KIND\_C16}.
  
   \item[[rc]]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayGet(array, rank, type, kind, counts, &
                                lbounds, ubounds, strides, base, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       integer, intent(out), optional :: rank
       type(ESMF_DataType), intent(out), optional :: type
       type(ESMF_DataKind), intent(out), optional :: kind
       integer, dimension(:), intent(out), optional :: counts
       integer, dimension(:), intent(out), optional :: lbounds
       integer, dimension(:), intent(out), optional :: ubounds
       integer, dimension(:), intent(out), optional :: strides
       type(ESMF_Pointer), intent(out), optional :: base
       character(len=ESMF_MAXSTR), intent(out), optional :: name
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns information about the array. For queries where the caller
   only wants a single value, specify the argument by name.
   All the arguments after the array input are optional to facilitate this.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayGetName] {ESMF\_ArrayGetName - Retrieve the name of a Array}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayGetName(array, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array), intent(in) :: array
       character (len = *), intent(out) :: name
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns the name of the array. If the array was created without
   specifying a name, the framework will have assigned it a unique one.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArraySpecGet(as, rank, type, kind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_ArraySpec), intent(in) :: as
       integer, intent(out), optional :: rank
       type(ESMF_DataType), intent(out), optional :: type
       type(ESMF_DataKind), intent(out), optional :: kind
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return information about the contents of a ArraySpec type.
  
   The arguments are:
   \begin{description}
  
   \item[as]
   An {\tt ArraySpec} object.
  
   \item[rank]
   Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 5D.
  
   \item[type]
   Array type. Valid types include {\tt ESMF\_DATA\_INTEGER},
   {\tt ESMF\_DATA\_REAL}, {\tt ESMF\_DATA\_LOGICAL},
   {\tt ESMF\_DATA\_CHARACTER}.
  
   \item[kind]
   Array kind. Valid kinds include {\tt ESMF\_KIND\_I4},
   {\tt ESMF\_KIND\_I8}, {\tt ESMF\_KIND\_R4}, {\tt ESMF\_KIND\_R8},
   {\tt ESMF\_KIND\_C8}, {\tt ESMF\_KIND\_C16}.
  
   \item[[rc]]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayF90Deallocate] {ESMF\_ArrayF90Deallocate - Deallocate an F90 pointer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}      subroutine ESMF_ArrayF90Deallocate(array, rank, type, kind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       integer :: rank
       type(ESMF_DataType) :: type
       type(ESMF_DataKind) :: kind
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Deallocate data contents for an array created from the C++ interface.
   The arguments are:
   \begin{description}
   \item[array]
   A partially created {\tt Array} object.
   \item[rank]
   The {\tt Array} rank.
   \item[type]
   The {\tt Array} type (integer, real/float, etc).
   \item[kind]
   The {\tt Array} kind (short/2, long/8, etc).
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayCheckpoint(array, iospec, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array):: array
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to save all data to disk as quickly as possible.
   (see Read/Write for other options). Internally this routine uses the
   same I/O interface as Read/Write, but the default options are to
   select the fastest way to save data to disk.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_ArrayRestore(name, iospec, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Array) :: ESMF_ArrayRestore\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       character (len = *), intent(in) :: name ! array name to restore
       type(ESMF_IOSpec), intent(in), optional :: iospec ! file specs
       integer, intent(out), optional :: rc ! return code\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to reinitialize
   all data associated with a Array from the last call to Checkpoint.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayWrite(array, iospec, filename, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       type(ESMF_IOSpec), intent(in), optional :: iospec
       character(len=*), intent(in), optional :: filename
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to write data to persistent storage in a variety of formats.
   (see Checkpoint/Restore for quick data dumps.) Details of I/O
   options specified in the IOSpec derived type.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_ArrayRead(name, iospec, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Array) :: ESMF_ArrayRead\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       character (len = *), intent(in) :: name ! array name to read
       type(ESMF_IOSpec), intent(in), optional :: iospec ! file specs
       integer, intent(out), optional :: rc ! return code\end{verbatim}
{\sf DESCRIPTION:\\ }


   Used to read data from persistent storage in a variety of formats.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayValidate] {ESMF\_ArrayValidate - Check validity of Array object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayValidate(array, options, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       character (len = *), intent(in), optional :: options
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Routine to print information about a array.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayPrint] {ESMF\_ArrayPrint - Print contents of an Array object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_ArrayPrint(array, options, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Array) :: array
       character (len = *), intent(in), optional :: options
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Routine to print information about a array.
  
%...............................................................
