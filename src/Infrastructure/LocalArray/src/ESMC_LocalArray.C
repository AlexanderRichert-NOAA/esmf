// Earth System Modeling Framework
// Copyright 2002-2003, University Corporation for Atmospheric Research, 
// Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
// Laboratory, University of Michigan, National Centers for Environmental 
// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
// NASA Goddard Space Flight Center.
// Licensed under the GPL.

// ESMC Array method implementation (body) file

//-----------------------------------------------------------------------------
//
// !DESCRIPTION:
//
// The code in this file implements the C++ Array methods declared
// in the companion file ESMC_LocalArray.h.  
//
// The {\tt ESMF\_Array} object allows C++ to emulate the richer
// Fortran language Array operations.  It allows strided access, 
// subsetting operations, known dimension sizes, and typed access 
// to arrays instead of just a starting address to a block of memory.  
//
//-----------------------------------------------------------------------------
//

// for printf
#include <stdio.h>
#include <string.h>
#include <assert.h>
// associated class definition file
#include "ESMC_LocalArray.h"

//-----------------------------------------------------------------------------
 // leave the following line as-is; it will insert the cvs ident string
 // into the object file for tracking purposes.
 static const char *const version = 
            "$Id: ESMC_LocalArray.C,v 1.2 2003/10/07 22:37:10 nscollins Exp $";
//-----------------------------------------------------------------------------

//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// This section includes all the Local Array create/destroy routines.
//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayCreate - Create a new Array
//
// !INTERFACE:
      ESMC_LocalArray *ESMC_LocalArrayCreate(
//
// !RETURN VALUE:
//     pointer to newly allocated ESMC_LocalArray
//
// !ARGUMENTS:
    int rank,                  // dimensionality
    ESMC_DataType dt,          // int, float, etc
    ESMC_DataKind dk,          // short/long, etc
    int *icounts,              // number of items in each dim
    void *base,                // if non-null, this is already allocated memory
    ESMC_DataCopy docopy,      // if base != NULL, copy data?
    int *rc) {                 // return code
//
// !DESCRIPTION:
//      This routine is the C++ entry point for creating an {\tt ESMF\_Array}
//      object.  Unlike natural C++ arrays which can be as simple as the
//      base address pointer and the number of bytes necessary to move to
//      the next item, {\tt ESMF\_Array}s are richer in the associated metadata
//      which allows them to behave more like Fortran arrays.  They store
//      the size of each dimension, allow non-contiguous strides per
//      dimension, and allow whole-array or subsectional operations.
//
//EOP
// !REQUIREMENTS:  AAAn.n.n

//   This code needs to make space for the private class data and store the
//   arguments given.
//
//   There will need to be a #if USING_MIXED_FORTRAN_AND_C++ section.  If
//   we are running with fortran, then it needs to do:
//   - call a *Fortran* allocate routine to get space - not malloc - and
//     it needs to create an F90 array pointer of the correct type/kind/rank 
//     so this array is useable from F90 as well as C++.  
//     The new F90 pointer is stored in the private 
//     data for this class as an opaque object; to be returned on demand 
//     for use by fortran code.
//
//   else, if this is a C++ only build then it has to call malloc to get
//   space, and it can ignore F90 pointers completely.
//
//   The return from this routine is a pointer to the new Array data.
//
     ESMC_LocalArray *a = new ESMC_LocalArray;
     int status;


     status = a->ESMC_LocalArrayConstruct(rank, dt, dk, icounts, base, 
                                          ESMC_FROM_CPLUSPLUS,
                                          NULL, ESMC_ARRAY_DO_ALLOCATE, 
                                          docopy, ESMF_TRUE, 
                                          NULL, NULL, NULL); 
     
     if (rc != NULL)
         *rc = status;

     return a;

 } // end ESMC_LocalArrayCreate

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayDestroy - free a LocalArray created with Create
//
// !INTERFACE:
      int ESMC_LocalArrayDestroy(ESMC_LocalArray *array) {
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//      ESMF routine which destroys a LocalArray object previously allocated
//      via an {\tt ESMC\_LocalArrayCreate} routine.  Define for deep classes
//      only.
//
//EOP
// !REQUIREMENTS:  

    array->ESMC_LocalArrayDestruct();

    delete array;

    return 0;

 } // end ESMC_LocalArrayDestroy

//-----------------------------------------------------------------------------
//BOPI
// !IROUTINE:  ESMC_LocalArrayCreateNoData - internal routine for fortran use
//
// !INTERFACE:
      ESMC_LocalArray *ESMC_LocalArrayCreateNoData(
//
// !RETURN VALUE:
//     pointer to newly allocated ESMC_LocalArray
//
// !ARGUMENTS:
    int rank,                  // dimensionality
    ESMC_DataType dt,          // int, float, etc
    ESMC_DataKind dk,          // short/long, etc
    ESMC_ArrayOrigin oflag,    // caller is fortran or C++?
    int *rc) {                 // return code
//
// !DESCRIPTION:
//      This version of Create is only intended for internal use by the
//      {\tt ESMF\_LocalArrayCreate} fortran routine.  It creates a partially
//      constructed array, then depends on the caller to come back and
//      complete the array with the {\tt ESMF\_LocalArraySetInfo} call.  
//      (It is broken up this way to try to minimize the amount of
//      macro-generated code needed in the {\tt ESMF\_LocalArray.F90} source
//      file.)
//
//EOPI

     ESMC_LocalArray *a = new ESMC_LocalArray;
     int status;

     status = a->ESMC_LocalArrayConstruct(rank, dt, dk, NULL, NULL, oflag,
                            NULL, ESMC_ARRAY_NO_ALLOCATE, 
                            ESMC_DATA_NONE, ESMF_FALSE, 
                            NULL, NULL, NULL);

     if (rc != NULL)
         *rc = status;

     return a;

 } // end ESMC_LocalArrayCreateNoData

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayCreate_F - internal routine for fortran use
//
// !INTERFACE:
      ESMC_LocalArray *ESMC_LocalArrayCreate_F(
//
// !RETURN VALUE:
//     pointer to newly allocated ESMC_LocalArray
//
// !ARGUMENTS:
    int rank,                  // dimensionality
    ESMC_DataType dt,          // int, float, etc
    ESMC_DataKind dk,          // short/long, etc
    int *icounts,              // counts along each dimension
    struct c_F90ptr *f90ptr,   // opaque type which fortran uses (dope v)
    void *base,                // real start of memory 
    ESMC_DataCopy docopy,      // if base is null and this is Copy, alloc here
    int *lbounds,              // lower index number per dim
    int *ubounds,              // upper index number per dim
    int *offsets,              // number of bytes to start of data/dim
    int *rc) {                 // return code
//
// !DESCRIPTION:
//      This version of Create is only intended for internal use by the
//      {\tt ESMF\_LocalArrayCreate} fortran routine.  This routine works in a
//      similar manner as the regular {\tt ESMC\_LocalArrayCreate} routine, but
//      the differences include:  it gets a real fortran 90 array pointer as
//      one of the arguments; instead of calling malloc to make space for
//      the array contents, it passes the f90 pointer back to a fortran
//      routine to do the allocation.  This is so the fortran routine
//      can create the corresponding 'dope vector' in a completely compiler-
//      independent manner.  If we tried to do it here, we would have to
//      reverse-engineer the structure for each version of each compiler
//      we used.
//
//EOP
// !REQUIREMENTS:  AAAn.n.n

// TODO: Add code here which does:
//
//   This code needs to make space for the private class data and store the
//   arguments given.  Decide if constructor is going to do much or not.
//
//   It then call a *Fortran* allocate routine to get space - not malloc - and 
//   it needs to call with a pointer of the correct type/kind/rank so
//   that this array is useable from F90 as well as C++.  
     //ESMF_Allocate();
//   This is overloaded to call a specific routine on the F90 side which
//    is per type/kind/rank.
//
//   It then needs to store an opaque pointer to the real F90 array pointer 
//   (also called the dope vector), so that it can be returned to any 
//   fortran routine on demand. 
// 
//   The return from this routine is a pointer to the new LocalArray data.
//
     ESMC_LocalArray *a = new ESMC_LocalArray;
     int status;

     if (base == NULL) 
         status = a->ESMC_LocalArrayConstruct(rank, dt, dk, icounts, base, 
                                              ESMC_FROM_FORTRAN, f90ptr, 
                                              ESMC_ARRAY_DO_ALLOCATE,
                                              ESMC_DATA_NONE, ESMF_TRUE, 
                                              lbounds, ubounds, offsets); 
     else
         status = a->ESMC_LocalArrayConstruct(rank, dt, dk, icounts, base, 
                                              ESMC_FROM_FORTRAN, f90ptr, 
                                              ESMC_ARRAY_NO_ALLOCATE, 
                                              docopy, ESMF_FALSE, 
                                              lbounds, ubounds, offsets); 

     if (rc != NULL)
         *rc = status;

     return a;

 } // end ESMC_LocalArrayCreate_F

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayConstruct - fill in an already allocated LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayConstruct(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
    int irank,                 // dimensionality
    ESMC_DataType dt,          // int, float, etc
    ESMC_DataKind dk,          // short/long, etc  (*2, *4, *8)
    int *icounts,              // number of items in each dim
    void *base,                // base memory address of data block
    ESMC_ArrayOrigin oflag,    // create called from F90 or C++?
    struct c_F90ptr *f90ptr,   // opaque type which fortran understands (dopev)
    ESMC_ArrayDoAllocate aflag, // do we allocate space or not?
    ESMC_DataCopy docopy,      // do we make a copy of the data?
    ESMC_Logical dflag,        // do we deallocate space or not?
    int *lbounds,              // lower index number per dim
    int *ubounds,              // upper index number per dim
    int *offsets) {            // offset in bytes to start of each dim
//
// !DESCRIPTION:
//      ESMF routine which fills in the contents of an already allocated
//      {\tt ESMF\_LocalArray} object.  May need to do additional allocations
//      as needed.  Must call the corresponding {\tt ESMC\_LocalArrayDestruct}
//      routine to free the additional memory.  Intended for internal
//      ESMF use only; end-users use {\tt ESMC\_LocalArrayCreate}, which calls
//      {\tt ESMC\_LocalArrayConstruct}.  Define for deep classes only.
//
//EOP
// !REQUIREMENTS:  
    int i, status;
    ESMC_LocalArray *aptr;

    rank = irank;
    type = dt;
    kind = dk;

    base_addr = base;
    for (i=0; i<rank; i++) {
        counts[i]     = icounts ? icounts[i] : 1;        
//        lbound[i] = lbounds ? lbounds[i] : 1;
//        ubound[i] = ubounds ? ubounds[i] : counts[i];
        bytestride[i] = 1;
        offset[i]     = offsets ? offsets[i] : 0;
    }
    for (i=rank; i<ESMF_MAXDIM; i++) {
        counts[i]     = 1;
//        lbound[i] = 1;
//        ubound[i] = 1;
        bytestride[i] = 1;
        offset[i]     = 0;
    }

    origin = oflag;
    needs_dealloc = dflag;

    if (f90ptr != NULL)
        ESMC_LocalArraySetF90Ptr(f90ptr);
 
    if (aflag == ESMC_ARRAY_DO_ALLOCATE) {
            aptr = this;
            FTN(f_esmf_localarrayf90allocate)(&aptr, &rank, &type, &kind, 
                                                      counts, &status);
    } 

    
    // TODO: memcpy from base to base_addr, proper number of bytes?
    //  if docopy flag is set.

    return ESMF_SUCCESS;



 } // end ESMC_LocalArrayConstruct

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayDestruct - release resources associated w/a LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayDestruct(void) {
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//      ESMF routine which deallocates any space allocated by
//      {\tt ESMF\_LocalArrayConstruct}, does any additional cleanup before the
//      original {\tt ESMC\_LocalArray} object is freed.  Intended for internal
//      ESMF use only; end-users use {\tt ESMC\_LocalArrayDestroy}, which calls
//      {\tt ESMC\_LocalArrayDestruct}.  Define for deep classes only.
//
//EOP
// !REQUIREMENTS:  

    int rc = ESMF_FAILURE;
    ESMC_LocalArray *aptr = this;

    // check origin and alloc flag, and call dealloc routine if needed 
    if (needs_dealloc != ESMF_TRUE)
        return ESMF_SUCCESS;

    // if there is an F90 dope vector, we have to call back into fortran
    // to deallocate this.   if we want to support a C++ only library,
    // then this code needs to be calling malloc/free or new/delete and
    // needs conditional code to pick the fortran or C++ mem mgt system.

    FTN(f_esmf_localarrayf90deallocate)(&aptr, &rank, &type, &kind, &rc);

    return rc;

 } // end ESMC_LocalArrayDestruct
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// get/set routines.
//-----------------------------------------------------------------------------
// Note that most of the Get/Set routines are by value and are inline in
//  the include file.
//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArraySetInfo - Set the most common F90 needs
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArraySetInfo(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
    struct c_F90ptr *fptr,    // in - f90 pointer
    void *base,               // in - base memory address
    int *icounts,             // in - counts along each dim
    int *lbounds,             // in - lowest valid index
    int *ubounds,             // in - highest valid index
    int *offsets,             // in - numbytes from base to 1st item/dim
    ESMC_Logical contig,      // in - is memory chunk contiguous?
    ESMC_Logical dealloc) {   // in - do we need to deallocate at delete?
//
// !DESCRIPTION:
//     Sets a list of values associated with an already created pointer.
//     This particular set was chosen to mesh well with creation on the
//     F90 side.  Other combinations will probably be useful.
//
//EOP
// !REQUIREMENTS:  

    int i, rank = this->rank;
    int bytes = ESMF_F90_PTR_BASE_SIZE;
  
    // note - starts at 1; base includes rank 1 size
    for (i=1; i<rank; i++)
	bytes += ESMF_F90_PTR_PLUS_RANK;
   
   //fprintf(stderr, "setting f90 ptr from %lx to %lx, %d bytes for rank %d\n", 
   //                (long int)fptr, (long int)(&this->f90dopev), bytes, rank);

    memcpy((void *)(&this->f90dopev), (void *)fptr, bytes);

    base_addr = base;
    for (i=0; i<rank; i++) {
        counts[i]     = icounts ? icounts[i] : 0;
        offset[i]     = offsets ? offsets[i] : 0;
        bytestride[i] = 0;
//        lbound[i] = lbounds ? lbounds[i] : 0;
//        ubound[i] = ubounds ? ubounds[i] : counts[i];
    }
    for (i=rank; i<ESMF_MAXDIM; i++) {
        counts[i]     = 1;
        offset[i]     = 0;
        bytestride[i] = 1;
//        lbound[i] = 1;
//        ubound[i] = 1;
    }
    iscontig = contig;
    needs_dealloc = dealloc;

    return ESMF_SUCCESS; 

 } // end ESMC_LocalArraySetInfo

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayGetF90Ptr - get F90Ptr for a LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayGetF90Ptr(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      struct c_F90ptr *p) const {     // out - fortran 90 array pointer
//
// !DESCRIPTION:
//     Return a stored F90 pointer block.  The size may vary with rank.
//
//EOP
// !REQUIREMENTS:  

    int i, rank = this->rank;
    int bytes = ESMF_F90_PTR_BASE_SIZE;
  
    // note - starts at 1; base includes rank 1 size
    for (i=1; i<rank; i++)
	bytes += ESMF_F90_PTR_PLUS_RANK;
   
    //fprintf(stderr, "getting f90 ptr, from %lx to %lx, %d bytes for rank %d\n", 
    //                 (long int)(&this->f90dopev), (long int)p, bytes, rank);

    memcpy((void *)p, (void *)(&this->f90dopev), bytes);

    return ESMF_SUCCESS; 

 } // end ESMC_LocalArrayGetF90Ptr

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArraySetF90Ptr - set F90Ptr for a LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArraySetF90Ptr(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const struct c_F90ptr *p) {     // in - f90 pointer block
//
// !DESCRIPTION:
//     Sets the {\tt ESMC\_LocalArray} member F90ptr with the given value.
//     Can be multiple routines, one per value
//
//EOP
// !REQUIREMENTS:  

    int i, rank = this->rank;
    int bytes = ESMF_F90_PTR_BASE_SIZE;
  
    for (i=1; i<rank; i++)
	bytes += ESMF_F90_PTR_PLUS_RANK;
   
    //fprintf(stderr, "setting f90 ptr, from %lx to %lx, %d bytes for rank %d\n", 
    //                  (long int)p,  (long int)(&this->f90dopev), bytes, rank);

    memcpy((void *)(&this->f90dopev), (void *)p, bytes);

    return ESMF_SUCCESS; 

 } // end ESMC_LocalArraySetF90Ptr

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Higher level Array functions.  Might need to move to another file if
// there are enough of them...
//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArraySlice - drop an array by one dimension
//
// !INTERFACE:
      ESMC_LocalArray *ESMC_LocalArray::ESMC_LocalArraySlice(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int slicedim,             // in - which dim to slice
      int sliceloc,             // in - at which location on that dim
      int *rc) const {          // out - return code
//
// !DESCRIPTION:
//      Creates a (N-1)D array from an existing one.  Copies data if
//      it exists.  Returns a new array.
//
//EOP

    ESMC_LocalArray *newa;

    *rc = ESMF_FAILURE;

    return NULL;

 } // end ESMC_LocalArraySlice

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayReshape - change the rank or counts on an array
//
// !INTERFACE:
      ESMC_LocalArray *ESMC_LocalArray::ESMC_LocalArrayReshape(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      int rank,                 // in - new rank
      int *newcounts,           // in - new counts along each rank dim
      int *rc) const {          // out - return code
//
// !DESCRIPTION:
//      Creates a new array based on an old one.  The original data is
//      referenced and therefore shared with the old array, but it can be
//      iterated with an F90 pointer of a different configuration.
//
//EOP

    ESMC_LocalArray *newa;

    *rc = ESMF_FAILURE;

    return NULL;

 } // end ESMC_LocalArrayReshape

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Standard methods - Validate, Print, Read, Write
//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayValidate - internal consistency check
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayValidate(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const char *options) const {    // in - validate options
//
// !DESCRIPTION:
//      Validates that a {\tt ESMC\_LocalArray} is internally consistent.
//      Returns error code if problems are found.  {\tt ESMC\_Base} class method.
//
//EOP

//
//  code goes here
//
    int rc = ESMF_FAILURE;

    return rc;

 } // end ESMC_LocalArrayValidate

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayPrint - print contents of a LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayPrint(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const char *options) const {     //  in - print options
//
// !DESCRIPTION:
//      Print information about a {\tt ESMC\_LocalArray}.  The options control
//      the type of information and level of detail.  {\tt ESMC\_Base} class
//      method. 
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

//
//  code goes here
//
    int rc = ESMF_FAILURE;
    int i, j, k, l, m;
    int imax, jmax, kmax, lmax, mmax;
    int tcount, rcount;
    char between = '\n';
    char beforeskip = ' ';
    bool opt_all = false;   // print all data
    bool opt_exc = false;   // print only exclusive region (needs halo len)
    bool opt_byline = false;  // print a row/line

    if (options) {
        if (strstr(options, "full")) opt_all = true;
        if (strstr(options, "exclusive")) opt_exc = true;
        if (strstr(options, "line")) opt_byline = true;
    }

    if (opt_byline) {
        between = ' ';
        beforeskip = '\n';
    }

    printf("ArrayPrint: Array at address 0x%08lx:\n", (unsigned long)this);
    printf("            rank = %d, type = %d, kind = %d, ", 
                             this->rank, this->type, this->kind);
    printf("base_addr = 0x%08lx\n", (unsigned long)this->base_addr);
    printf("            ");
    for (i=0; i<this->rank; i++) 
        printf("dim[%d] = %d  ", i, this->counts[i]);
    printf("\n");
    
    // TODO: make this look at one of the option letters to see if user
    //   wants data printed.
    switch (this->type) {
      case ESMF_DATA_REAL:
        switch (this->rank) {
          case 1:
            printf("  Real, Dim 1, Data values:\n");
            imax = this->counts[0];
            tcount = imax;
            for (i=0; i<tcount; i++) {
                if (!opt_byline)
                    printf("(%2d) =  %lg\n", i+1, *((float *)(this->base_addr) + i));
                else
                    printf("%lg ", *((float *)(this->base_addr) + i));
                if (!opt_all && (tcount > 22) && ((i+1)==10)) {
                   printf("%c skipping to end ...\n", beforeskip);
                   i = tcount - 11;
                }
            }
            if (opt_byline) printf("\n");
            break;
          case 2:
            printf("  Real, Dim 2, Data values:\n");
            imax = this->counts[0];
            jmax = this->counts[1];
            tcount = imax * jmax;
            rcount = 0;
            for (j=0; j<jmax; j++) {
                if (opt_byline) printf("(*,%2d) = ", j+1);
                for (i=0; i<imax; i++) {
                    if (!opt_byline)
                        printf("(%2d,%2d) =  %lg\n", i+1, j+1, 
                               *((float *)(this->base_addr) + i + j*imax) );
                    else
                        printf("%lg ",  
                               *((float *)(this->base_addr) + i + j*imax) );
                    rcount++;
                    if (!opt_all && (tcount > 22) && (rcount==10)) {
                       printf("%c skipping to end ...\n", beforeskip);
                       j = (tcount-11) / imax;
                       i = (tcount-11) % imax;
                    }
                }
                if (opt_byline) printf("\n");
            }
            break;
          case 3:
            printf("  Real, Dim 3, Data values:\n");
            imax = this->counts[0];
            jmax = this->counts[1];
            kmax = this->counts[2];
            tcount = imax * jmax * kmax;
            rcount = 0; 
            for (k=0; k<kmax; k++) {
              for (j=0; j<jmax; j++) {
                if (opt_byline) printf("(*,%2d,%2d) = ", j+1, k+1);
                for (i=0; i<imax; i++) {
                    if (!opt_byline)
                        printf("(%2d,%2d,%2d) =  %g\n", 
                               i+1, j+1, k+1,
                               *((float *)(this->base_addr) + 
                               i + j*imax + k*jmax*imax));
                    else
                         printf("%g ", *((float *)(this->base_addr) + 
                               i + j*imax + k*jmax*imax));
                    rcount++;
                    if (!opt_all && (tcount > 22) && (rcount==10)) {
                       int krem;
                       printf("%c skipping to end ...\n", beforeskip);
                       k = (tcount-11) / (imax*jmax);
                       krem = (tcount-11) % (imax*jmax);
                       j = krem / imax;
                       i = krem % imax;
                    }
                }
                if (opt_byline) printf("\n");
              }
            }
            break;
          default:
            printf("no code to handle real rank %d yet\n", this->rank);
            break;    
        }
        break;
      case ESMF_DATA_INTEGER:
        switch (this->rank) {
          case 1:
            imax = this->counts[0];
            tcount = imax;
            printf("  Integer, Dim 1, Data values:\n");
            for (i=0; i<imax; i++) {
                if (!opt_byline)
                    printf("(%2d) =  %d\n", i+1, 
                           *((int *)(this->base_addr) + i));
                else
                    printf("%d ",
                           *((int *)(this->base_addr) + i));
                if (!opt_all && (tcount > 22) && ((i+1)==10)) {
                   printf("%c skipping to end ...\n", beforeskip);
                   i = tcount - 11;
                }
            }
            if (opt_byline) printf("\n");
            break;
          case 2:
            printf("  Integer, Dim 2, Data values:\n");
            imax = this->counts[0];
            jmax = this->counts[1];
            tcount = imax * jmax;
            rcount = 0; 
            for (j=0; j<jmax; j++) {
                if (opt_byline) printf("(*,%2d) = ", j+1);
                for (i=0; i<imax; i++) {
                    if (!opt_byline)
                        printf("(%2d,%2d) =  %d\n", 
                                i+1, j+1, 
                             *((int *)(this->base_addr) + i + j*imax) );
                    else
                        printf("%d ", 
                             *((int *)(this->base_addr) + i + j*imax) );
                    rcount++;
                    if (!opt_all && (tcount > 22) && (rcount==10)) {
                       printf("%c skipping to end ...\n", beforeskip);
                       j = (tcount-11) / imax;
                       i = (tcount-11) % imax;
                    }
                }
                if (opt_byline) printf("\n");
            }
            break;
          case 3:
            printf("  Integer, Dim 3, Data values:\n");
            imax = this->counts[0];
            jmax = this->counts[1];
            kmax = this->counts[2];
            tcount = imax * jmax * kmax;
            rcount = 0; 
            for (k=0; k<kmax; k++) {
              for (j=0; j<jmax; j++) {
                if (opt_byline) printf("(*,%2d,%2d) = ", j+1, k+1);
                for (i=0; i<imax; i++) {
                    if (!opt_byline)
                        printf("(%2d,%2d,%2d) =  %d\n", 
                               i+1, j+1, k+1,
                               *((int *)(this->base_addr) + 
                               i + j*imax + k*jmax*imax));
                    else
                        printf("%d ", 
                               *((int *)(this->base_addr) + 
                               i + j*imax + k*jmax*imax));
                    rcount++;
                    if (!opt_all && (tcount > 22) && (rcount==10)) {
                       int krem;
                       printf("%c skipping to end ...\n", beforeskip);
                       k = (tcount-11) / (imax*jmax);
                       krem = (tcount-11) % (imax*jmax);
                       j = krem / imax;
                       i = krem % imax;
                    }
                }
                if (opt_byline) printf("\n");
              }
            }
            break;
          default:
            printf("no code to handle integer rank %d yet\n", this->rank);
            break;    
        }
        break;
      default:
            printf("no code to handle data type %d yet\n", this->type);

      break;
    }

    rc = ESMF_SUCCESS;
    return rc;

 } // end ESMC_LocalArrayPrint

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArrayWrite - write contents of a LocalArray
//
// !INTERFACE:
      int ESMC_LocalArray::ESMC_LocalArrayWrite(
//
// !RETURN VALUE:
//    int error return code
//
// !ARGUMENTS:
      const char *options,             // in - write options
      const char *filename) const {    // in - file name
//
// !DESCRIPTION:
//      Write the contents of an {\tt ESMC\_LocalArray} to disk.
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

//
//  code goes here
//
    int rc = ESMF_FAILURE;
    int i, j, k, l, m;
    int imax, jmax, kmax, lmax, mmax;
    int tcount, rcount;
    FILE *ffile = NULL;

    if ((filename == NULL) || (filename[0] == '-')) {
        ffile = stdout;
    } else {
        ffile = fopen(filename, "w");
        if (ffile == NULL) {
            printf("error opening file '%s'\n", filename);
            return ESMF_FAILURE;
        }
    }

    fprintf(ffile, "ArrayWrite: Array at address 0x%08lx:  ", 
                           (unsigned long)this);
    fprintf(ffile, "rank = %d, type = %d, kind = %d\n", 
                             this->rank, this->type, this->kind);
    for (i=0; i<this->rank; i++) 
        fprintf(ffile, " dim[%d] = %d  ", i, this->counts[i]);
    fprintf(ffile, "\n");
    
    // TODO: make this look at one of the option letters to see how user
    //   wants data written (ascii, binary, multifile, singlefile).
    switch (this->type) {
      case ESMF_DATA_REAL:
        switch (this->rank) {
          case 1:
            imax = this->counts[0];
            tcount = imax;
            for (i=0; i<tcount; i++) {
                fprintf(ffile, "%lg\n", *((float *)(this->base_addr) + i));
            }
            break;
          case 2:
            imax = this->counts[0];
            jmax = this->counts[1];
            tcount = imax * jmax;
            rcount = 0;
            for (j=0; j<jmax; j++) {
                for (i=0; i<imax; i++) {
                    fprintf(ffile, "%lg ",  
                               *((float *)(this->base_addr) + i + j*imax) );
                }
                fprintf(ffile, "\n");
            }
            break;
          case 3:
            imax = this->counts[0];
            jmax = this->counts[1];
            kmax = this->counts[2];
            tcount = imax * jmax * kmax;
            rcount = 0; 
            for (k=0; k<kmax; k++) {
              for (j=0; j<jmax; j++) {
                for (i=0; i<imax; i++) {
                    fprintf(ffile, "%lg ",
                     *((float *)(this->base_addr) + i + j*imax + k*jmax*imax));
                }
                fprintf(ffile, "\n");
              }
            }
            break;
          default:
            fprintf(ffile, "no code to handle real rank %d yet\n", this->rank);
            break;    
        }
        break;
      case ESMF_DATA_INTEGER:
        switch (this->rank) {
          case 1:
            imax = this->counts[0];
            tcount = imax;
            for (i=0; i<imax; i++) {
                fprintf(ffile, "%d\n", *((int *)(this->base_addr) + i));
            }
            break;
          case 2:
            imax = this->counts[0];
            jmax = this->counts[1];
            tcount = imax * jmax;
            rcount = 0; 
            for (j=0; j<jmax; j++) {
                for (i=0; i<imax; i++) {
                    fprintf(ffile, "%d ",
                                *((int *)(this->base_addr) + i + j*imax) );
                }
                fprintf(ffile, "\n");
            }
            break;
          case 3:
            imax = this->counts[0];
            jmax = this->counts[1];
            kmax = this->counts[2];
            tcount = imax * jmax * kmax;
            rcount = 0; 
            for (k=0; k<kmax; k++) {
              for (j=0; j<jmax; j++) {
                for (i=0; i<imax; i++) {
                    fprintf(ffile, "%d ", 
                       *((int *)(this->base_addr) + i + j*imax + k*jmax*imax));
                }
                fprintf(ffile, "\n");
              }
            }
            break;
          default:
            fprintf(ffile, "no code to handle integer rank %d yet\n", this->rank);
            break;    
        }
        break;
      default:
            fprintf(ffile, "no code to handle data type %d yet\n", this->type);

      break;
    }

    fclose(ffile);

    rc = ESMF_SUCCESS;
    return rc;

 } // end ESMC_LocalArrayWrite

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// native constructor/destructors
//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ESMC_LocalArray - native C++ constructor
//
// !INTERFACE:
      ESMC_LocalArray::ESMC_LocalArray(
//
// !RETURN VALUE:
//    none
//
// !ARGUMENTS:
      void) {  // in
//
// !DESCRIPTION:
//      Calls standard ESMF deep or shallow methods for initialization
//      with default or passed-in values
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

//
//  code goes here
//

 } // end ESMC_LocalArray

//-----------------------------------------------------------------------------
//BOP
// !IROUTINE:  ~ESMC_LocalArray - native C++ destructor
//
// !INTERFACE:
      ESMC_LocalArray::~ESMC_LocalArray(void) {
//
// !RETURN VALUE:
//    none
//
// !ARGUMENTS:
//    none
//
// !DESCRIPTION:
//      Calls standard ESMF deep or shallow methods for destruction
//
//EOP
// !REQUIREMENTS:  SSSn.n, GGGn.n

//
//  code goes here
//

 } // end ~ESMC_LocalArray


