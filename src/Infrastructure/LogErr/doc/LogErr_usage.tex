% $Id: LogErr_usage.tex,v 1.14 2004/11/16 22:40:35 cpboulder Exp $

%\subsection{Use and Examples}

A default Log is created at {\tt ESMF\_Initialize()}.  ESMF handles 
the initialization and finalization of the default Log so the user 
can immediately start using it.  A single default Log is opened 
in the directory that initializes the default Log.  If a Log is 
not present, a new one is created.  If multiple Logs are 
desired, they must be explicitly created or opened using 
{\tt ESMF\_LogOpen()}.

If a user wants to use a new or different Log, the user must call
{\tt ESMF\_LogOpen()} and pass in a Log object and filename to open a Log 
file.
 
By default, the Log file is not truncated at the start of a new run; it just
gets appended each time.  Future functionality would include an option to
either truncate or append to the Log file. 

In all cases where a Log is opened, a unit number is assigned to a specific
Log.  A Log is assigned the lowest available unit number starting with
11.  If a unit number is occupied, the next higher unit number is 
checked using the "inquire" method.  The process repeats until a free unit 
number is found or when the unit number reaches {\tt ESMF\_LOGUPPER} in 
which case an error is returned.  As a result, the user should always check
for free numbers using "inquire" to prevent potential unit number conflicts.
In the near future we anticipate supporting an option in which a desired
unit number can be passed in.

The user can then set or get options on how the Log should be used 
with the {\tt ESMF\_LogSet()} and {\tt ESMF\_LogGet()} methods.  These are 
partially implemented at this time. 

Depending on how the options are set, {\tt ESMF\_LogWrite()} either writes user
messages directly to a Log file or writes to a buffer that can be flushed when 
full or by using the {\tt ESMF\_LogFlush()} method.  The default is to flush 
after every {\tt ESMF\_LogWrite()} because {\tt maxElements} is initialized to
one (which means the buffer reaches its full state after each write, therefore,
flushing.

For every {\tt ESMF\_LogWrite()}, a time and date stamp is prepended to the
Log entry.  The time is given in microsecond precision.

When calling {\tt ESMF\_LogWrite()}, the user can supply an optional line,
file and method.  These arguments can be passed in explicitly or with the help
of cpp macros.  In the latter case, a define for an {\tt ESMF\_FILE} must be 
placed at the beginning of the code and a define for {\tt ESMF\_METHOD} must
be placed at the beginning of each method.  The user can then use the
{\tt ESMF\_CONTEXT} cpp macro in place of line, file and method to insert the 
parameters into the method.  The user does not have to specify line number as
it is a value supplied by cpp.

An example of log output is given below:

20041105 163418.472210 INFO      Running with ESMF Version 2.0.2   

20041105 163419.186153 ERROR     ESMF_Field.F90             812  ESMF_FieldGet
No Grid or Bad Grid attached to Field

The first entry of the shows date and time stamp.  The time is given in 
microsecond precision.  The next item shown is the type of message (INFO 
in this case).  Lastly, the context is written.

The second entry shows something slightly different.  In this case, we have
an ERROR.  The method name (ESMF\_Field.F90) is automatically provided from 
the cpp macros as well as the line number (812).  Lastly, the context of the 
message is written.
 
When done writing messages, the Log is closed by calling 
{\tt ESMF\_LogClose()} which will release the assigned unit number.




