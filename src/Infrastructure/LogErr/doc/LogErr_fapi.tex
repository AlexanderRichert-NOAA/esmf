%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_LogErr.F90,  Date: Thu Aug  7 10:28:16 EDT 2003
}

 
%/////////////////////////////////////////////////////////////

  ============================================================================\subsection{Fortran:  Module Interface Fortran Interface to Log class.  (Source File: ESMF\_LogErr.F90)}


  
  
   The Fortran interface to the {\tt ESMF\_Log} class is written in both
   Fortran and C/C++.
   This file contains the interface code written in Fortran.  It also contains
   some utility functions used by the {\tt ESMF\_Log} class.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogCloseFile] {ESMF\_LogCloseFile - closes a file from Fortran code}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}      subroutine ESMF_LogCloseFile(aLog)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Log), intent(in) :: aLog\end{verbatim}
{\sf DESCRIPTION:\\ }


   Calls c\_esmf\_logclosefile() (defined in ESMC\_LogInterface.C), the wraper for the method {\tt ESMC\_LogCloseFileForWrite} which closes aLog's 
   log file.
  
   The arguments are
   \begin{description}
   \item[aLog]
    an ESMG\_Log object
  
    \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection [ESMF\_LogOpenFile] {ESMF\_LogOpenFile - opens a log file}


\bigskip{\sf INTERFACE:}
\begin{verbatim} subroutine ESMF_LogOpenFile(aLog, numFile, name)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Log) :: aLog
 
   integer :: numFile                              
 
   character(len=*) :: name
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   This routine finds the first space in the array name and inserts a
   a null character. It then calls {\tt ESMC\_LogOpenFileForWrite} 
   an {\tt ESMC\_Log} method for opening files.
  
   The arguments are:
   \begin{description}
   
   \item[aLog]
   Log object.
  
   \item[numFile]
   Set to either ESMF\_SINGLE\_FILE or ESMF\_MULTIPLE\_FILE
   
    \item[name]
    name of file
   
    \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogSet] {ESMF\_LogSet - initialize an error object.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} subroutine ESMF_LogSet(aLog, verbose, flush, haltOnErr, haltOnWarn)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  type(ESMF_Log), intent(in) :: aLog
  type(ESMF_Logical), intent(in), optional :: verbose
  type(ESMF_Logical), intent(in), optional :: flush
  type(ESMF_Logical), intent(in), optional :: haltOnErr
  type(ESMF_Logical), intent(in), optional :: haltOnWarn \end{verbatim}
{\sf DESCRIPTION:\\ }


  
     With the exception of the {\tt ESMF\_Log} object, all the arguments
     are optional.
     See the Examples section of the document for a discussion of how to use
     the routine.
  
     The arguments are:
     \begin{description}
  
     \item[verbose]
     If set to ESMF\_TF\_TRUE, output written to Log file.                   
    \item[flush]                                                       
     If set to ESMF\_TF\_TRUE, output is flushed.                                  
    \item[haltOnWarn]                                              
     If set to ESMF\_TF\_TRUE, code stops on warnings.                             
    \item[haltOnErr]                                                   
     If set to ESMF\_TF\_TRUE, code stops on errors.                               
  
    \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogGet] {ESMF\_LogGet - gets attributes of log object }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} subroutine ESMF_LogGet(aLog, verbose, flush, haltOnErr, haltOnWarn)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  type(ESMF_Log), intent(in) :: aLog
  type(ESMF_Logical), intent(out), optional :: verbose
  type(ESMF_Logical), intent(out), optional :: flush 
  type(ESMF_Logical), intent(out), optional :: haltOnWarn 
  type(ESMF_Logical), intent(out), optional :: haltOnErr\end{verbatim}
{\sf DESCRIPTION:\\ }


  
     With the exception of the {\tt ESMF\_Log} object, all the arguments
     are optional.
     See the Examples section of the document for a discussion of how to use the
     routine.
    
     The arguments are:
     \begin{description}
  
     \item[verbose]
     If present, return value in argument. 
    \item[flush]
     If present, return value in argument. 
    \item[haltOnWarn]
     If present, return value in argument. 
    \item[haltOnErr]
     If present, return value in argument. 
  
    \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection [ESMF\_LogWarnMsg] {ESMF\_LogWarnMsg - writes a warning message to the log file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} subroutine ESMF_LogWarnMsg_(aLog, errCode, line,file,dir,msg)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Log) :: aLog
 
     integer, intent(in) :: errCode               
 
     character(len=*), intent(in) :: msg 
 
     integer, intent(in) :: line        
                                      
 
     character(len=*), intent(in) :: file  
                                          
 
     character(len=*), intent(in) :: dir   
                                         
 \end{verbatim}
{\sf DESCRIPTION:\\ }


      This routine calls c\_esmf\_logerrmsg in ESMC\_LogErrInterface.C
      to write a warning message to the log file.  This warning
      message consists of the erroCode, a description of the warning, the 
      line number, file, and directory of the error, and a message. A 
      preprocessor macro adds the predefined preprocessor symbolic
      constants \_\_LINE\_\_, \_\_FILE\_\_, and \_\_DIR\_\_ when
      {\tt ESMF\_LogWarnMsg} is called user code.  Note,
      the value of \_\_DIR\_\_ 
      must be suppliled by the user (usually done in
      the makefile.).  By default, execution continues after encountering
      a warning, but by calling the routine ESMF\_LogWarnHalt(), the user
      can halt on warnings.
  
      The arguments are
      \begin{description}
     
      \item[errCode]
      integer value for error code
  
      \item[msg]
      msg written to log file
  
      \item[line]
      line number of warning; argument supplied by macro
  
      \item[file]
      file where warning occurred in;argument supplied by macro
  
      \item[dir]
      directory where warning occurred in; argument supplied by macro
    
      \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogWarn] {ESMF\_LogWarn - writes a warning message to log file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_LogWarn_(aLog, errCode,line,file,dir)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Log) :: aLog
 
     integer, intent(in) :: errCode         
 
     integer, intent(in) :: line            
                                          
 
     character(len=*), intent(in) :: file   
                                            
 
     character(len=*), intent(in) :: dir    
                                          
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     This routine is identical to {\tt ESMF\_LogWarnMsg}, except a msg is
     not written to the log file.
  
     The arguments are:
     \begin{description}
  
     \item[errCode]
     Error code
  
     \item[line]
     line number of warning; argument supplied by macro
  
     \item[file]
     file where warning occurred in; argument supplied by macro
  
     \item[dir]
     directory where warning occurred in; argument supplied by macro
  
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogErr] {ESMF\_LogErr - writes a error message to log file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}  subroutine ESMF_LogErrMsg_(aLog, errCode,line,file,dir,msg)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Log) :: aLog
 
     integer, intent(in) :: errCode       
 
     character(len=*), intent(in) :: msg   
 
     integer, intent(in) :: line            
                                            
 
     character(len=*), intent(in) :: file   
                                           
 
     character(len=*), intent(in) :: dir   
                                           
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     This routine is identical to {\tt ESMF\_LogErrMsg}, except a msg is
     not written to the log file.
  
     The arguments are:
     \begin{description}
  
     \item[errCode]
     Error code   
  
     \item[line]
     line number of warning; argument supplied by macro
  
     \item[file]
     file where warning occurred in; argument supplied by macro
  
     \item[dir]
     directory where warning occurred in; argument supplied by macro
  
     \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogErr] {ESMF\_LogErr - writes a error message to log file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}  subroutine  ESMF_LogErr_(aLog, errCode,line,file,dir)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Log) :: aLog
 
     integer, intent(in) :: errCode     
 
     integer, intent(in) :: line           
                                         
 
     character(len=*), intent(in) :: file 
                                           
 
     character(len=*), intent(in) :: dir    
                                         
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     This routine is identical to {\tt ESMF\_LogErrMsg}, except a msg is
     not written to the log file.
  
     The arguments are:
     \begin{description}
  
     \item[errCode]
     Error code   
  
     \item[line]
     line number of warning; argument supplied by macro
  
     \item[file]
     file where warning occurred in; argument supplied by macro
  
     \item[dir]
     directory where warning occurred in; argument supplied by macro
                                                                     
     \end{description}  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogOpenFortran] {ESMF\_LogOpenFortran}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} subroutine ESMF_LogOpenFortran(isOpen, unitNumber, nameLogFile)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Logical), intent(out) ::  isOpen     
 		                           
 			                   
 
   integer, intent(inout) ::  unitNumber 
 
   character (len=32), intent(in) :: nameLogFile
      \end{verbatim}
{\sf DESCRIPTION:\\ }


   This routine opens the log file and is called by {\tt ESMC\_LogWrite}.
   See the ESMC\_LogErr.C file for more details.
   This routine is not a module procedure because F90 mangles
   the names of functions
   inside modules and this routine is called by ESMC\_LogWrite() - a C++
   method.
  
   The arguments are:
   \begin{description}
  
   \item[isOpen]
   If file successfully opened isOpen set to ESMF\_TF\_TRUE otherwise set
   to ESMF\_TF\_FALSE
  
   \item[unitNumber]
   standard Fortran unit number for I/O
  
   \item[nameLogFile]
   name of log file
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogCloseFortran] {ESMF\_LogCloseFortran}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_LogCloseFortran(unitNumber)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     integer, intent(in) :: unitNumber\end{verbatim}
{\sf DESCRIPTION:\\ }


   This routine closes any log files that have been written to using
   the Fortran interface.  It is called by by the C/C++ Log
   method ESMC\_LogFinalize().
  
   The arguments are;
   \begin{description}
  
   \item[unitNumber]
   standard Fortran unit number for I/O
  
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogPrintNewLine] {ESMF\_LogPrintNewLine - prints a newline character}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_LogPrintNewLine(unitNumber,flushSet)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Logical), intent(in)::flushSet
   integer, intent(in)::unitNumber
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   Prints a newline character. 
  
   The arguments are:
   \begin{description}
  
   \item[flushSet]
   If set to ESMF\_TF\_TRUE, out flushed.
  
   \item[unitNumber]
   standard Fortran unit number for I/O
  
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_LogPrintString] {ESMF\_LogPrintString - prints a string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  subroutine ESMF_LogPrintString(unitNumber,stringToPrint,flushSet)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Logical), intent(in)::flushSet
   integer, intent(in) :: unitNumber
   character(len=*), intent(in)::stringToPrint
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   This routine, is used by ESMC\_LogPrint() and
   ESMC\_LogPrintHeader() in the Log class to print a string.
   Ordinarily, these Log routines would
   have just used fprintf.  However, because we need to allow one
   to use the Fortran I/O 
   libraries when Fortran I/O is selected
   (see the discussion about the class design), we need to call a
   Fortran routine to do the printing
   and this is the one!
    
   ! The arguments are:
   \begin{description}
  
   \item[unitNumber]
   standard Fortran unit number for I/O
  
   \item[stringToPrint]
   String to be printed.
  
   \item[flushSet]
   If set to ESMF\_TF\_TRUE, out flushed.
  
   \end{description}
%...............................................................
