// $Id: ESMC_MeshVTK.C,v 1.1 2007/08/07 17:48:01 dneckels Exp $
//
// Earth System Modeling Framework
// Copyright 2002-2007, University Corporation for Atmospheric Research, 
// Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
// Laboratory, University of Michigan, National Centers for Environmental 
// Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
// NASA Goddard Space Flight Center.
// Licensed under the University of Illinois-NCSA License.
//
//==============================================================================
#include <ESMC_MeshVTK.h>
#include <ESMC_Mesh.h>
#include <ESMC_MEField.h>

#include <iostream>
#include <fstream>
#include <map>

namespace ESMCI {
namespace MESH {

enum {VTK_TRIANGLE=5, VTK_QUAD=9, VTK_TETRA=10, VTK_HEXAHEDRON=12};


// Load data into an array from the mesh, switching on the correct typeid
template<typename iter, typename FIELD>
static void get_data(iter ni, iter ne, const FIELD &llf, double data[], UInt d) {
  UInt i = 0;
  if (llf.tinfo() == typeid(double)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
        data[i] = ((double*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else if (llf.tinfo() == typeid(int)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
      data[i] = ((int*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else if (llf.tinfo() == typeid(float)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
      data[i] = ((float*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else if (llf.tinfo() == typeid(long)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
      data[i] = ((long*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else if (llf.tinfo() == typeid(char)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
      data[i] = ((char*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else if (llf.tinfo() == typeid(UChar)) {
    for (; ni != ne; ++ni) {
      if (llf.OnObj(*ni))
      data[i] = ((UChar*)llf.data(*ni))[d];
      else data[i] = 0;
      i++;
    }
  } else std::cout << "Unknown data type, skipping ";
}


void WriteVTKMesh(const Mesh &mesh, const std::string &filename) {

  std::ofstream out(filename.c_str(), std::ios::out);

  out << "# vtk DataFile Version 3.0" << std::endl;
  out << "This file was generated by DVD " << std::endl;
  out << "ASCII" << std::endl;
  out << "DATASET UNSTRUCTURED_GRID" << std::endl;
  out << "POINTS " << mesh.num_nodes() << " double" << std::endl;
  

  std::map<MeshObj::id_type, int> id2ord;

  {
    MEField<> &coord = *mesh.GetCoordField();
    Mesh::const_iterator ni = mesh.node_begin(), ne = mesh.node_end();
    for (UInt i = 0; ni != ne; ++ni) {
      const MeshObj &node = *ni;
      double *cd = coord.data(node);
      // Write coordinates
      out << cd[0] << " " << cd[1] << " " << (mesh.spatial_dim() == 3 ? cd[2] : 0.0) << std::endl;
  
      // Increment ordinal
      id2ord[node.get_id()] = i++;
    }
  }

  // Now figure out how large the cell index list is:
  int cell_size = 0, num_elem = 0;
  {
    Mesh::const_iterator ei = mesh.elem_begin(), ee = mesh.elem_end();
    for (; ei != ee; ++ei) {
      const MeshObj &elem = *ei;
      const MeshObjTopo *topo = GetMeshObjTopo(elem);
      cell_size += 1+topo->num_nodes; // 1 for the num connectivity
      num_elem++;
    }
  }

  out << "CELLS " << num_elem << " " << cell_size << std::endl;

  // Now print the connectivity
  {
    Mesh::const_iterator ei = mesh.elem_begin(), ee = mesh.elem_end();
    for (; ei != ee; ++ei) {
      const MeshObj &elem = *ei;
      const MeshObjTopo *topo = GetMeshObjTopo(elem);

      out << topo->num_nodes << " ";
      for (UInt n = 0; n < topo->num_nodes; n++) {

        MeshObj::id_type id = elem.Relations[n].obj->get_id();
        std::map<MeshObj::id_type,int>::iterator imi = id2ord.find(id);
        ThrowRequire(imi != id2ord.end());

         out << imi->second << " ";

      }

      out << std::endl;

    } // for ei

  } // print connectivity

  // Now print the cell types
  out << "CELL_TYPES " << num_elem << std::endl; 
  {
    Mesh::const_iterator ei = mesh.elem_begin(), ee = mesh.elem_end();
    for (; ei != ee; ++ei) {
      const MeshObj &elem = *ei;
      const MeshObjTopo *topo = GetMeshObjTopo(elem);

      switch(topo->num_nodes) {
        case 3:
          out << VTK_TRIANGLE << std::endl;
        break;

        case 4:
          if (topo->parametric_dim == 3) {
//std::cout << "tetra!@!" << std::endl;
            out << VTK_TETRA << std::endl;
          } else {
//std::cout << "quad!@! " << mesh.parametric_dim() << std::endl;
            out << VTK_QUAD << std::endl;
          }
        break;

        case 8:
          out << VTK_HEXAHEDRON << std::endl;
        break;
 
        default:
          Throw() << "Unsupported VTK element type:" << topo->name << std::endl;
      }

    }

  } // print cell types

  // Now element variables
  {
     FieldReg::MEField_const_iterator nv = mesh.Field_begin(), ne = mesh.Field_end();

     bool firstvar = true;
     std::vector<double> data(num_elem, 0);
     for (; nv != ne; ++nv) {
       const MEField<> &mf = *nv;
       if (mf.Output() && mf.is_elemental()) {

         for (UInt d = 0; d < mf.dim(); d++) {
           char buf[512];
           std::sprintf(buf, "_%d", d);
           std::string vname = mf.name() + (mf.dim() == 1? "" : std::string(buf));

           if (firstvar) {
             out << "CELL_DATA " << num_elem << std::endl;
             firstvar = false;
           }
           out << "SCALARS " << vname << " double 1" << std::endl;
           out << "LOOKUP_TABLE default" << std::endl;

           const _field &llf = mf();
           get_data(mesh.elem_begin(), mesh.elem_end(), llf, &data[0], d);
           
           for (UInt e = 0; e < (UInt) num_elem; e++)
             out << data[e] << " ";

           out << std::endl;

         } //for d

       } // is elemental/output

     }// fields

  } // elem vars

  // And next, nodal variables
  {
  } // nodal vars
  
}


} // namespace
} // namespace
