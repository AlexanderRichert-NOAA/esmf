

\subsubsection{Grid Composition}\label{sec:gridcomp}
  An ESMF Grid is constructed of a hierarchy of elements. At the top
level a grid is constructed of a set of tiles. Each tile is a logically
rectangular distributed index space. A tile will usually have some
physical significanc (e.g. the face of a cube). The piece of a tile
which resides on one DE is called a local tile. The six faces of a
cube sphere Grid are each tiles and each of 
the tiles/faces can be divided into many local tiles by its distribution 
across processors. 

% Need to work Cells into the above??

\subsubsection{Grid Topology} 

The {\tt ESMF\_Grid} class depends upon the {\tt ESMF\_DistGrid} class
for the specification of its topology. That is, when 
creating a Grid, first an {\tt ESMF\_DistGrid} is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the {\tt ESMF\_Array} class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. {\tt ESMF\_GridGenSphere}) a set of standard
topology generation subroutines be implemented (e.g. {\tt ESMF\_DistGridGenSphere}) for users who want to create a standard topology, but a custom geometry.


\subsubsection{Stagger Locations}\label{ref:stagger}
A useful finite difference technique is to place different physical quantities at different locations within a grid cell. This {\em {staggering}} of the physical variables on the mesh is introduced so that the difference of a field is naturally defined at the location of another variable. This method was first formalized by Mesinger and Arakawa (1976).

The default or {\em{Arakawa A-grid}} staggering colocates all the variables on the mesh. All other {\em{staggerings}} separate the location of the scalar or {\em{mass}} quantities from the vector or {\em{velocity}} components. The Arakawa classification is not unique in itself for grids B-D. There are four vertices to choose from in the B-grid, and four faces to choose from in the C and D grids. However, the need for this level of specification has been eliminated by imposing symmetric staggers.

While the Arakawa classification can specify the stagger for two dimensional grids, it does not generalize to higher dimensions. To completely specify stagger for an arbitrary number of dimensions, a different approach is introduced. We define the stagger location in terms of a set of cartesian coordinates. The cell is represented by a n-dimensional cube with sides of length 2, and the coordinate origin located at the center of the cell. The geometry of the cell is for reference purposes only, and does not literally represent the actual shape of the cell. Think of this method instead as an easy way to specify a part (e.g. center, corner, face) of a higher dimensional cell which is extensible to any number of dimensions. 

To illustrate this approach, consider again the Arakawa staggerings. In 2 dimensions the cell is represented by a square. An xy axis is placed at its center, with the positive x-axis oriented {\em East} and the positive y-axis oriented {\em North}. The resulting coordinate for the lower left corner is at $(-1,-1)$, and upper right corner at $(1,1)$.
However, because our staggers are symmetric they don't need to distinguish between the $-1$, and the $1$, so
we only need concern ourselves with the first quadrant of this cell. We only need to use the $1$, and the $0$, and
many of the cell locations collapse together (e.g. we only need to represent one corner). 

\begin{verbatim}
                                (0,1)-EDGE2     (1,1)-CORNER
  1  *-------*-------*         1  *---------------* 
     |               |                            |
     |               |                            | 
     |       |       |                            | 
  0  *       +-      *                            |  
     |               |                            | 
     |               |            |               |  EDGE1
     |               |            |               |   |
 -1  *-------*-------*         0  *----           * (1,0)
    -1       0       1            0               1

        Full Cell               Just The 1st Quadrant
                                
\end{verbatim}


An A-grid is represented by the coordinate pair $(0,0)$ indicating the cell center, since by definition all variables are located at the origin. The B-grid places the staggered location at the corners. A corner is represented
by the relative location $(1,1)$. So the B-grid would consist of the following:
\begin{description}
\item [Center:] $(0,0)$
\item [Corner:] $(1,1)$
\end{description}

The C and D-grid place the staggered location on one of the four edges. The edge associated with the first dimension (e.g. x) is indicated by the relative location $(1,0)$. The edge associated with the second dimension (e.g. y) is indicated by the relative location $(0,1)$. So the C and D grids consist of the following stagger locations:
\begin{description}
\item [Center:] $(0,0)$
\item [1st Dim Edge:] $(1,0)$
\item [2nd Dim Edge:] $(0,1)$
\end{description}

For three dimensions, the vertical location of the staggering can be added by simply adding an additional coordinate. The three dimensional generalization of the A-grid becomes one of the two cases,
\begin{description}
\item [Vertical Face:] $(0,0,1)$
\item [Vertical Center:] $(0,0,0)$
\end{description}
This representation is general enough to describe configurations beyond that of the Arakawa classification, such as a staggering where one variable lives on the cell walls and another variable lives on the cell corners.

To implement this more generalized stagger location, the Grid contains
a new class {\tt ESMF\_StaggerLoc} which specifies a particular stagger
location in a grid cell (e.g. the corner). This class has an
associated set of subroutines (see Section~\ref{ref:stagsub}) which use
the above coordinate method for defining a particular location. 
The final implementation of the stagger location will also contain a
large set of predefined stagger locations for ease of use. 

\subsubsection{Storage and Distribution of Stagger Locations in Grid}

The primarily complication in the storage of multiple stagger locations in a Grid is that different variables in a symmetric stagger can require a different amount of storage depending on the underlying grid type.  For example while h,u, and v on an A-grid all require n x m arrays, on a B-grid u and v require n+1 x m+1. On a C or D grid one vector component requires n+1 x m and the other n x m+1. To handle this complication the natural approach would be to define each stagger's storage to what is necessary for that grid type. This approach introduces a problem when the arrays are distributed, because they are different sizes. It is non-trivial to guarantee that the (i,j) element of all three of arrays ends up on the same processor. It is simpler to guarantee a consistent distribution of the arrays when using the same distGrid if they are the same size.

This may sound like a contradiction, but to be more precise we choose the exclusive region of each array to be the same size (say n x m), and pad the arrays that need it with additional memory from the computational region of the ARRAY class. Recall that the exclusive region is defined as the cells for which the DE claims exclusive ownership. These are the cells updated by computations local to that DE. The exclusive region is a subset of the computation region. The computational region contains all the cells kept locally on the DE in addition to the exclusive cells. By using the computational region as padding we are able to guarantee a consistent distribution of the arrays and at the same time impose a symmetric stagger. This approach extends naturally to the connected/periodic cases because the padding can be used to hold the values across the branch cut.

The biased configuration (where each stagger location has the same number of elements) falls out trivially by setting an optional padding argument ({\tt globalComputationUBound}) to zero. This argument can also be used to adjust where the stagger padding is located or
to add extra for halos. 



