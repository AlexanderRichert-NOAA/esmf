% $Id: Attribute_implnotes.tex,v 1.15 2009/05/04 05:59:30 eschwab Exp $
%
% Earth System Modeling Framework
% Copyright 2002-2009, University Corporation for Atmospheric Research,
% Massachusetts Institute of Technology, Geophysical Fluid Dynamics
% Laboratory, University of Michigan, National Centers for Environmental
% Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
% NASA Goddard Space Flight Center.
% Licensed under the University of Illinois-NCSA License.

This section covers Attribute memory deallocation, the use of {\tt ESMF\_AttributeGet()}, Attribute package nesting capabilities, issues with Attributes in a distributed environment, and reading of Attributes via XML files.  Issues and procedures dealing with Attribute memory deallocation using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists, and nested Attribute package capabilities are discussed to help avoid misuse.  The limitations with Attributes in a distributed environment are also discussed, with an outline of the future work to be done in this area. 

\subsubsection{Attribute Memory Deallocation}

The Attribute class presents a somewhat different paradigm with respect to memory deallocation than other ESMF objects.  The {\tt ESMF\_AttributeRemove()} call can be issued to remove any Attribute from an ESMF object or an Attribute package on an ESMF object.  This call is also enabled to remove entire Attribute packages with one call, which would remove any nested Attribute packages as well.  The user is {\bf not} required to remove all Attributes that are used in a model run.  The entire Attribute hierarchy will be removed automatically by ESMF, provided the ESMF objects which contain them are properly destroyed.  

\subsubsection{Using {\tt ESMF\_AttributeGet()} to retrieve Attribute lists}

The behavior of the {\tt ESMF\_AttributeGet()} routine,when retrieving an Attribute containing a value list, follows a slightly different convention than other similar ESMF routines.  This routine requires the input of a Fortran array as a place to store the retrieved values of the Attribute list.  If the array that is given is longer that the list of Attribute values, the first part of the array will be filled, leaving the extra space untouched.  If, however the array passed in, is shorter than the number of Attribute values, the routine will exit with an {\bf ESMF\_FAILURE} return code.  It is suggested that if it is required by the user to use a Fortran array that is longer than the number of Attribute values returned, only the indices of the array which the user desires to be filleds should be passed into the routine.  
  
\subsubsection{Using Attribute package nesting capabilites}

There is a recommended practice when using nested Attribute packages to organize metadata conventions.  The most general Attribute packages should always be added first, followed by the more specific ones.  For instance, when adding Attribute packages to a Field, it is recommend that the CF convention be added first, followed by the ESG convention, followed by any additional customized Attribute packages.  In a future release the standardized Attribute packages will be added automatically by ESMF, but until that time this recommendation stands.

Another consideration when using nested Attribute packages is to remember to specify that the nesting capability is desired by setting the {\it attpacknestflag} argument to {\bf ESMF\_ATTPACKNEST\_ON}.  In addition, when a nested Attribute package is removed, every nested Attribute package below the point of removal will also be removed.  Thus, by removing the CF Attribute package on a Field, the ESG and any other customized Attribute packages will also be removed.

\subsubsection{Attributes in a Distributed Environment}
\label{sec:Att:Dist}

The Attribute class is slightly different than other ESMF objects in the context of building a consistent view of the metadata across the VM.  To better explain the ESMF capabilities for ensuring the integrity of Attributes in a distributed environment, a small working vocabulary of ESMF Attributes will be presented.  Three types of changes to an Attribute hierarchy need to be specified, these are: 1. {\bf link changes} are structural links created when two separate Attribute hierarchies are linked, 2. {\bf structural changes} are changes which occur when Attributes or Attribute packages are added or removed within a single level of an Attribute hierarchy, and 3. {\bf value changes} occur when the value portion of any single Attribute is modified.  These definitions will help to describe how {\tt ESMF\_StateReconcile()} and {\tt ESMF\_AttributeUpdate()} can be effectively used to ensure a consistent view of metadata throughout a model run.

The {\tt ESMF\_StateReconcile()} call is used to create a consistent view of ESMF objects over the entire VM in the initialization phase of a model run.  All Attributes that are attached to an ESMF object contained in the State, i.e. an object that is being reconciled, can also be reconciled.  This is done by setting a flag in the {\tt ESMF\_StateReconcile()} call, see the State documentation for details.  This means that, at the conclusion of {\tt ESMF\_StateReconcile()} there is a one-to-one correspondence between Attribute hierarchies and the objects to which they belong.  This is the only place where link changes in an Attribute hierarchy can be resolved.

The {\tt ESMF\_AttributeUpdate()} call can be used any time during the run phase of a model to insure that either structural or value changes made to an Attribute hierarchy on a subset of the VM are consistently represented across the remainder of the VM.  This call is similar to {\tt ESMF\_StateReconcile()} in that it must be called from a location that has a view of the entire VM across which to update the Attribute hierarchy, such as a coupler Component.  The main difference is that {\tt ESMF\_AttributeUpdate()} operates only on the underlying Attribute hierarchy of the given ESMF object.  The Attribute hierarchy may be updated as many times as necessary, this call is much more efficient than {\tt ESMF\_StateReconcile()} for this reason.  The specification of a list of PETs that are to be used as the basis for the update is one such efficiency boost, as this allows a many-to-many communication.

\subsubsection{Copying Attribute hierarchies}

The ability to copy an Attribute hierarchy is limited at this time.  The {\tt ESMF\_AttributeCopy()} routine can be used to {\it locally} copy an Attribute hierarchy between States.  It is important to note that this is a local copy, and no inter-PET communication is carried out.  Another thing to note is that when this functionality is based on a reference copy any further changes made to some portions of the original Attribute hierarchy will also affect the new Attribute hierarchy.

There are two flags in the {\tt ESMF\_AttributeCopy()} routine which specify which type of copy is desired.  At this point there are only two different varieties of Attribute hierarchy copies available.  One of the requires the {\tt ESMF\_AttCopyFlag} to be set to {\tt ESMF\_ATTCOPY\_VALUE} and the {\tt ESMF\_AttTreeFlag} to be set to {\tt ESMF\_ATTTREE\_OFF}.  This does a copy of only the first level of an Attribute hierarchy, by value.  In future ESMF will allow a full Attribute hierarchy value copy.  

The second available copy can be applies by setting the {\tt ESMF\_AttCopyFlag} to {\tt ESMF\_ATTCOPY\_HYBRID} and the {\tt ESMF\_AttTreeFlag} does not matter.  This copy is more of a hybrid approach of reference and value copies.  In this case the Attributes which {\it belong} to the object being copied are actually copied in full (by value), while the Attributes which are linked to the object being copied are referenced by a pointer (by reference).  This means that after copying an Attribute hierarchy from ESMF object A to ESMF object B with this approach, the changes made to the lower portion of either A or B's Attribute hierarchy will be reflected on {\it both} object A and object B.

\subsubsection{Reading Attributes from XML files}

The Xerces C++ library is used to read XML files.  More specifically, the SAX2 API is currently used, although future releases may also use the DOM API.  The Xerces C++ website is http://xerces.apache.org/xerces-c/.
