% $Id: Field_usage.tex,v 1.4 2003/12/17 20:20:26 svasquez Exp $

%\subsection{Design}

% <Describe strategy for overall class design.>


The Field class aggregates two internal subclasses: a GlobalField class
and a LocalField class.  This separation allows the code to clearly
differentiate between functions which operate internal to a single DE
on a local decomposition of data, 
and those which must be aware of the
global state of the Field.  
 
There is a correspondence between the Global Distributed Grid class,
and the Local Distributed Grid class, and Fields.  Each DE contains
the corresponding local decompositions for Distributed Grids and Fields.

The Field class maintains the relationship of
how data maps onto the grid (e.g. one item per cell located at
the cell center, one item per cell located at the NW corner, 
one item per cell vertex, etc).  This means that different Fields
which are on the same underlying Grid but have different
mappings (staggerings) can share the same Grid object without
needing to copy or replicate it multiple times.  Regridding
operations can operate first on the shared Grid, and then
use the staggering information from the Field to compute the
corresponding transformation of the data.

Some methods which have a Field interface will actually be
implemented at the underlying Grid or Array level; they
will be inherited by the Field class.  This allows the user
API (Application Programming Interface) to present functions at
the level which is most consistent to the application without
restricting where inside the ESMF the actual implementation
is done.

\input{../Infrastructure/Field/doc/ESMF_FieldCreateEx_fapi}

% cecelia - this is the new section on the data interfaces to the
% communications routines.  move it where you want.   nsc 31jul03

\subsection{Distributed Data Methods}

There are ten methods which involve movement of data between DEs.
The first three are higher level functions which are intended to
map closely to needs of applications programs.  They are:

\subsubsection{Halo}
\input{../Infrastructure/ArrayComm/doc/ArrayHalo_desc.tex}

\subsubsection{Regrid}
\input{../Infrastructure/Regrid/doc/Regrid_usage.tex}

\subsubsection{Redist}
\input{../Infrastructure/ArrayComm/doc/ArrayRedist_desc.tex}

\subsubsection{Lower Level Functions}
The last seven correspond closely to the lower level
MPI communications primitives.  They are:
\begin{description}
\item[Gather]
Reassembling data which is decomposed over a set of DEs into a single
block of data on one DE.
\item[AllGather]
Reassembling data which is decomposed over a set of DEs into multiple
copies of a single block of data, one copy per original DE.
\item[Scatter]
Spreading an undecomposed block of data on one DE over a set of DEs,
decomposing that single block into smaller subsets of data, one
data decomposition per DE.
\item[AlltoAll]
Spreading an undecomposed block of data from multiple DEs onto
each of the other DEs in the set, resulting in a set of multiple decomposed 
data blocks per DE, one from each of the original source DEs.
\item[Broadcast]
Spreading an undecomposed block of data from one DE onto all other
DEs, where the resulting data is still undecomposed and simply
copied to all other DEs.
\item[Reduction]
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to a single DE.
\item[AllReduce]
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to all DEs in the set.
\end{description}

Each of these methods can be called on Bundles, with and without packed
data, on Fields, and on Arrays.

