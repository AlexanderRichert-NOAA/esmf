! $Id: ESMF_FieldCreateGe.cppF90,v 1.1 2009/01/02 19:48:56 feiliu Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2008, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldCreateGe.F90"
!==============================================================================
!
! ESMF FieldCreateGe module
module ESMF_FieldCreateGeMod
!
!==============================================================================
!
! This file contains the GeomBase related FieldCreate() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"

!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_LogErrMod
  use ESMF_IOSpecMod
  use ESMF_ArraySpecMod
  use ESMF_LocalArrayMod
  use ESMF_DELayoutMod
  use ESMF_StaggerLocMod
  use ESMF_GridMod
  use ESMF_MeshMod
  use ESMF_LocStreamMod
  use ESMF_GeomBaseMod
  use ESMF_ArrayMod
  use ESMF_ArrayGetMod
  use ESMF_ArrayCreateMod
  
  use ESMF_FieldMod
  use ESMF_FieldSetCoMod
  use ESMF_FieldCreateBaMod
  
  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
!  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_FieldCreateGe.cppF90,v 1.1 2009/01/02 19:48:56 feiliu Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================


! -------------------------- ESMF-public method -------------------------------
!------------------------------------------------------------------------------
  public
!    ESMF_FieldCreateGBArraySpec
!    ESMF_FieldCreateGBArray
!    T-ypeKindRankInterfaceMacro(FieldCreateGBData)
!    T-ypeKindRankInterfaceMacro(FieldCreateGBDataPtr)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGBArraySpec"
!BOPI
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Grid and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGBArraySpec(geombase, arrayspec, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    maxHaloLWidth, maxHaloUWidth, name, iospec, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGBArraySpec
!
! !ARGUMENTS:
    type(ESMF_GeomBase) :: geombase
    type(ESMF_ArraySpec), intent(inout) :: arrayspec     
    integer, intent(in), optional :: gridToFieldMap(:)    
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    integer, intent(in), optional :: maxHaloLWidth(:)
    integer, intent(in), optional :: maxHaloUWidth(:)
    character (len=*), intent(in), optional :: name 
    type(ESMF_IOSpec), intent(in), optional :: iospec 
    integer, intent(out), optional :: rc              
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_grid_arrayspec}.
! 
! The arguments are:
! \begin{description}
! \item [geombase] 
!       {\tt ESMF\_GeomBase} object. 
! \item [arrayspec]
!       Data type and kind specification. 
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.  
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[maxHaloLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[maxHaloUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method. 
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[name]}] 
!       {\tt Field} name. 
! \item [{[iospec]}] 
!       I/O specification. ! NOT IMPLEMENTED
! \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOPI
!------------------------------------------------------------------------------
    type(ESMF_FieldType), pointer :: ftype      ! Pointer to new field
    integer :: localrc                          !  Local error code
    logical :: rcpresent                        ! Return code present
    integer :: fieldDimCount, fieldUngriddedDimCount 
    integer :: gridDimCount
    integer :: fieldUndistDimCount 
    integer :: i
    integer :: localGridToFieldMap(ESMF_MAXDIM)
    integer :: localMaxHaloLWidth (ESMF_MAXDIM)
    integer :: localMaxHaloUWidth (ESMF_MAXDIM)
    logical :: flipflop(ESMF_MAXDIM)


    ! Initialize pointers
    localrc = ESMF_RC_NOT_IMPL
    rcpresent = .FALSE.
    nullify(ftype)
    nullify(ESMF_FieldCreateGBArraySpec%ftypep)

    ! Initialize return code   
    if(present(rc)) then
      rcpresent=.TRUE.
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, ESMF_ArraySpecInit, arrayspec)

    ! Get rank of proposed Field.  
    call ESMF_ArraySpecGet(arrayspec, rank=fieldDimCount, rc=localrc) 
    if (ESMF_LogMsgFoundError(localrc, &  
         ESMF_ERR_PASSTHRU, &  
         ESMF_CONTEXT, rc)) return   

    ! Get number of grid dimensions, number  
    ! of distributed grid dimensions, distgrid,  
    ! number of ungridded Field dimensions,  
    ! and number of undistributed Field Dimensions  
    call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &  
        ESMF_ERR_PASSTHRU, &  
        ESMF_CONTEXT, rc)) return  
 
    if(fieldDimCount .lt. gridDimCount) then  
        call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
             "- farray rank must be greater than or equal to grid rank", &  
               ESMF_CONTEXT, rc)   
        return
    endif  

    if(fieldDimCount .gt. gridDimCount) then
      if( (.not. present(ungriddedLBound)) .or. &
          (.not. present(ungriddedUBound)) ) then
        call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
         "- ungridded bounds must be present when Field has ungridded dimension(s)", &
           ESMF_CONTEXT, rc)
        return
      endif
    endif

    fieldUngriddedDimCount = fieldDimCount-gridDimCount  
    fieldUndistDimCount = fieldDimCount-gridDimCount  
 
    ! Error Check Input  
    if (present(gridToFieldMap)) then   
        if (size(gridToFieldMap) .ne. gridDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- gridToFieldMap size must equal to grid_rank", &  
                ESMF_CONTEXT, rc)   
            return  
        endif  
    endif  
 
    if (present(ungriddedLBound)) then   
       if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then  
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
               "- ungriddedLBound size must equal to array_rank-grid_rank", &  
               ESMF_CONTEXT, rc)   
          return  
       endif  
    endif  
 
    if (present(ungriddedUBound)) then   
       if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then  
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
                 "- ungriddedUBound size must equal to array_rank-grid_rank", &  
                 ESMF_CONTEXT, rc)   
          return  
       endif  
    endif  
 
    if (present(maxHaloLWidth)) then   
        if (size(maxHaloLWidth) .ne. gridDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- maxHaloLWidth must equal to grid dimCount", &  
                ESMF_CONTEXT, rc)   
            return  
        endif  
    endif  
 
    if (present(maxHaloUWidth)) then   
       if (size(maxHaloUWidth) .ne. gridDimCount) then  
           call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- maxHaloUWidth must equal to grid dimCount", &  
                ESMF_CONTEXT, rc)   
           return  
       endif  
    endif  
 
    ! Set default gridToFieldMap
     if (present(gridToFieldMap)) then  
       localGridToFieldMap(1:gridDimCount) = &  
          gridToFieldMap (1:gridDimCount)  
     else  
       do i = 1, gridDimCount  
         localGridToFieldMap(i) = i  
       enddo  
     endif  

     ! gridToFieldMap elements must be in range 1...fieldRank and unique  
     ! algorithm to check element uniqueness:  
     !   run time: O(ESMF_MAXDIM)  
     !   memory:   O(2*ESMF_MAXDIM)  
     !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector  
     flipflop = .false.  
     do i = 1, gridDimCount  
        if(localGridToFieldMap(i) .lt. 1 .and. &  
          localGridToFieldMap(i) .gt. fieldDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                  "- gridToFieldMap element must be within range 1...array rank", &  
                    ESMF_CONTEXT, rc)   
            return  
        endif  
        if(flipflop(localGridToFieldMap(i))) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                  "- gridToFieldMap element must be unique", &  
                    ESMF_CONTEXT, rc)   
            return  
        endif  
        flipflop(localGridToFieldMap(i)) = .true.  
     enddo  
 
     if(present(maxHaloLWidth)) then  
       localMaxHaloLWidth(1:gridDimCount) = &  
          maxHaloLWidth (1:gridDimCount)  
     else  
          localMaxHaloLWidth = 0  
     endif  
 
     if(present(maxHaloUWidth)) then  
       localMaxHaloUWidth(1:gridDimCount) = &  
          maxHaloUWidth (1:gridDimCount)  
     else  
          localMaxHaloUWidth = 0  
     endif  

    ! allocate Fieldtype
    allocate(ftype, stat=localrc)
    if (ESMF_LogMsgFoundAllocError(localrc, &
                                "Allocating Field Type", &
                                ESMF_CONTEXT, rc)) return

    call ESMF_FieldInitialize(ftype, rc=localrc) 
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &
                                     ESMF_CONTEXT, rc)) return

    ! Call construction method to allocate and initialize field internals.
    call ESMF_FieldConstructIANew(ftype, geombase, arrayspec, &
                                localGridToFieldMap(1:gridDimCount), ungriddedLBound, &
                                ungriddedUBound, localMaxHaloLWidth(1:gridDimCount), &
                                localMaxHaloUWidth(1:gridDimCount), name, &
                                iospec, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
   
    ! Set return values.
    ESMF_FieldCreateGBArraySpec%ftypep => ftype
    ESMF_INIT_SET_CREATED(ESMF_FieldCreateGBArraySpec)

    call ESMF_FieldValidate(ESMF_FieldCreateGBArraySpec, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) then
        ESMF_FieldCreateGBArraySpec%ftypep%fieldstatus = ESMF_STATUS_INVALID
        return
    endif

    if(rcpresent) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGBArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateGBArray"
!BOPI
! !IROUTINE: ESMF_FieldCreate - Create a Field from Grid and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateGBArray(geombase, array, copyflag, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, maxHaloLWidth, &
    maxHaloUWidth, name, iospec, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateGBArray    
!
! !ARGUMENTS:
    type(ESMF_GeomBase), intent(in) :: geombase                
    type(ESMF_Array), intent(in) :: array              
    type(ESMF_CopyFlag), intent(in), optional :: copyflag       
    integer, intent(in), optional :: gridToFieldMap(:)    
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    integer, intent(in), optional :: maxHaloLWidth(:)
    integer, intent(in), optional :: maxHaloUWidth(:)
    character (len = *), intent(in), optional :: name   
    type(ESMF_IOSpec), intent(in), optional :: iospec   
    integer, intent(out), optional :: rc                
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_grid_array}.
! 
! The arguments are:
! \begin{description}
! \item [geombase] 
!       {\tt ESMF\_GeomBase} object. 
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[copyflag]}]
!       Indicates whether to copy the {\tt array} or reference it directly.
!       For valid values see \ref{opt:copyflag}.  The default is
!       {\tt ESMF\_DATA\_REF}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.  
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[maxHaloLWidth]}]
!       Lower bound of halo region.  The size of this array is the number
!       of dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method.
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[maxHaloUWidth]}]
!       Upper bound of halo region.  The size of this array is the number
!       of dimensions in the {\tt grid}.  However, ordering of the elements
!       needs to be the same as they appear in the {\tt field}.  Values default
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in
!       the size of the {\tt field}.  That is, for each gridded dimension the
!       {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth}
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored
!       in preparation for the implementation of the halo method. 
!       HALO OPERATION NOT IMPLEMENTED
! \item [{[name]}] 
!       {\tt Field} name. 
! \item [{[iospec]}] 
!       I/O specification. NOT IMPLEMENTED
! \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    type(ESMF_FieldType), pointer :: ftype  ! Pointer to new field
    integer :: localrc                       !  Local error code
    logical :: rcpresent                    ! Return code present

    integer :: fieldDimCount, fieldUngriddedDimCount 
    integer :: gridDimCount
    integer :: fieldUndistDimCount 
    integer :: i
    integer :: localGridToFieldMap(ESMF_MAXDIM)
    integer :: localMaxHaloLWidth (ESMF_MAXDIM)
    integer :: localMaxHaloUWidth (ESMF_MAXDIM)
    logical :: flipflop(ESMF_MAXDIM)
    type(ESMF_CopyFlag)    :: l_copyflag
    integer :: l_uglb(ESMF_MAXDIM), l_ugub(ESMF_MAXDIM)
    type (ESMF_IndexFlag) :: arrayIndexFlag, gridIndexFlag    

    ! Initialize pointers
    localrc = ESMF_RC_NOT_IMPL
    rcpresent = .FALSE.
    nullify(ftype)
    nullify(ESMF_FieldCreateGBArray%ftypep)

    ! Initialize return code   
    if(present(rc)) then
      rcpresent = .TRUE. 
      rc = ESMF_RC_NOT_IMPL
    endif     

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

    ! Get rank of proposed Field.  
    call ESMF_ArrayGet(array, rank=fieldDimCount, & 
                       indexflag=arrayIndexFlag, rc=localrc) 
    if (ESMF_LogMsgFoundError(localrc, &  
         ESMF_ERR_PASSTHRU, &  
         ESMF_CONTEXT, rc)) return   

    ! Get number of grid dimensions, number  
    ! of distributed grid dimensions, distgrid,  
    ! number of ungridded Field dimensions,  
    ! and number of undistributed Field Dimensions  
    call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, &
                      indexflag=gridIndexFlag, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &  
        ESMF_ERR_PASSTHRU, &  
        ESMF_CONTEXT, rc)) return  
 
    if(fieldDimCount .lt. gridDimCount) then  
        call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
             "- farray rank must be greater than or equal to grid rank", &  
               ESMF_CONTEXT, rc)   
        return
    endif  

    if(fieldDimCount .gt. gridDimCount) then
      if( (.not. present(ungriddedLBound)) .or. &
          (.not. present(ungriddedUBound)) ) then
        call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
         "- ungridded bounds must be present when Field has ungridded dimension(s)", &
           ESMF_CONTEXT, rc)
        return
      endif
    endif
 
    fieldUngriddedDimCount = fieldDimCount-gridDimCount  
    fieldUndistDimCount = fieldDimCount-gridDimCount  
 
    ! Error Check Input  
    if (present(gridToFieldMap)) then   
        if (size(gridToFieldMap) .ne. gridDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- gridToFieldMap size must equal to grid_rank", &  
                ESMF_CONTEXT, rc)   
            return  
        endif  
    endif  
 
    if (present(ungriddedLBound)) then   
       if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then  
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
               "- ungriddedLBound size must equal to array_rank-grid_rank", &  
               ESMF_CONTEXT, rc)   
          return  
       endif  
    endif  
 
    if (present(ungriddedUBound)) then   
       if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then  
          call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
                 "- ungriddedUBound size must equal to array_rank-grid_rank", &  
                 ESMF_CONTEXT, rc)   
          return  
       endif  
    endif  
 
    if (present(maxHaloLWidth)) then   
        if (size(maxHaloLWidth) .ne. gridDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- maxHaloLWidth must equal to grid dimCount", &  
                ESMF_CONTEXT, rc)   
            return  
        endif  
    endif  
 
    if (present(maxHaloUWidth)) then   
       if (size(maxHaloUWidth) .ne. gridDimCount) then  
           call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, &   
              "- maxHaloUWidth must equal to grid dimCount", &  
                ESMF_CONTEXT, rc)   
           return  
       endif  
    endif  
 
    if (.not.(arrayIndexFlag .eq. gridIndexFlag)) then
        call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &
         "- Array indexflag must be the same as the Grid indexflag", &
           ESMF_CONTEXT, rc)
        return
    endif

    if (present(copyflag)) then
        l_copyflag = copyflag
    else
        l_copyflag = ESMF_DATA_REF
    endif
 
    ! Set default gridToFieldMap
     if (present(gridToFieldMap)) then  
       localGridToFieldMap(1:gridDimCount) = &  
          gridToFieldMap (1:gridDimCount)  
     else  
       do i = 1, gridDimCount  
         localGridToFieldMap(i) = i  
       enddo  
     endif  

     ! gridToFieldMap elements must be in range 1...fieldRank and unique  
     ! algorithm to check element uniqueness:  
     !   run time: O(ESMF_MAXDIM)  
     !   memory:   O(2*ESMF_MAXDIM)  
     !          or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector  
     flipflop = .false.  
     do i = 1, gridDimCount  
        if(localGridToFieldMap(i) .lt. 1 .and. &  
          localGridToFieldMap(i) .gt. fieldDimCount) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                  "- gridToFieldMap element must be within range 1...array rank", &  
                    ESMF_CONTEXT, rc)   
            return  
        endif  
        if(flipflop(localGridToFieldMap(i))) then  
            call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, &   
                  "- gridToFieldMap element must be unique", &  
                    ESMF_CONTEXT, rc)   
            return  
        endif  
        flipflop(localGridToFieldMap(i)) = .true.  
     enddo  
 
     if(present(maxHaloLWidth)) then  
       localMaxHaloLWidth(1:gridDimCount) = &  
          maxHaloLWidth (1:gridDimCount)  
     else  
          localMaxHaloLWidth = 0  
     endif  
 
     if(present(maxHaloUWidth)) then  
       localMaxHaloUWidth(1:gridDimCount) = &  
          maxHaloUWidth (1:gridDimCount)  
     else  
          localMaxHaloUWidth = 0  
     endif  

    if(present(ungriddedLBound)) then
        l_uglb(1:size(ungriddedLBound)) = ungriddedLBound
    else
        l_uglb = -1
    endif
    if(present(ungriddedUBound)) then
        l_ugub(1:size(ungriddedUBound)) = ungriddedUBound
    else
        l_ugub = -1
    endif

    allocate(ftype, stat=localrc)
    if (ESMF_LogMsgFoundAllocError(localrc, "Allocating Field information", &
                                     ESMF_CONTEXT, rc)) return
    call ESMF_FieldInitialize(ftype, rc=localrc) 
    if (ESMF_LogMsgFoundAllocError(localrc, "Default initialize Field", &
                                     ESMF_CONTEXT, rc)) return

    ! Call construction method to allocate and initialize field internals.
    call ESMF_FieldConstructIANewArray(ftype, geombase, array, l_copyflag, &
                                     localgridToFieldMap, l_uglb, l_ugub, &
                                     localmaxHaloLWidth, localmaxHaloUWidth, name, &
                                     iospec, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
   

    ! Set return values.
    ESMF_FieldCreateGBArray%ftypep => ftype
    ESMF_INIT_SET_CREATED(ESMF_FieldCreateGBArray)

    call ESMF_FieldValidate(ESMF_FieldCreateGBArray, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) then
        ESMF_FieldCreateGBArray%ftypep%fieldstatus = ESMF_STATUS_INVALID
        return
    endif

    if(rcpresent) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateGBArray
!------------------------------------------------------------------------------


#define FieldCreateGBDataDoc() \
!---------------------------------------------------------------------------- @\
!BOPI @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGBData<rank><type><kind>(geombase, & @\
!   farray, indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, maxHaloLWidth, maxHaloUWidth, name, iospec, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGBData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_GeomBase) :: geombase                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray @\
!   type(ESMF_IndexFlag), intent(in)            :: indexflag @\
!   type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
!   type(ESMF_StaggerLoc), intent(in), optional ::staggerloc  @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   integer, intent(in), optional :: ungriddedLBound(:) @\
!   integer, intent(in), optional :: ungriddedUBound(:) @\
!   integer, intent(in), optional :: maxHaloLWidth(:) @\
!   integer, intent(in), optional :: maxHaloUWidth(:) @\
!   character (len=*), intent(in), optional :: name  @\
!   type(ESMF_IOSpec), intent(in), optional :: iospec @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a fortran data array and {\tt ESMF\_GeomBase}. @\
! For examples and @\
! associated documentations using this method see Section  @\
! \ref{sec:field:usage:create_2dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [geombase]  @\
!       {\tt ESMF\_GeomBase} object.  The dimCount of the @\
!       GeomBase must be smaller than or equal to the rank of the {\tt farray}. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field} @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the farray. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Whether to copy the {\tt farray} or reference directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see Section \ref{sec:opt:staggerloc}. @\
!       To create a custom stagger location see Section @\
!       \ref{sec:usage:staggerloc:adv}.  The default @\
!       value is ESMF\_STAGGERLOC\_CENTER. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the ESMF\_ ArrayRedist() operation. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of dimensions in the {\tt grid}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of dimensions in the {\tt grid}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[name]}]  @\
!       {\tt Field} name.  @\
! \item [{[iospec]}]  @\
!       I/O specification. NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOPI @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGBDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGBData" @\
  function ESMF_FieldCreateGBData##mrank##D##mtypekind(geombase, & @\
    farray, indexflag, copyflag,  gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, maxHaloLWidth, maxHaloUWidth, name, iospec, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGBData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_GeomBase) :: geombase                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag), intent(in)            :: indexflag @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    character (len=*), intent(in), optional :: name  @\
    type(ESMF_IOSpec), intent(in), optional :: iospec @\
    integer, intent(out), optional :: rc                @\
@\
    ! local variables @\
    integer          :: localrc @\
@\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ESMF_FieldCreateGBData##mrank##D##mtypekind = & @\
        ESMF_FieldCreateEmpty(name, iospec, rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_FieldSetCommit( & @\
        ESMF_FieldCreateGBData##mrank##D##mtypekind, & @\
        geombase, farray, indexflag, copyflag, & @\
        gridToFieldMap, & @\
        ungriddedLBound, ungriddedUBound, maxHaloLWidth, maxHaloUWidth, & @\
        rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_FieldValidate(ESMF_FieldCreateGBData##mrank##D##mtypekind, & @\
        rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGBData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGBData)



#define FieldCreateGBDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOPI @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateGBDataPtr<rank><type><kind>(geombase, & @\
!   farrayPtr, copyflag, staggerloc, gridToFieldMap, & @\
!   maxHaloLWidth, maxHaloUWidth, name, iospec, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateGBDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_GeomBase) :: geombase                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr @\
!   type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
!   type(ESMF_StaggerLoc), intent(in), optional ::staggerloc  @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   integer, intent(in), optional :: maxHaloLWidth(:) @\
!   integer, intent(in), optional :: maxHaloUWidth(:) @\
!   character (len=*), intent(in), optional :: name  @\
!   type(ESMF_IOSpec), intent(in), optional :: iospec @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a fortran data array and {\tt ESMF\_GeomBase}. @\
! For examples and @\
! associated documentations using this method see Section  @\
! \ref{sec:field:usage:create_2dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map}, @\
! \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [geombase]  @\
!       {\tt ESMF\_GeomBase} object.  The dimCount of the @\
!       GeomBase must be smaller than or equal to the rank of the {\tt farray}. @\
! \item [farrayPtr] @\
!       Native fortran data array to be copied/referenced in the {\tt field} @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the farray. @\
! \item [{[copyflag]}] @\
!       Whether to copy the {\tt farray} or reference directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[staggerloc]}] @\
!       Stagger location of data in grid cells.  For valid  @\
!       predefined values see Section \ref{sec:opt:staggerloc}. @\
!       To create a custom stagger location see Section @\
!       \ref{sec:usage:staggerloc:adv}.  The default @\
!       value is ESMF\_STAGGERLOC\_CENTER. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt grid}|s dimCount.  The list elements map each dimension @\
!       of the {\tt grid} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the ESMF\_ ArrayRedist() operation. @\
! \item [{[maxHaloLWidth]}] @\
!       Lower bound of halo region.  The size of this array is the number @\
!       of dimensions in the {\tt grid}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for maxHaloLWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not @\
!       implemented, the {\tt minHaloLWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method. @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[maxHaloUWidth]}] @\
!       Upper bound of halo region.  The size of this array is the number @\
!       of dimensions in the {\tt grid}.  However, ordering of the elements @\
!       needs to be the same as they appear in the {\tt farray}.  Values default @\
!       to 0.  If values for maxHaloUWidth are specified they must be reflected in @\
!       the size of the {\tt farray}.  That is, for each gridded dimension the @\
!       {\tt farray} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} @\
!       + {\tt computationalCount}, {\tt exclusiveCount} ).  Although the halo operation is not @\
!       implemented, the {\tt maxHaloUWidth} is checked for validity and stored @\
!       in preparation for the implementation of the halo method.  @\
!       HALO OPERATION NOT IMPLEMENTED @\
! \item [{[name]}]  @\
!       {\tt Field} name.  @\
! \item [{[iospec]}]  @\
!       I/O specification. NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOPI @\
!---------------------------------------------------------------------------- @\

#define FieldCreateGBDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateGBDataPtr" @\
  function ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geombase, & @\
    farrayPtr, copyflag,  gridToFieldMap, & @\
    maxHaloLWidth, maxHaloUWidth, name, iospec, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_GeomBase) :: geombase                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: maxHaloLWidth(:) @\
    integer, intent(in), optional :: maxHaloUWidth(:) @\
    character (len=*), intent(in), optional :: name  @\
    type(ESMF_IOSpec), intent(in), optional :: iospec @\
    integer, intent(out), optional :: rc                @\
@\
    ! local variables @\
    integer          :: localrc @\
@\
    if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
    localrc = ESMF_RC_NOT_IMPL @\
@\
    ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind = & @\
        ESMF_FieldCreateEmpty(name, iospec, rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_FieldSetCommit( & @\
        ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind, & @\
        geombase, farrayPtr, copyflag, & @\
        gridToFieldMap, & @\
        maxHaloLWidth, maxHaloUWidth, & @\
        rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    call ESMF_FieldValidate(ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind, & @\
        rc=localrc) @\
@\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateGBDataPtr)

!------------------------------------------------------------------------------

end module ESMF_FieldCreateGeMod
