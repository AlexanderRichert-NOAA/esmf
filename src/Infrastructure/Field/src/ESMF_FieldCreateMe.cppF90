! $Id: ESMF_FieldCreateMe.cppF90,v 1.1 2009/01/02 19:48:56 feiliu Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2008, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_FieldCreateMe.F90"
!==============================================================================
!
! ESMF FieldCreateMe module
module ESMF_FieldCreateMeMod
!
!==============================================================================
!
! This file contains the Mesh related FieldCreate() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below.  they are created by the files which
!   define various macros. >
^include "ESMF.h"
#include "ESMF_TypeKindRankMacros.hcppF90"

!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_LogErrMod
  use ESMF_IOSpecMod
  use ESMF_ArraySpecMod
  use ESMF_LocalArrayMod
  use ESMF_DELayoutMod
  use ESMF_StaggerLocMod
  use ESMF_GridMod
  use ESMF_MeshMod
  use ESMF_LocStreamMod
  use ESMF_GeomBaseMod
  use ESMF_ArrayMod
  use ESMF_ArrayGetMod
  use ESMF_ArrayCreateMod
  
  use ESMF_FieldMod
  use ESMF_FieldSetCoMod
  use ESMF_FieldCreateGeMod
  
  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
!  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_FieldCreateMe.cppF90,v 1.1 2009/01/02 19:48:56 feiliu Exp $'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================


! -------------------------- ESMF-public method -------------------------------
!------------------------------------------------------------------------------
  public

!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateMeshArraySpec"
!BOP
! !IROUTINE:   ESMF_FieldCreate - Create a Field from Mesh and ArraySpec

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name, iospec, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec
!
! !ARGUMENTS:
    type(ESMF_Mesh) :: mesh               
    type(ESMF_ArraySpec), intent(inout) :: arrayspec     
    integer, intent(in), optional :: gridToFieldMap(:)    
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    character (len=*), intent(in), optional :: name 
    type(ESMF_IOSpec), intent(in), optional :: iospec 
    integer, intent(out), optional :: rc              
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field} and allocate space internally for an
! {\tt ESMF\_Array}.  Return a new {\tt ESMF\_Field}. For an example and
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_grid_arrayspec}.
! 
! The arguments are:
! \begin{description}
! \item [mesh] 
!       {\tt ESMF\_Mesh} object. 
! \item [arrayspec]
!       Data type and kind specification. 
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.  
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[name]}] 
!       {\tt Field} name. 
! \item [{[iospec]}] 
!       I/O specification. ! NOT IMPLEMENTED
! \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                          !  Local error code
    type(ESMF_GeomBase) :: geombase

    ! Initialize pointers
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code   
    if(present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)
    ESMF_INIT_CHECK_SHALLOW(ESMF_ArraySpecGetInit, ESMF_ArraySpecInit, arrayspec)
 
    ! Create GeomBase from Mesh
    geombase=ESMF_GeomBaseCreate(mesh, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &
                                     ESMF_CONTEXT, rc)) return

    ! Create Field from GeomBase
    ESMF_FieldCreateMeshArraySpec=ESMF_FieldCreateGBArraySpec(geombase, &
        arrayspec, gridToFieldMap, &
        ungriddedLBound, ungriddedUBound, &
        name=name, iospec=iospec, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &
                                     ESMF_CONTEXT, rc)) return

    if(present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateMeshArraySpec
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldCreateMeshArray"
!BOP
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Array

! !INTERFACE:
  ! Private name; call using ESMF_FieldCreate()
  function ESMF_FieldCreateMeshArray(mesh, array, copyflag, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name, iospec, rc)
!
! !RETURN VALUE:
    type(ESMF_Field) :: ESMF_FieldCreateMeshArray    
!
! !ARGUMENTS:
    type(ESMF_Mesh), intent(in) :: mesh                
    type(ESMF_Array), intent(in) :: array              
    type(ESMF_CopyFlag), intent(in), optional :: copyflag       
    integer, intent(in), optional :: gridToFieldMap(:)    
    integer, intent(in), optional :: ungriddedLBound(:)
    integer, intent(in), optional :: ungriddedUBound(:)
    character (len = *), intent(in), optional :: name   
    type(ESMF_IOSpec), intent(in), optional :: iospec   
    integer, intent(out), optional :: rc                
!
! !DESCRIPTION:
! Create an {\tt ESMF\_Field}.  This version of creation
! assumes the data exists already and is being
! passed in through an {\tt ESMF\_Array}.  For an example and
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_grid_array}.
! 
! The arguments are:
! \begin{description}
! \item [grid] 
!       {\tt ESMF\_Mesh} object. 
! \item [array]
!       {\tt ESMF\_Array} object.
! \item [{[copyflag]}]
!       Indicates whether to copy the {\tt array} or reference it directly.
!       For valid values see \ref{opt:copyflag}.  The default is
!       {\tt ESMF\_DATA\_REF}.
! \item [{[gridToFieldMap]}]
!       List with number of elements equal to the
!       {\tt grid}|s dimCount.  The list elements map each dimension
!       of the {\tt grid} to a dimension in the {\tt field} by
!       specifying the appropriate {\tt field} dimension index. The default is to
!       map all of the {\tt grid}|s dimensions against the lowest dimensions of
!       the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal
!       to one and smaller than or equal to the {\tt field} rank.
!       It is erroneous to specify the same {\tt gridToFieldMap} entry
!       multiple times. The total ungridded dimensions in the {\tt field}
!       are the total {\tt field} dimensions less
!       the dimensions in
!       the {\tt grid}.  Ungridded dimensions must be in the same order they are
!       stored in the {\t field}.  
! \item [{[ungriddedLBound]}]
!       Lower bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[ungriddedUBound]}]
!       Upper bounds of the ungridded dimensions of the {\tt field}.
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
!       dimensions in the {\tt field}.  All ungridded dimensions of the
!       {\tt field} are also undistributed. When field dimension count is
!       greater than grid dimension count, both ungriddedLBound and ungriddedUBound
!       must be specified. When both are specified the values are checked
!       for consistency.  Note that the the ordering of
!       these ungridded dimensions is the same as their order in the {\tt field}.
! \item [{[name]}] 
!       {\tt Field} name. 
! \item [{[iospec]}] 
!       I/O specification. NOT IMPLEMENTED
! \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
    integer :: localrc                       !  Local error code
    type(ESMF_GeomBase) :: geombase

    ! Initialize pointers
    localrc = ESMF_RC_NOT_IMPL

    ! Initialize return code   
    if (present(rc)) then
      rc = ESMF_RC_NOT_IMPL
    endif     

    ! check init status of input parameters
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

    ! Create GeomBase from Mesh
    geombase=ESMF_GeomBaseCreate(mesh, rc=localrc)
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &
                                     ESMF_CONTEXT, rc)) return

    ! Create Field from GeomBase
    ESMF_FieldCreateMeshArray=ESMF_FieldCreateGBArray(geombase, array, copyflag, &
    gridToFieldMap, ungriddedLBound, ungriddedUBound, &
    name=name, iospec=iospec, rc=localrc)

    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &
                                     ESMF_CONTEXT, rc)) return
 
    if (present(rc)) rc = ESMF_SUCCESS

  end function ESMF_FieldCreateMeshArray
!------------------------------------------------------------------------------

  
#define FieldCreateMeshDataDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Fortran array @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateMeshData<rank><type><kind>(mesh, & @\
!   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
!   ungriddedUBound, name, iospec, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateMeshData<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Mesh) :: mesh                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray @\
!   type(ESMF_IndexFlag), intent(in)            :: indexflag @\
!   type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   integer, intent(in), optional :: ungriddedLBound(:) @\
!   integer, intent(in), optional :: ungriddedUBound(:) @\
!   character (len=*), intent(in), optional :: name  @\
!   type(ESMF_IOSpec), intent(in), optional :: iospec @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a fortran data array and {\tt ESMF\_Mesh}. @\
! For examples and @\
! associated documentations using this method see Section  @\
! \ref{sec:field:usage:create_2dptr}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr_map}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dmesh_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [mesh]  @\
!       {\tt ESMF\_Mesh} object.  The dimCount of the @\
!       Mesh must be smaller than or equal to the rank of the {\tt farray}. @\
! \item [farray] @\
!       Native fortran data array to be copied/referenced in the {\tt field} @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the farray. @\
! \item[indexflag] @\
!       Indicate how DE-local indices are defined. See section @\
!       \ref{opt:indexflag} for a list of valid indexflag options. @\
! \item [{[copyflag]}] @\
!       Whether to copy the {\tt farray} or reference directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt mesh}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt mesh}.  Unmeshded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the ESMF\_ ArrayRedist() operation. @\
! \item [{[ungriddedLBound]}] @\
!       Lower bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[ungriddedUBound]}] @\
!       Upper bounds of the ungridded dimensions of the {\tt field}. @\
!       The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded @\
!       dimensions in the {\tt field}.  All ungridded dimensions of the @\
!       {\tt field} are also undistributed. When field dimension count is @\
!       greater than mesh dimension count, both ungriddedLBound and ungriddedUBound @\
!       must be specified. When both are specified the values are checked @\
!       for consistency.  Note that the the ordering of @\
!       these ungridded dimensions is the same as their order in the {\tt farray}. @\
! \item [{[name]}]  @\
!       {\tt Field} name.  @\
! \item [{[iospec]}]  @\
!       I/O specification. NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateMeshDataMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateMeshData" @\
  function ESMF_FieldCreateMeshData##mrank##D##mtypekind(mesh, & @\
    farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & @\
    ungriddedUBound, name, iospec, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateMeshData##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Mesh) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), target :: farray @\
    type(ESMF_IndexFlag), intent(in)            :: indexflag @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    integer, intent(in), optional :: ungriddedLBound(:) @\
    integer, intent(in), optional :: ungriddedUBound(:) @\
    character (len=*), intent(in), optional :: name  @\
    type(ESMF_IOSpec), intent(in), optional :: iospec @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_GeomBase) :: geombase @\
@\
    ! Initialize pointers@\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)@\
@\
@\
    ! Create GeomBase from Mesh@\
    geombase=ESMF_GeomBaseCreate(mesh,rc=localrc)@\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
                                     ESMF_CONTEXT, rc)) return@\
@\
@\
       ESMF_FieldCreateMeshData##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBData##mrank##D##mtypekind(geombase, & @\
                               farray, indexflag, copyflag,  gridToFieldMap, ungriddedLBound, & @\
                               ungriddedUBound, & @\
                               name=name, iospec=iospec, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateMeshData##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateMeshData)


#define FieldCreateMeshDataPtrDoc() \
!---------------------------------------------------------------------------- @\
!BOP @\
! !IROUTINE: ESMF_FieldCreate - Create a Field from Mesh and Fortran array pointer @\
! @\
! !INTERFACE: @\
! ! Private name; call using ESMF_FieldCreate() @\
! function ESMF_FieldCreateMeshDataPtr<rank><type><kind>(mesh, & @\
!   farrayPtr, copyflag, gridToFieldMap, & @\
!   name, iospec, rc) @\
! @\
! !RETURN VALUE: @\
!   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr<rank><type><kind> @\
! @\
! !ARGUMENTS: @\
!   type(ESMF_Mesh) :: mesh                  @\
!   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr @\
!   type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
!   integer, intent(in), optional :: gridToFieldMap(:)     @\
!   character (len=*), intent(in), optional :: name  @\
!   type(ESMF_IOSpec), intent(in), optional :: iospec @\
!   integer, intent(out), optional :: rc                @\
! @\
! !DESCRIPTION: @\
! Create an {\tt ESMF\_Field} from a fortran data array and {\tt ESMF\_Mesh}. @\
! For examples and @\
! associated documentations using this method see Section  @\
! \ref{sec:field:usage:create_2dptr}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr_map}, @\
! \ref{sec:field:usage:create_2dmesh_3dptr_map_halo}, and @\
! \ref{sec:field:usage:create_5dmesh_7dptr_2dungridded}. @\
! @\
! The arguments are: @\
! \begin{description} @\
! \item [mesh]  @\
!       {\tt ESMF\_Mesh} object.  The dimCount of the @\
!       Mesh must be smaller than or equal to the rank of the {\tt farray}. @\
! \item [farrayPtr] @\
!       Native fortran data array to be copied/referenced in the {\tt field} @\
!       The {\tt field} dimension (dimCount) will be the same as the dimCount @\
!       for the farray. @\
! \item [{[copyflag]}] @\
!       Whether to copy the {\tt farray} or reference directly. @\
!       For valid values see \ref{opt:copyflag}.  The default is @\
!       {\tt ESMF\_DATA\_REF}. @\
! \item [{[gridToFieldMap]}] @\
!       List with number of elements equal to the @\
!       {\tt mesh}|s dimCount.  The list elements map each dimension @\
!       of the {\tt mesh} to a dimension in the {\tt farray} by @\
!       specifying the appropriate {\tt farray} dimension index. The default is to @\
!       map all of the {\tt mesh}|s dimensions against the lowest dimensions of @\
!       the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). @\
!       The values of all {\tt gridToFieldMap} entries must be greater than or equal @\
!       to one and smaller than or equal to the {\tt farray} rank. @\
!       It is erroneous to specify the same {\tt gridToFieldMap} entry @\
!       multiple times. The total ungridded dimensions in the {\tt field} @\
!       are the total {\tt farray} dimensions less @\
!       the total (distributed + undistributed) dimensions in @\
!       the {\tt mesh}.  Unmeshded dimensions must be in the same order they are @\
!       stored in the {\t farray}.  Permutations of the order of @\
!       dimensions are handled via individual communication methods.  For example, @\
!       an undistributed dimension can be remapped to a distributed dimension @\
!       as part of the ESMF\_ ArrayRedist() operation. @\
! \item [{[name]}]  @\
!       {\tt Field} name.  @\
! \item [{[iospec]}]  @\
!       I/O specification. NOT IMPLEMENTED @\
! \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
! \end{description} @\
! @\
!EOP @\
!---------------------------------------------------------------------------- @\

#define FieldCreateMeshDataPtrMacro(mname, mtypekind, mrank, mdim, mlen, mrng, mloc) \
!---------------------------------------------------------------------------- @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_FieldCreateMeshDataPtr" @\
  function ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind(mesh, & @\
    farrayPtr, copyflag, gridToFieldMap, & @\
    name, iospec, rc) @\
@\
    ! return value @\
    type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind @\
@\
    ! input arguments @\
    type(ESMF_Mesh) :: mesh                  @\
    mname (ESMF_KIND_##mtypekind), dimension(mdim), pointer :: farrayPtr @\
    type(ESMF_CopyFlag), intent(in), optional   :: copyflag @\
    integer, intent(in), optional :: gridToFieldMap(:)     @\
    character (len=*), intent(in), optional :: name  @\
    type(ESMF_IOSpec), intent(in), optional :: iospec @\
    integer, intent(out), optional :: rc                @\
@\
    integer :: localrc                       !  Local error code@\
    type(ESMF_GeomBase) :: geombase @\
@\
    ! Initialize pointers@\
    localrc = ESMF_RC_NOT_IMPL@\
@\
    ! Initialize return code   @\
    if (present(rc)) then@\
      rc = ESMF_RC_NOT_IMPL@\
    endif     @\
@\
    ! check init status of input parameters@\
    ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc)@\
@\
@\
    ! Create GeomBase from Mesh@\
    geombase=ESMF_GeomBaseCreate(mesh,rc=localrc)@\
    if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &@\
                                     ESMF_CONTEXT, rc)) return@\
@\
@\
       ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind = & @\
              ESMF_FieldCreateGBDataPtr##mrank##D##mtypekind(geombase, & @\
                               farrayPtr, copyflag,  gridToFieldMap, & @\
                               name=name, iospec=iospec, rc=localrc) @\
    if (ESMF_LogMsgFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rc)) return @\
@\
@\
    if (present(rc)) rc = ESMF_SUCCESS @\
  end function ESMF_FieldCreateMeshDataPtr##mrank##D##mtypekind  @\
!------------------------------------------------------------------------------ @\

TypeKindRankDeclarationMacro(FieldCreateMeshDataPtr)

!------------------------------------------------------------------------------

end module ESMF_FieldCreateMeMod
